<!DOCTYPE html>
<html lang=zh-CN data-theme="light">
	
<script src="/js/plugins/toggleTheme.js"></script>

	<script>
		setTheme();
	</script>
	<head>
		
<title>12.1 动态内存与智能指针 | The technology-sea for kin12138</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/images/icon/favicon.ico">
<link href="/css/plugins/print.css" media="print" rel="stylesheet" />

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="c++,c++ primer,动态内存,智能指针,shared_ptr,unique_ptr,weak_ptr,new,delete,">
<meta name="description" content="">



<script src="/js/plugins/jquery.min.js"></script>


<script src="/js/plugins/hljs.min.js"></script>


<script src="/js/plugins/init.js"></script>


<script src="/js/plugins/hide.js"></script>


<script src="/js/plugins/tabs.js"></script>



    







    

	<meta name="generator" content="Hexo 7.3.0"></head>

	<body>
		<header class="sticky-header">
	<nav>
		<div class="nav-left">
			<a href="/" class="logo">
				<img no-lazy src="/images/headers_icon/logo.webp" alt="Quieter">
			</a>
			<ul class="breadcrumb" id="breadcrumb"></ul>
		</div>
		<div class="nav-right">
			<ul>
				
					<li>
						<a href="/">
						  主页
						</a>
					</li>
				
					<li>
						<a href="/categories">
						  类别
						</a>
					</li>
				
					<li>
						<a href="/tags">
						  标签
						</a>
					</li>
				
					<li>
						<a href="/archives">
						  归档
						</a>
					</li>
				
					<li>
						<a href="/galleries">
						  相册
						</a>
					</li>
				
					<li>
						<a href="/links">
						  链接
						</a>
					</li>
				
					<li>
						<a href="/about">
						  关于
						</a>
					</li>
								  
			</ul>
		</div>
		<div class="nav-right-close">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
				<path fill="none" d="M0 0h24v24H0z" />
				<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
			</svg>
		</div>

		<div class="sidebar">
    <div class="topo">
        <p>The technology-sea for kin12138</p>
    </div>
    <ul>
        
        <li>
            <a href="/">
                主页
            </a>
        </li>
        
        <li>
            <a href="/categories">
                类别
            </a>
        </li>
        
        <li>
            <a href="/tags">
                标签
            </a>
        </li>
        
        <li>
            <a href="/archives">
                归档
            </a>
        </li>
        
        <li>
            <a href="/galleries">
                相册
            </a>
        </li>
        
        <li>
            <a href="/links">
                链接
            </a>
        </li>
        
        <li>
            <a href="/about">
                关于
            </a>
        </li>
        
    </ul>
    <div class="sidebar-footer">
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Weibo.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Tieba.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Bilibili.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/github.webp" alt="Quieter">
        </a>
        
    </div>
</div>
<div class='shelter'>
    <script>
        $(function() {
            $('.nav-right-close > svg').click(function() {
                $('.sidebar').animate({
                    right: "0"
                }, 500);
                $('.shelter').fadeIn("slow");
            
                var element = $('.topo');
                element.addClass('custom-style');
            
                var links = null;
                if ("") {
                    links = "".split(',');
                } else {
                    links = "/images/random_top_img/01.webp,/images/random_top_img/02.webp,/images/random_top_img/03.webp,/images/random_top_img/04.webp,/images/random_top_img/05.webp,/images/random_top_img/06.webp,/images/random_top_img/07.webp".split(',');
                }
            
                var randomLink = links[Math.floor(Math.random() * links.length)];
                element.css('background-image', "url('" + randomLink + "')");
            });
          
            $('.shelter').click(function(e) {
                $('.sidebar').animate({
                    right: "-100%"
                }, 500);
                $('.shelter').fadeOut("slow");
            });
        });      
    </script>
</div>
	</nav>

	
		<div class="header-background"></div>
	

	<script>
		const name = 'post';
		const ul = document.querySelectorAll('.nav-right ul')[0];
		const lis = ul.querySelectorAll('li');

		if (name == 'home') {
			lis[0].classList.add('select');
		} else {
			for (let i = 0; i < lis.length; i++) {
				const li = lis[i];
				const a = li.querySelector('a');
				if (name === a.href.split('/')[3]) {
					li.classList.add('select');
				}
			}
		}
	</script>
	
	<script>
		var element = document.querySelector('.header-background');
		if(element) {
			element.classList.add('custom-style');
			var links = null;
			if("")
			{
				links = "".split(',');
			} else
			{
				links = "/images/random_top_img/01.webp,/images/random_top_img/02.webp,/images/random_top_img/03.webp,/images/random_top_img/04.webp,/images/random_top_img/05.webp,/images/random_top_img/06.webp,/images/random_top_img/07.webp".split(',');
			}
			var randomLink = links[Math.floor(Math.random() * links.length)];
			element.style.backgroundImage = "url('" + randomLink + "')";
		}
	</script>

	
<script src="/js/plugins/breadcrumb.js"></script>

	<script>
		var menus_title = [];
		
			menus_title.push({home: '主页'});
		
			menus_title.push({categories: '类别'});
		
			menus_title.push({tags: '标签'});
		
			menus_title.push({archives: '归档'});
		
			menus_title.push({galleries: '相册'});
		
			menus_title.push({links: '链接'});
		
			menus_title.push({about: '关于'});
		
		
			
				postsBreadcrumb(
					document.getElementById('breadcrumb'),
					"类别",
					"/categories",
					"technology",
					"/categories/technology"
				);
			
		
	</script>
</header>

<div class="main-wrapper">
    <main class="post">
        <header class="main-header">
	
		
			
				
<link rel="stylesheet" href="/css/plugins/fancybox.css">

				
<script src="/js/plugins/fancybox.umd.js"></script>

				
<script src="/js/plugins/fancybox.js"></script>

			
			<div class="post-header-background-content">
				<ul class="post-header-tag">
					
						
							<li><a href="/tags/c++"><span>c++</span></a></li>
						
							<li><a href="/tags/c++ primer"><span>c++ primer</span></a></li>
						
							<li><a href="/tags/动态内存"><span>动态内存</span></a></li>
						
							<li><a href="/tags/智能指针"><span>智能指针</span></a></li>
						
							<li><a href="/tags/shared_ptr"><span>shared_ptr</span></a></li>
						
							<li><a href="/tags/unique_ptr"><span>unique_ptr</span></a></li>
						
							<li><a href="/tags/weak_ptr"><span>weak_ptr</span></a></li>
						
							<li><a href="/tags/new"><span>new</span></a></li>
						
							<li><a href="/tags/delete"><span>delete</span></a></li>
						
					
				</ul>
				
				<h1>12.1 动态内存与智能指针</h1>
		
				
		
				<div class="post-header-info">
					<svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
					xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
						<path
							d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
							p-id="2902" fill="#ffffff"></path>
					</svg>
					<div class="post-header-info-author">
						<a href="/about">kin12138</a>
					</div>
					
						<div class="post-header-info-categories">
							
								<a href="/categories/technology">technology</a>
							
						</div>
					
					<time>2025/04/10 00:00:00</time>
				</div>
		
				
					<div class="post-header-stat">
						<svg version="1.0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
						viewBox="0 0 200 200" enable-background="new 0 0 200 200" xml:space="preserve" width="20" height="20">
							<path fill="#FFFFFF" d="M187.2,165.6c0,2.6-2.1,4.7-4.7,4.7H17.5c-2.6,0-4.7-2.1-4.7-4.7s2.1-4.7,4.7-4.7h165.1
								C185.2,160.9,187.2,163,187.2,165.6z"/>
							<path fill="#FFFFFF" d="M17.5,29.7c2.6,0,4.7,2.1,4.7,4.7v131.2c0,2.6-2.1,4.7-4.7,4.7s-4.7-2.1-4.7-4.7V34.4
								C12.8,31.8,14.9,29.7,17.5,29.7z M77.9,91.5c1.8,1.8,1.8,4.8,0,6.6l-39.8,39.8c-1.9,1.8-4.9,1.7-6.6-0.2c-1.7-1.8-1.7-4.6,0-6.4
								l39.8-39.8C73.1,89.6,76,89.6,77.9,91.5z M169.9,70.2c1.6,2.1,1.1,5-0.9,6.5c0,0,0,0,0,0l-64.2,48.2c-2.1,1.5-5,1.1-6.6-0.9
								c-1.6-2.1-1.1-5,0.9-6.5c0,0,0,0,0,0l64.2-48.2C165.4,67.7,168.3,68.1,169.9,70.2L169.9,70.2z"/>
							<path fill="#FFFFFF" d="M104.6,124.5c-1.8,1.8-4.8,1.8-6.6,0L71.6,98.1c-1.8-1.8-1.8-4.8,0-6.6c1.8-1.8,4.8-1.8,6.6,0l26.3,26.3
								C106.4,119.6,106.4,122.6,104.6,124.5C104.6,124.4,104.6,124.4,104.6,124.5z"/>
						</svg>
		
						
							
<script src="/js/plugins/wordCount.js"></script>

							<p class="post-count">文字数：---</p>
						
		
						
							<p id="busuanzi_container_page_pv" style='display:none;'>阅读数：<span id="busuanzi_value_page_pv"></span></p>
						
					</div>
				
			</div>
		
	
</header>
        <div class="post-content article-container">
            <article class="post-content-info">
                <h2 id="动态内存概述"><a href="#动态内存概述" class="headerlink" title="动态内存概述"></a>动态内存概述</h2><ul>
<li><strong>静态内存</strong>：用来保存<strong>局部 static 对象</strong>，<strong>类 static 成员</strong>，<strong>定义在任何函数之外的变量</strong></li>
<li><strong>栈内存</strong>：保存<strong>定义在函数内的非 static 对象</strong></li>
<li><strong>静态内存或栈内存中的对象</strong>由<strong>编译器自动创建和销毁</strong></li>
<li>对于<strong>栈对象</strong>，<strong>只有在其定义的程序块运行时才存在</strong></li>
<li><strong>static 对象</strong>在<strong>使用前分配</strong>，在<strong>程序结束时销毁</strong></li>
<li>除静态内存和栈内存之外，每个程序还有一个内存池，称为<strong>自由空间(free memory) 或 堆(heap)</strong>，来<strong>存储动态分配(dynamically allocate)的对象</strong>,即在程序运行时分配的对象</li>
<li><strong>动态对象的生存周期由程序来控制</strong></li>
</ul>
<h2 id="动态内存与智能指针概述"><a href="#动态内存与智能指针概述" class="headerlink" title="动态内存与智能指针概述"></a>动态内存与智能指针概述</h2><ul>
<li>c++ 中动态内存由一对运算符管理：<ul>
<li><strong>new</strong>：在动态内存中为对象分配内存空间并<strong>返回一个指向该对象的指针</strong></li>
<li><strong>delete</strong>：<strong>接受一个动态对象的指针</strong>，销毁该对象，并释放与之关联的内存</li>
</ul>
</li>
<li><strong>忘记释放内存</strong>，会<strong>产生内存泄漏</strong></li>
<li>在<strong>尚有指针引用内存的情况下释放内存</strong>，会<strong>产生引用非法内存的指针</strong></li>
<li>标准库提供两种<strong>智能指针(smart pointer)来管理内存</strong>，与普通指针的区别是<strong>智能指针自动释放所指向的对象</strong></li>
<li>而这两种智能指针的区别是<strong>管理底层指针的方式</strong>：<ul>
<li><strong>shared_ptr：允许多个指针指向同一个对象</strong></li>
<li><strong>unique_ptr：独占所指向的对象</strong></li>
</ul>
</li>
<li>标准库还定义了一个名为 <strong>weak_ptr</strong> 的伴随类，是一种<strong>弱引用</strong>，<strong>指向 shared_ptr 所管理的对象</strong>。</li>
<li>三种类型都定义在 <strong>memory 头文件</strong>中</li>
</ul>
<h2 id="shared-ptr-类"><a href="#shared-ptr-类" class="headerlink" title="shared_ptr 类"></a>shared_ptr 类</h2><ul>
<li>智能指针也是模板，默认初始化的的智能指针保存一个空指针</li>
<li>解引用一个智能指针返回它指向的对象</li>
<li>在一个<strong>条件判断中使用智能指针，就是检测它是否为空</strong></li>
</ul>
<h3 id="shared-ptr-和-unique-ptr-都支持的操作"><a href="#shared-ptr-和-unique-ptr-都支持的操作" class="headerlink" title="shared_ptr 和 unique_ptr 都支持的操作"></a>shared_ptr 和 unique_ptr 都支持的操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>shared_ptr<T> sp <br> unique_ptr<T> up</td>
<td>空智能指针，可以指向类型为 T 的对象</td>
</tr>
<tr>
<td>p</td>
<td><strong>将 p 用作一个条件判断，若 p 指向一个对象，则为 true</strong></td>
</tr>
<tr>
<td>*p</td>
<td>解引用 p，返回它指向的对象</td>
</tr>
<tr>
<td>p -&gt; mem</td>
<td>等价于 (*p).mem</td>
</tr>
<tr>
<td>p.get()</td>
<td>返回 p 中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也消失了</td>
</tr>
<tr>
<td><strong>swap(p, q) <br> p.swap(q)</strong></td>
<td><strong>交换 p, q 中的指针</strong></td>
</tr>
</tbody>
</table>
</div>
<h3 id="shared-ptr-独有的操作"><a href="#shared-ptr-独有的操作" class="headerlink" title="shared_ptr 独有的操作"></a>shared_ptr 独有的操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>make_shared\<T> (args)</strong></td>
<td>返回一个 shared_ptr，指向动态分配的类型为 T 的对象。使用 args 初始化此对象</td>
</tr>
<tr>
<td><strong>shared_ptr\<T> p(q)</strong></td>
<td>p 是 shared_ptr 的拷贝；<br> <strong>此操作会递增 q 中的计数器</strong> <br> q 中的指针必须能转换成 T*</td>
</tr>
<tr>
<td><strong>p = q</strong></td>
<td>p 和 q 都是 shared_ptr，所保存的指针必须能相互转换；<br> <strong>此操作会递减 p 的引用计数</strong>，<strong>递增 q 的引用计数</strong> <br> 若 p 的引用计数变为 0，则将其管理的<strong>原内存释放</strong></td>
</tr>
<tr>
<td>p.unique()</td>
<td>若 p.use_count() 为 1，返回 true，否则返回 false</td>
</tr>
<tr>
<td>p.use_count()</td>
<td>返回与 p 共享对象的智能指针数量，主要用于调试</td>
</tr>
</tbody>
</table>
</div>
<h3 id="make-shared-函数"><a href="#make-shared-函数" class="headerlink" title="make_shared 函数"></a>make_shared 函数</h3><ul>
<li>此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 指向一个值为 42 的 int 的 shared_ptr</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">42</span>);<br><span class="hljs-comment">// p4 指向一个值为 &quot;9999999999&quot; 的string</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt; (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>);<br><span class="hljs-comment">// p5 指向一个值初始化的 int ，即值为 0</span><br>shared_ptr&lt;string&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt; ();<br></code></pre></td></tr></table></figure>
<h3 id="shared-ptr-的拷贝和赋值"><a href="#shared-ptr-的拷贝和赋值" class="headerlink" title="shared_ptr 的拷贝和赋值"></a>shared_ptr 的拷贝和赋值</h3><ul>
<li>进行拷贝或赋值时，<strong>每个 shared_ptr 都会记录有多少个其他 shared_ptr 指向同一个对象</strong><ul>
<li>用<strong>一个 shared_ptr 初始化 另一个 shared_ptr</strong>、将它<strong>作为一个参数传递给一个函数</strong>、<strong>作为函数的返回值</strong>，都会<strong>增加 shared_ptr 的引用计数值</strong></li>
<li><strong>给一个 shared_ptr 赋予一个新值</strong>、<strong>shared_ptr 被销毁</strong>（例如离开其作用域），都会<strong>递减引用计数值</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">42</span>);     <span class="hljs-comment">// r 指向 int，只有一个引用者</span><br>r = q;      <span class="hljs-comment">// 给 r 赋值，令它指向另一个地址</span><br>            <span class="hljs-comment">// 递增 q 指向的对象的引用计数</span><br>            <span class="hljs-comment">// 递减 r 原来指向的对象的引用计数</span><br>            <span class="hljs-comment">// r 原来指向的对象的引用计数为 0，释放该对象</span><br></code></pre></td></tr></table></figure>
<h3 id="shared-ptr-自动销毁所管理的对象"><a href="#shared-ptr-自动销毁所管理的对象" class="headerlink" title="shared_ptr 自动销毁所管理的对象"></a>shared_ptr 自动销毁所管理的对象</h3><ul>
<li>通过 <strong>析构函数(destructor)</strong> 完成销毁工作</li>
<li>shared_ptr 的析构函数会递减它所指向对象的引用计数。</li>
<li>如果引用计数为 0，则 shared_ptr 的析构函数会销毁该对象，并释放它所占用的内存</li>
</ul>
<h3 id="shared-ptr-会自动释放相关联的内存"><a href="#shared-ptr-会自动释放相关联的内存" class="headerlink" title="shared_ptr 会自动释放相关联的内存"></a>shared_ptr 会自动释放相关联的内存</h3><ul>
<li>当动态对象不再使用时，shared_ptr 类会自动释放动态对象</li>
<li>对于一块儿内存，shared_ptr <strong>保证只要有任何 shared_ptr 对象引用它，则它就不会被释放掉</strong></li>
<li><strong>如果将 shared_ptr 存放在一个容器中</strong>，而后不再需要全部元素，只需要使用容器中的一部分元素，要记得用 erase 删除不再需要的那些 shared_ptr 元素</li>
</ul>
<h2 id="程序使用动态内存出于以下三种原因之一"><a href="#程序使用动态内存出于以下三种原因之一" class="headerlink" title="程序使用动态内存出于以下三种原因之一"></a>程序使用动态内存出于以下三种原因之一</h2><ul>
<li><strong>程序不知道自己需要使用多少个对象</strong></li>
<li><strong>程序不知道所需对象的准确类型</strong></li>
<li><strong>程序需要再多个对象间共享底层数据</strong></li>
</ul>
<h3 id="定义-strBlob-类"><a href="#定义-strBlob-类" class="headerlink" title="定义 strBlob 类"></a>定义 strBlob 类</h3><ul>
<li>定义一个管理 string 的类 strBlob, 为每个 strBlob 设置一个 shared_ptr 管理动态分配的 vector</li>
<li>这个类应该提供的操作：<ul>
<li>访问元素：如果用户访问不存在元素，这些操作会抛出一个异常</li>
</ul>
</li>
<li>一个默认构造函数和一个构造函数，接受单一的 initializer_list\<string> 类型参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">strBlob</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span>  size_type = std::vector&lt;std::string&gt;::size_type;<br>    <span class="hljs-built_in">strBlob</span>();<br>    <span class="hljs-built_in">strBlob</span>(std::initializer_list&lt;std::string&gt; il);<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">size</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">empty</span>(); &#125;<br><br>    <span class="hljs-comment">// 添加和删除元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; s)</span> </span>&#123; data-&gt;<span class="hljs-built_in">push_back</span>(s);&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 元素访问</span><br>    <span class="hljs-function">std::string &amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">std::string &amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;<br>    <span class="hljs-comment">// 如果 data[i] 不合法，抛出一个异常</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(size_type i, <span class="hljs-type">const</span> std::string &amp; msg)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">strBlob::<span class="hljs-built_in">strBlob</span>() : <span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;std::string&gt;&gt; () ) &#123; &#125;<br>strBlob::<span class="hljs-built_in">strBlob</span>(std::initializer_list&lt;std::string&gt; il)<br>                : <span class="hljs-built_in">data</span>( std::make_shared&lt;std::vector&lt;std::string&gt;&gt; (il) ) &#123; &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>接受一个 initializer_list 的构造函数将其参数传递给 vector 的对应构造函数</strong>。此构造函数通过拷贝列表中的值来初始化 vector 的元素</li>
</ul>
<h4 id="元素访问成员函数"><a href="#元素访问成员函数" class="headerlink" title="元素访问成员函数"></a>元素访问成员函数</h4><ul>
<li><p>访问元素操作前都要先检查元素是否存在，因此定义一个 check 工具函数</p>
<ul>
<li>front 和 back 应该对 const 进行重载</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strBlob::check</span><span class="hljs-params">(strBlob::size_type i, <span class="hljs-type">const</span> std::string &amp;msg)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= data-&gt;<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlob::front</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;front on empty strBlob&quot;</span>);<br>    <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">front</span>();<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlob::front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;front on empty strBlob&quot;</span>);<br>    <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">front</span>();<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlob::back</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;back on empty strBlob&quot;</span>);<br>    <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">back</span>();<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlob::back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;back on empty strBlob&quot;</span>);<br>    <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strBlob::pop_back</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;pop_back on empty strBlob&quot;</span>);<br>    data-&gt;<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h2><ul>
<li>new 分配内存</li>
<li>delete 释放 new 分配的内存</li>
</ul>
<h3 id="使用-new-动态分配和初始化对象"><a href="#使用-new-动态分配和初始化对象" class="headerlink" title="使用 new 动态分配和初始化对象"></a>使用 new 动态分配和初始化对象</h3><ul>
<li>new 无法为其分配的对象命名，而是返回一个指向该对象的指针</li>
<li><strong>默认情况下，动态分配的对象是默认初始化的</strong>，这意味着<strong>内置类型或组合类型的对象的值是未定义的</strong></li>
<li><p>可以使用直接初始化方式</p>
<ul>
<li><p>传统<strong>直接初始化方式：使用圆括号</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>新标准下也可以使用<strong>列表初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">veccot&lt;<span class="hljs-type">int</span>&gt; *pi = <span class="hljs-keyword">new</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>也可以对动态分配对象进行<strong>值初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string *ps1 = <span class="hljs-keyword">new</span> string;<br>string *ps2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>();<br><span class="hljs-type">int</span> * pi3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对于内置类型，值初始化和默认初始化有很大区别</p>
<ul>
<li><strong>值初始化内置类型有这良好的定义值</strong></li>
<li><strong>默认初始化内置类型对象的值是未定义的</strong></li>
</ul>
</li>
<li><p>使用 <code>auto</code> 关键字</p>
<ul>
<li><p><strong>只有当括号中仅有单一初始化器时才能使用 auto</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">auto</span>(obj);    <span class="hljs-comment">// p 指向一个与 obj 类型相同的对象</span><br>                            <span class="hljs-comment">// 该对象使用 obj 进行初始化</span><br><span class="hljs-keyword">auto</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">auto</span>&#123;a, b, c&#125;;    <span class="hljs-comment">// 错误，括号中只能有单一初始化器</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="动态分配的-const-对象"><a href="#动态分配的-const-对象" class="headerlink" title="动态分配的 const 对象"></a>动态分配的 const 对象</h3><ul>
<li>使用 new 动态分配 const 对象是<strong>合法</strong>的</li>
<li>与其他 const 对象一样，动态分配的 const 对象也<strong>必须初始化</strong></li>
<li>new 返回的指针是一个<strong>指向 const 的指针</strong></li>
</ul>
<h3 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h3><ul>
<li>如果 new 不能分配所要求的内存空间，就会<strong>抛出一个 bad_alloc 的异常</strong></li>
<li><strong>定位 new(placement new)</strong> 表达式允许向 new 传递额外的参数，阻止抛出异常</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();    <span class="hljs-comment">// 如果分配失败，会抛出 std::bad_alloc 异常</span><br><span class="hljs-type">int</span> *p1 = <span class="hljs-built_in">new</span> (nothrow) <span class="hljs-built_in">int</span>();  <span class="hljs-comment">// 如果分配失败，new 返回一个空指针</span><br></code></pre></td></tr></table></figure>
<ul>
<li>bad_alloc 和 nothrow 都定义在<strong>头文件 new</strong> 中</li>
</ul>
<h3 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h3><ul>
<li>delete 表达式接受一个指针，释放指针指向的对象</li>
<li>delete 表达式执行两个动作：<ul>
<li>销毁给定指针指向的对象</li>
<li>释放对应的内存</li>
</ul>
</li>
</ul>
<h3 id="指针值和-delete"><a href="#指针值和-delete" class="headerlink" title="指针值和 delete"></a>指针值和 delete</h3><ul>
<li>传递给 delete 的<strong>指针必须指向动态分配的内存</strong>，或者是一个<strong>空指针</strong></li>
<li><strong>释放一个并非 new 分配的内存，或者将相同的指针值释放多次，行为都是未定义的</strong></li>
<li>虽然 const 对象的值不能被改变，但可以被销毁</li>
</ul>
<h3 id="动态对象的生存周期直到被释放为止"><a href="#动态对象的生存周期直到被释放为止" class="headerlink" title="动态对象的生存周期直到被释放为止"></a>动态对象的生存周期直到被释放为止</h3><ul>
<li><font size=4><strong>内置指针</strong></font>(而不是智能指针) 管理的动态对象，直到<strong>被显式释放之前都存在</strong></li>
<li>当一个<strong>内置类型指针</strong>离开其作用域时，它所指向的对象什么也不会发生。<strong>如果这个指针指向的是动态内存，那么内存也不会被自动释放</strong></li>
</ul>
<h3 id="使用-new-和-delete-管理内存存在三个常见问题"><a href="#使用-new-和-delete-管理内存存在三个常见问题" class="headerlink" title="使用 new 和 delete 管理内存存在三个常见问题"></a>使用 new 和 delete 管理内存存在三个常见问题</h3><ul>
<li><strong>忘记 delete 内存</strong>：产生<strong>内存泄漏</strong>问题</li>
<li><strong>使用已经释放掉的对象</strong></li>
<li><strong>同一块内存释放两次</strong>：主要出现在当有<strong>两个指针指向同一个动态分配的对象</strong>时</li>
</ul>
<h3 id="delete-之后重置指针值"><a href="#delete-之后重置指针值" class="headerlink" title="delete 之后重置指针值"></a>delete 之后重置指针值</h3><ul>
<li>delete 之后，指针变成<strong>空悬指针(dangling pointer)</strong>, 也叫野指针</li>
<li>如果需要保留指针，可以在 delete 之后将 <strong>nullptr</strong> 赋予指针</li>
</ul>
<h2 id="shared-ptr-和-new-结合使用"><a href="#shared-ptr-和-new-结合使用" class="headerlink" title="shared_ptr 和 new 结合使用"></a>shared_ptr 和 new 结合使用</h2><ul>
<li>还可以使用 new 返回的指针来初始化 shared_ptr</li>
<li><strong>接受指针参数</strong>的智能指针构造函数是 <strong>explicit</strong> 的，<strong>限制隐式转换</strong>，必须使用直接初始化方式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-type">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 错误，必须使用直接初始化方式</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;    <span class="hljs-comment">// 正确，使用了直接初始化方式</span><br></code></pre></td></tr></table></figure>
<ul>
<li>一个<strong>返回 shared_ptr 的函数</strong>不能在其返回语句中隐式转换为一个普通指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p);      <span class="hljs-comment">// 错误，隐式的转换为 shared_ptr&lt;int&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>必须将 shared_ptr 绑定到想要返回的指针上</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p));<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>默认情况下，一个<strong>用来初始化智能指针的普通指针，必须指向动态内存</strong>，因为<strong>智能指针默认使用 delete 释放它所关联的对象</strong></li>
<li>可以将智能指针绑定到一个指向其他类型的资源的指针上，但是必须提供自己的操作来代替 delete</li>
</ul>
<h3 id="定义和改变-shared-ptr-的其他方法"><a href="#定义和改变-shared-ptr-的其他方法" class="headerlink" title="定义和改变 shared_ptr 的其他方法"></a>定义和改变 shared_ptr 的其他方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>shared_ptr\<T> p(q)</strong></td>
<td><strong>p 管理内置指针 q 所指的对象</strong> <br> q 必须指向 new 分配的内存，且能转换成 T* 类型</td>
</tr>
<tr>
<td><strong>shared_ptr\<T> p(u)</strong></td>
<td>p 从 <strong>unique_ptr u</strong> 那里接管对象的所有权<br> <strong>将 u 置为空</strong></td>
</tr>
<tr>
<td><strong>shared_ptr\<T> p(q, d)</strong></td>
<td>p 接管内置指针 q 所指对象的所有权, q 必须能转换成 T<em> 类型 <br> <em>*p 将使用可调用对象 d 来代替 delete</em></em></td>
</tr>
<tr>
<td><strong>shared_ptr\<T> p(p2, d)</strong></td>
<td>p 是 shared_ptr p2 的一个拷贝，唯一区别是 p 使用可调用对象 d 来代替 delete</td>
</tr>
<tr>
<td><strong>p.reset() <br> p.reset(q) <br> p.reset(q, d)</strong></td>
<td><strong>若 p 是唯一指向其对象的shared_ptr ，reset 会释放此对象</strong> <br> <strong>若传递了可选参数内置指针 q , 会令 p 指向 q, 否则将 p 置为空</strong> <br> 若还传递了参数 d, 将调用 d 代替 delete</td>
</tr>
</tbody>
</table>
</div>
<h3 id="不要混合使用智能指针和普通指针"><a href="#不要混合使用智能指针和普通指针" class="headerlink" title="不要混合使用智能指针和普通指针"></a>不要混合使用智能指针和普通指针</h3><ul>
<li>shared_ptr 可以协调对象的析构，但这<strong>仅限于自身的拷贝(也是 shared_ptr)之间</strong>，因此<strong>推荐使用 make_shared()</strong>, 在分配对象时就将 shared_ptr 与对象绑定</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 ptr</span><br>&#125;   <span class="hljs-comment">// ptr 离开作用域，被销毁</span><br></code></pre></td></tr></table></figure>
<ul>
<li>上面函数中的参数是<strong>值传递方式</strong>的，实参会被<strong>拷贝</strong>到 ptr 中，shared_ptr 会<strong>递增其引用计数</strong></li>
<li>当 ptr 离开作用域被销毁，引用计数会减 1，但不会变为 0. 因此 ptr 指向的内存不会被释放</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">x</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;       <span class="hljs-comment">// x 是一个普通指针</span><br><span class="hljs-built_in">process</span>(x);             <span class="hljs-comment">// 错误，不能将 int* 转换为 shared_ptr&lt;int&gt;</span><br><span class="hljs-built_in">process</span>(<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">int</span>&gt; (x));       <span class="hljs-comment">// 合法，但内存会被释放</span><br><span class="hljs-type">int</span> j = *x;     <span class="hljs-comment">// 未定义行为，x 现在是一个空悬指针</span><br></code></pre></td></tr></table></figure>
<ul>
<li>不能向 process 传递内置指针(shared_ptr 接受指针的构造函数是 explicit 的)，但可以传递一个临时 shared_ptr</li>
<li>传递临时 shared_ptr，当临时对象作用域结束别销毁时，引用计数递减为 0，此对象的内存空间也被释放</li>
<li><strong>当将一个 shared_ptr 绑定到一个普通指针后，不要再使用内置指针来访问 shared_ptr 指向的内存</strong>，因为无法知道对象何时被销毁</li>
</ul>
<h3 id="不要使用-get-初始化另一个智能指针或者为智能指针赋值"><a href="#不要使用-get-初始化另一个智能指针或者为智能指针赋值" class="headerlink" title="不要使用 get 初始化另一个智能指针或者为智能指针赋值"></a>不要使用 get 初始化另一个智能指针或者为智能指针赋值</h3><ul>
<li>设计 get 函数的目的是为了向需要向不能使用智能指针的代码传递一个内置指针。</li>
<li><strong>使用 get 返回的指针的代码不能 delete 此指针</strong></li>
<li><strong>永远不要使用 get 初始化另一个智能指针或者为另一个智能指针赋值</strong></li>
</ul>
<h3 id="其他-shared-ptr-操作"><a href="#其他-shared-ptr-操作" class="headerlink" title="其他 shared_ptr 操作"></a>其他 shared_ptr 操作</h3><ul>
<li>可以用 reset 来将一个新的指针赋予一个 shared_ptr</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>);  <span class="hljs-comment">// 错误，不能将普通指针赋给一个 shared_ptr</span><br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>)); <span class="hljs-comment">// 正确，p 指向一个新对象</span><br></code></pre></td></tr></table></figure>
<ul>
<li>与赋值类型，<strong>reset 会更新 shared_ptr 的引用计数</strong></li>
<li>reset 成员经常与 unique 一起使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">unique</span>()) <br>    p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p));        <span class="hljs-comment">// 不是唯一用户，分配新的拷贝</span><br>*p += newVal;<br></code></pre></td></tr></table></figure>
<ul>
<li>在改变底层对象之前，先检查自身是否是当前对象的唯一用户，如果不是，在改变之前要做一份新的拷贝</li>
</ul>
<h2 id="智能指针与异常"><a href="#智能指针与异常" class="headerlink" title="智能指针与异常"></a>智能指针与异常</h2><ul>
<li>程序需要确保在异常发生后资源能被正确释放</li>
<li>如果程序块因为异常过早结束，<strong>智能指针能确保在内存不再需要时将其释放</strong></li>
<li>发生异常时，直接管理的内存是不会自动释放的<ul>
<li>使用<strong>内置指针管理内存</strong>，且在 <strong>new 之后，对应的 delete 之前发生异常，内存不会被释放</strong></li>
</ul>
</li>
</ul>
<h3 id="智能指针和哑类"><a href="#智能指针和哑类" class="headerlink" title="智能指针和哑类"></a>智能指针和哑类</h3><ul>
<li>与管理动态内存类似，可以使用相似的技术来管理<strong>不具有良好定义的析构函数的类</strong>，当这些类对象的作用域结束，程序会自动释放资源，避免发生资源泄露</li>
</ul>
<h3 id="使用自定义的释放操作"><a href="#使用自定义的释放操作" class="headerlink" title="使用自定义的释放操作"></a>使用自定义的释放操作</h3><ul>
<li><strong>删除器(deleter)</strong>: 自定义一个函数来代替 delete</li>
<li>当创建一个 shared_ptr 时，可以<strong>传递一个 (可选的) 指向删除函数的参数</strong></li>
</ul>
<h3 id="使用智能指针遵循的基本规范"><a href="#使用智能指针遵循的基本规范" class="headerlink" title="使用智能指针遵循的基本规范"></a>使用智能指针遵循的基本规范</h3><ul>
<li><strong>不使用相同的内置指针初始化（ 或 reset）多个智能指针</strong></li>
<li><strong>不 delete get() 返回的指针</strong></li>
<li>不使用 get() 初始化或 reset 另一个智能指针</li>
<li>如果使用 get() 返回的指针，记住当最后一个对应的智能指针销毁后，先前 get() 返回的指针就无效了</li>
<li><strong>如果使用智能指针管理的资源不是 new 分配的资源，记得传递给它一个删除器</strong></li>
</ul>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul>
<li>某一时刻只能有一个 unique_ptr 指向一个给定对象，当 unique_ptr 被销毁，它所指向的对象也被销毁</li>
<li><strong>定义一个 unique_ptr，需要将其绑定到一个 new 返回的指针上</strong></li>
<li>初始化 unique_ptr 也必须使用<strong>直接初始化</strong></li>
<li><strong>unique_ptr 不支持普通的拷贝或赋值操作</strong>，因为一个 unique_ptr 拥有它所指向的对象</li>
</ul>
<h3 id="unique-ptr-支持的操作"><a href="#unique-ptr-支持的操作" class="headerlink" title="unique_ptr 支持的操作"></a>unique_ptr 支持的操作</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>unique_ptr\<T> u1</strong> <br> <strong>unique_ptr\<T, D> u2</strong></td>
<td>空 unique_ptr，可以指向类型为 T 的对象 <br> u1 使用 <strong>delete</strong> 来释放指针; u2 使用一个<strong>类型为 D 的可调用对象</strong>来释放指针</td>
</tr>
<tr>
<td><strong>unique_ptr\<T, D> u(d)</strong></td>
<td>空 unique_ptr，指向类型为 T 的对象 <br> <strong>用类型为 D 的可调用对象 d 来代替 delete</strong></td>
</tr>
<tr>
<td><strong>u = nullptr</strong></td>
<td>释放 u 指向的对象，将 u 置为空</td>
</tr>
<tr>
<td><strong>u.release()</strong></td>
<td>u 放弃对指针的控制权，返回指针，并将 u 置为空</td>
</tr>
<tr>
<td><strong>u.reset()</strong> <br> <strong>u.reset(q)</strong> <br> <strong>u.reset(nullptr)</strong></td>
<td>释放 u 指向的对象 <br> 如果提供了内置指针 q, 令 u 指向这个对象；否则将 u 置空</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>虽然不能拷贝和赋值 unique_ptr，但是可以<strong>使用 release 或 reset</strong> 将指针的所有权<strong>从一个 (非 const) unique_ptr 转移给另一个 unique_ptr</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有权从 p1 转移给 p2</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p<span class="hljs-number">1.</span>release())</span></span>;  <span class="hljs-comment">// release 将 p1 置为空</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Trex&quot;</span>))</span></span>;<br><span class="hljs-comment">// 将所有权从 p3 转给 p2</span><br>p<span class="hljs-number">2.</span><span class="hljs-built_in">reset</span>(p<span class="hljs-number">3.</span><span class="hljs-built_in">release</span>());   <span class="hljs-comment">// reset 释放了 p2 原来指向的内存</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>release 返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值</p>
</li>
<li><p>如果不用另一个智能指针来保存 release 返回的指针程序就要负责资源的释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">p<span class="hljs-number">2.</span><span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 错误，p2 不会释放内存，而且丢失了指针</span><br><span class="hljs-keyword">auto</span> p = p<span class="hljs-number">2.</span><span class="hljs-built_in">release</span>();  <span class="hljs-comment">// 正确，在后面程序中要记得 delete(p)</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="传递-unique-ptr-参数和返回-unique-ptr"><a href="#传递-unique-ptr-参数和返回-unique-ptr" class="headerlink" title="传递 unique_ptr 参数和返回 unique_ptr"></a>传递 unique_ptr 参数和返回 unique_ptr</h3><ul>
<li><p><strong>不能拷贝或赋值一个 unique_ptr 的规则有一中例外情况</strong>：<strong>可以拷贝或赋值一个即将被销毁的 unique_ptr</strong>。</p>
<ul>
<li><p>例如从函数返回一个 unique_ptr</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p));    <span class="hljs-comment">// 从 int * 创建一个 unique_ptr</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>返回一个局部对象的拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(p))</span></span>;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="向-unique-ptr-传递删除器"><a href="#向-unique-ptr-传递删除器" class="headerlink" title="向 unique_ptr 传递删除器"></a>向 unique_ptr 传递删除器</h3><ul>
<li>unique_ptr 也可以重载一个删除器来代替默认的 delete</li>
<li>与重载关联容器的比较操作类似，必须在 <code>&lt;&gt;</code> 中提供删除器类型，在创建或 reset 这种类型对象时，必须提供一个指定类型的可调用对象(删除器)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// p 指向一个类型为 objT 的对象，使用类型为 delT 的对象释放 objT 对象</span><br><span class="hljs-comment">// 它会调用一个名为 fcn 的 delT 类型对象</span><br><span class="hljs-function">unique_ptr&lt;objT, delT&gt; <span class="hljs-title">p</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> objT, fcn)</span></span>;<br></code></pre></td></tr></table></figure>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ul>
<li><strong>weak_ptr 不控制所指向对象生存周期</strong>，<strong>指向一个由 shared_ptr 管理的对象</strong></li>
<li>将一个 weak_ptr 绑定到一个 shared_ptr <strong>不会改变 shared_ptr 的引用计数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Operation</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>weak_ptr\<T> w</strong></td>
<td>空 weak_ptr，可以指向类型为 T 的对象</td>
</tr>
<tr>
<td><strong>weak_ptr\<T> w(sp)</strong></td>
<td><strong>w 与 shared_ptr sp 指向相同的对象</strong>。<br> T 必须能转换为 sp 指向的类型</td>
</tr>
<tr>
<td><strong>w = p</strong></td>
<td><strong>p 可以是</strong>一个 <strong>shared_ptr</strong> 或一个 <strong>weak_ptr</strong>。赋值后 <strong>w 与 p 共享对象</strong></td>
</tr>
<tr>
<td><strong>w.reset()</strong></td>
<td>将 w <strong>置空</strong></td>
</tr>
<tr>
<td><strong>w.use_count()</strong></td>
<td><strong>与 w 共享对象的 shared_ptr 的数量</strong></td>
</tr>
<tr>
<td><strong>w.expired()</strong></td>
<td>若 <strong>w.use_count() 为 0</strong>，<strong>返回 true</strong>，否则返回 false</td>
</tr>
<tr>
<td><strong>w.lock()</strong></td>
<td>如果 <strong>w.expired() 为 true，返回一个空 shared_ptr</strong> 。<strong>否则返回一个指向 w 的对象的 shared_ptr</strong></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>创建一个 weak_ptr 时，要<strong>用一个 shared_ptr 来初始化它</strong></li>
<li><strong>由于对象可能不存在</strong>，不能使用 weak_ptr 直接访问对象，<strong>必须调用 lock</strong>，此函数检查 weak_ptr 指向的对象是否存在</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(shared_ptr&lt;<span class="hljs-type">int</span>&gt; np = w.<span class="hljs-built_in">lock</span>()) &#123;   <span class="hljs-comment">// 如果 np 不为空则条件成立</span><br>  <span class="hljs-comment">// 在 if 中，np 与 w 共享对象</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="核查指针类"><a href="#核查指针类" class="headerlink" title="核查指针类"></a>核查指针类</h3><ul>
<li>为 strBlob 类定义一个伴随指针类 <strong>strBlobPtr</strong>，这个类的作用类似于<strong>智能指针迭代器</strong></li>
<li>strBlobPtr 提供更安全的接口，具有更好的封装性，更安全的资源管理(<strong>利用 weak_ptr 避免循环引用</strong>)</li>
<li>strBlobPtr 有两个数据成员: wptr, curr<ul>
<li>wptr 或为空，或指向一个 strBlob 中的 vector</li>
<li>curr 保存当前对象表示的元素下标</li>
</ul>
</li>
<li>辅助函数 check 检查解引用 strBlobPtr 是否安全</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KNOWLEDGETEST_STRBLOBPTR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KNOWLEDGETEST_STRBLOBPTR_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">strBlob</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">strBlobPtr</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> strBlobPtr &amp;, <span class="hljs-type">const</span> strBlobPtr &amp;);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> strBlobPtr &amp;, <span class="hljs-type">const</span> strBlobPtr &amp;);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">strBlobPtr</span>() : <span class="hljs-built_in">curr</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">strBlobPtr</span>(<span class="hljs-type">const</span> strBlob &amp;a, <span class="hljs-type">size_t</span> sz = <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// deref 调用 check，检查使用 vector 是否安全以及 curr 是否在合法范围内</span><br>    <span class="hljs-function">std::string &amp; <span class="hljs-title">deref</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 前缀递增，返回递增后对象的引用</span><br>    <span class="hljs-function">strBlobPtr &amp; <span class="hljs-title">incr</span><span class="hljs-params">()</span></span>;<br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 若检查成功，check 返回一个指向 vector 的 shared_ptr</span><br>    std::shared_ptr&lt;std::vector&lt;std::string &gt;&gt; <span class="hljs-built_in">check</span>(std::<span class="hljs-type">size_t</span> , <span class="hljs-type">const</span> std::string &amp;) <span class="hljs-type">const</span>;<br><br>    <span class="hljs-comment">// 保存一个 weak_ptr，意味着底层 vector 可能被销毁</span><br>    std::weak_ptr&lt;std::vector&lt;std::string&gt;&gt; wptr;<br>    std::<span class="hljs-type">size_t</span> curr;       <span class="hljs-comment">// 在数组中的当前位置</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//KNOWLEDGETEST_STRBLOBPTR_H</span></span><br></code></pre></td></tr></table></figure>
<h3 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h3><ul>
<li>deref ：解引用</li>
<li>incr: 递增 strBlobPtr</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strBlobPtr.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strBlob.h&quot;</span></span><br><br>strBlobPtr::<span class="hljs-built_in">strBlobPtr</span>(<span class="hljs-type">const</span> strBlob &amp;a, <span class="hljs-type">size_t</span> sz) : <span class="hljs-built_in">wptr</span>(a.data), <span class="hljs-built_in">curr</span>(sz) &#123; &#125;<br><br>std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;<br>strBlobPtr::<span class="hljs-built_in">check</span>(std::<span class="hljs-type">size_t</span> i, <span class="hljs-type">const</span> std::string &amp; msg) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">auto</span> ret = wptr.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(!ret)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;unbound strBlobPtr&quot;</span>);<br>    <span class="hljs-keyword">if</span>(i &gt;= ret-&gt;<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(msg);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlobPtr::deref</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;dereference past end&quot;</span>);<br>    <span class="hljs-keyword">return</span> (*p)[curr];      <span class="hljs-comment">// *p 是 shared_ptr 所指向的 vector</span><br>&#125;<br><br><span class="hljs-function">strBlobPtr &amp; <span class="hljs-title">strBlobPtr::incr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果 curr 已经指向容器的尾后位置，就不能递增它</span><br>    <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;increment past end of strBlobPtr&quot;</span>);<br>    ++curr; <span class="hljs-comment">// 推进当前位置</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> strBlobPtr &amp; lhs, <span class="hljs-type">const</span> strBlobPtr &amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span>(!lhs.wptr.<span class="hljs-built_in">expired</span>() &amp;&amp; !rhs.wptr.<span class="hljs-built_in">expired</span>()) &#123;<br>        <span class="hljs-built_in">return</span> (lhs.wptr.<span class="hljs-built_in">lock</span>() == rhs.wptr.<span class="hljs-built_in">lock</span>()) &amp;&amp; (lhs.curr == rhs.curr);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!= (<span class="hljs-type">const</span> strBlobPtr &amp; lhs, <span class="hljs-type">const</span> strBlobPtr &amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ul>
<li>两个类的声明与实现都在<strong>不同的文件中</strong>，在声明 strBlobPtr 为 strBlob 的友元类时，注意<strong>使用前向声明打破循环依赖</strong>, 参考<a target="_blank" rel="noopener" href="https://kin12138.github.io/2025/03/24/7.%20%E7%B1%BB/7.3%20%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/" title="类的其他特性">类之间的友元关系</a></li>
</ul>

            </article>
            
	<aside class="rightside">
	
		<div class="rightside-button" id="js-aside">
			<span>
				<img no-lazy src="/images/icon/aside.png" class="rightside-button-icon" alt="Icon">
			</span>
		</div>
		<script>
			$("#js-aside").click(function () {
				onShowAsideButton();
			});
		</script>
	
	<div class="rightside-button" id="js-toggle_theme">
		<span>
			<img no-lazy src="/images/icon/toggle_theme.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>

	
<script src="/js/plugins/goto_position.js"></script>

	
	<div class="rightside-button" id="js-go_top">
		<span>
			<img no-lazy src="/images/icon/go_top.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>
	<div class="rightside-button" id="js-go_bottom">
		<span>
			<img no-lazy src="/images/icon/go_bottom.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>

	<script>
		setToggleThemeButtonListener();
	</script>
	<script>
		$('#js-go_top')
		.gotoPosition( {
			speed: 300,
			target: 'top',
		} );
		$('#js-go_bottom')
		.gotoPosition( {
			speed: 300,
			target: 'bottom',
		} );
	</script>
</aside>


<div class="post-bottom">
    
        <div class="post-paging">     
            <div class="post-paging-last">
                
                    <a href="/2025/04/16/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/12.2%20%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/">
                        上一篇：12.2 动态数组
                    </a>
                
            </div>
            <div class="post-paging-next">
                
                    <a href="/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.3%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/">
                        下一篇：11.3 关联容器操作
                    </a>
                
            </div>
        </div>
    
    
    
        
    
</div>
        </div>
    </main>
    
        <aside class="main-aside">
    
<script src="/js/widgets/aside.js"></script>

    <script>
        showAside();
    </script>

    <div class="aside-top">
        <div class="aside-top-about aside-card">
            <a href="/about" class="aside-top-about-portrait">
                <img no-lazy src="/images/about_icon/about_icon.webp" alt="Q">
            </a>
            <div class="aside-top-about-info">
                <span class="author"> kin12138</span>
                <span class="description">This is life, it's suck, but i love it</span>
            </div>              
            <div class="aside-top-about-site">
                <a href="/categories" class="aside-top-about-site-item">
                    <span class="title">类别</span>
                    <span class="count">3</span>
                </a>
                <a href="/tags" class="aside-top-about-site-item">
                    <span class="title">标签</span>
                    <span class="count">99</span>
                </a>
                <a href="/archives" class="aside-top-about-site-item">
                    <span class="title">归档</span>
                    <span class="count">57</span>
                </a>
            </div>
            <div class="aside-top-about-contact">
                
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Weibo.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Tieba.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Bilibili.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/github.webp" alt="Quieter">
                        </a>
                    
                
            </div>
        </div> 

        
    </div>

    <div class="aside-bottom">
        
            <script>
                
                    const tocCollapsed = true;
                
                
                    const tocDepth = 6;
                
                var headerString = '';
                for (let i = 1; i <= tocDepth; i++) {
                    if (i === 1) {
                        headerString += 'h1';
                    } else {
                        headerString += ', h' + i;
                    }
                }
                hbeToc();
            </script>
            <div class="aside-bottom-toc aside-card">
                <div class="aside-bottom-toc-title">
                    <h1>目录</h1>
                    <span class="toc-percentage"></span>
                </div>
                <ol class="aside-bottom-toc-content"></ol>
            </div>
        
    </div>
</aside>
    
</div>
		<footer>
	<div class="content">
		
			<span>©2025&nbsp;By&nbsp;<a href="/about">kin12138</a>.</span>
		
		<span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> theme by <a target="_blank" rel="noopener" href="https://github.com/GZ-Metal-Cell/hexo-theme-quieter">Quieter</a>.</span>
		
	</div>

	
<script src="/js/plugins/ref.js"></script>

	
<script src="/js/plugins/highlight_tools.js"></script>

	<script>
		var copyIcon = "/images/icon/copy.png";
		var closeCodeBlockIcon = "/images/icon/close_code_block.png";
		var highlightShrink = "";
		var HighlightHeightLimit = "";
	</script>
	
	<!-- Analytics -->

    
        <!-- Busuanzi Analytics -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    


	

	

    
		
<script src="/js/plugins/replaceSpacesWithNbsp.js"></script>

	

	
	
	
		<script>
			if (typeof init === 'function') {
				init();
			}
		</script>
	

	
		
	

	

	<!--
		
<script src="/js/plugins/jquery.pjax.min.js"></script>

		<script>
			$(document).pjax('a[target!=_blank]', 'main', {
				fragment: 'main',
				timeout: 8000
			});

			$(document).on('pjax:complete', function() {
			});
		</script> 
	-->
	<script>
		console.log('\n %c Hexo-Quieter 主题 %c https://github.com/GZ-Metal-Cell/hexo-theme-quieter \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
	</script>
</footer>
	</body>

	<!-- Hexo-Quieter 主题  https://github.com/GZ-Metal-Cell/hexo-theme-quieter -->
</html>

