<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>How virtual functions work in c++</title>
      <link href="/2025/05/12/c++%20object-oriented%20programing/How%20virtual%20functions%20work%20in%20c++/"/>
      <url>/2025/05/12/c++%20object-oriented%20programing/How%20virtual%20functions%20work%20in%20c++/</url>
      
        <content type="html"><![CDATA[<p>虚函数是 C++ 中实现<strong>动态多态性</strong>的一种重要手段，简单来说就是利用基类指针或引用的静态类型与动态类型不同的特性，使得在<strong>运行时</strong>基类指针或引用实际指向派生类实例</p><h2 id="VTABLE-与-VPTR"><a href="#VTABLE-与-VPTR" class="headerlink" title="VTABLE 与 VPTR"></a>VTABLE 与 VPTR</h2><ul><li>如果一个<strong>类中包含虚函数，那么在它的实现过程中会做两个工作</strong>：<ul><li>如果这个<strong>类的对象已经被创建</strong>，就会生成一个<strong>虚指针 virtual pointer(VPTR)</strong>，并将它插入到类中作为一个<strong>隐形的数据成员</strong>，它<strong>指向这个类的虚函数表(VTable)</strong>。针对每个被创建的新对象，都会有一个新的 vptr 作为数据成员被插入对应的类中</li><li>无论有无创建对象，包含虚函数的类都会创建一个<strong>静态成员——静态数组，用来保存函数指针，称为 VTable</strong>，这个数组中保存着<strong>当前类中所有虚函数的地址</strong></li></ul></li></ul><h2 id="单继承中的虚函数表"><a href="#单继承中的虚函数表" class="headerlink" title="单继承中的虚函数表"></a>单继承中的虚函数表</h2><ul><li>举个例子：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func_1</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func_2</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; &#125;<br>    <span class="hljs-type">int</span> d;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derive obj;<br>    Base *p = &amp;obj;<br>    p-&gt;<span class="hljs-built_in">func</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中，Derive 对象实例在内存中的分布如下图所示：</p><p><a data-fancybox="gallery" href="/c++ object-oriented programing/img/虚函数内存分布-2025-05-12-2003.png"><br>  <img src="/c++ object-oriented programing/img/虚函数内存分布-2025-05-12-2003.png" alt="继承中的内存分布"></a></p></li><li><p>其中，Derive 的数据成员包括</p><ul><li>继承来的 int b</li><li>特有的 int d</li><li><strong>虚函数表指针</strong></li></ul></li><li>Derive 类的虚函数表 VTable 是一个静态数组<ul><li>由于 Derive 中覆盖了虚函数 func_1 , 所以 <strong>VTable 中原有 <code>&amp;Base::func_1()</code> 被替换为 <code>&amp;Derive::func_1()</code></strong>（在创建 Derive 实例时就被替换）</li><li>在 Derive 中没有覆盖 func_2，所以 <strong>VTable 中保留 <code>&amp;Base::func_2()</code></strong></li><li>从而实现多态性：无论 Base 指针还是 Derive 指针，都可以调用 <code>Derive::func_1</code>, <code>Base::func_2</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> OOP </tag>
            
            <tag> vtable </tag>
            
            <tag> vptr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SOLID 原则</title>
      <link href="/2025/05/12/c++%20object-oriented%20programing/SOLID%20%E5%8E%9F%E5%88%99/"/>
      <url>/2025/05/12/c++%20object-oriented%20programing/SOLID%20%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>SOLID 是面向对象设计的五条核心原则的首字母缩写，包括</p><ul><li><strong>Single Responsibility Principle</strong> —— 单一职责原则</li><li><strong>Open/Closed Principle</strong> —— 开闭原则</li><li><strong>Liskov Substitution Principle</strong> —— 里氏替换原则</li><li><strong>Interface Segregation Principle</strong> —— 接口隔离原则</li><li><strong>Dependency Inversion Principle</strong> —— 依赖倒置原则</li></ul><h2 id="1-Single-Responsibility-Principle"><a href="#1-Single-Responsibility-Principle" class="headerlink" title="1. Single Responsibility Principle"></a>1. Single Responsibility Principle</h2><ul><li>一个类或模块应该仅有一个引起它变化的原因，即<strong>只负责一项职责</strong></li><li>常见误区：<ul><li>“一个类只写一个方法”是误解，一个类负责一种职责，而不是一个方法</li><li>拆分过度会导致类过多、管理困难，应该以高内聚为目标</li></ul></li></ul><h2 id="2-Open-Closed-Principle"><a href="#2-Open-Closed-Principle" class="headerlink" title="2. Open/Closed Principle"></a>2. Open/Closed Principle</h2><ul><li>类、模块、函数等<strong>对扩展开放，对修改关闭</strong><ul><li>当需求变化时，尽量通过新增代码来扩展功能而不是修改已有代码</li></ul></li><li>违反 OCP 的例子</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对每种形状的面积计算都需要修改 Switch 语句 </span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (s.type) &#123;<br>        <span class="hljs-keyword">case</span> Shape::Circle : <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * s.radius * s. radius;<br>        <span class="hljs-keyword">case</span> Shape::Rectangle : <span class="hljs-keyword">return</span> s.width * s.height;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>遵循 OCP 之后的修改</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape &amp;)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r) : <span class="hljs-built_in">radius_</span>(r) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape &amp; s)</span> <span class="hljs-keyword">override</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * s.radius_ * s. radius_; &#125; <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> radius_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>(doubel w, doubel h) : <span class="hljs-built_in">width_</span>(w), <span class="hljs-built_in">height_</span>(h) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape &amp; s)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> width_ * height_; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> width_, height_;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">totalArea</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; &amp; shapes)</span> </span>&#123;<br>    <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; shape : shapes) sum += shape-&gt;<span class="hljs-built_in">area</span>();<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Liskov-Substitution-Principle"><a href="#3-Liskov-Substitution-Principle" class="headerlink" title="3. Liskov Substitution Principle"></a>3. Liskov Substitution Principle</h2><ul><li>派生类型对象必须能替换基类对象，且程序行为不边<ul><li>保证继承体系的正确性和使用多态时的可靠性</li><li>避免子类“破坏”父类的期望行为</li></ul></li><li>违反里氏替换原则的示例：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Square 继承自 Rectangle，却在设置宽高时破坏了矩形的行为预期</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> w)</span> </span>&#123; width_ = w; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> </span>&#123; height_ = h; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> width_ * height_; &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">double</span> width_, height_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Rectangle &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> w)</span> <span class="hljs-keyword">override</span> </span>&#123; width_ = height_ = w; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> <span class="hljs-keyword">override</span> </span>&#123;  width_ = height_ = h; &#125;<br>&#125;;<br><br><span class="hljs-comment">// 客户代码可能假设</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(Rectangle &amp; r)</span> </span>&#123;<br>    r.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">5</span>);<br>    r.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">// 期望 area() == 20，但传入的参数如果是一个 Square 就会得到 16</span><br>    std::cout &lt;&lt; r.<span class="hljs-built_in">area</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在客户端代码 resize 中，r 的动态类型是基类 Rectangle 还是派生类 Square 只有在运行时才能确定。而用户使用 <code>r.setWidth(5); r.setHeight(4);</code> 就是希望得到 width * height == 5 * 4 == 20 的结果，但是如果 r 的运行时类型是 Square，程序会得到 4 * 4 == 16 的结果，显然不符合预期，这就违背了里氏替换原则</li><li>要让继承体系满足 LSP，必须保证：<ul><li><strong>不改变基类类的行为语义</strong></li><li>子类实现即使扩展，也要保留基类契约（即基类的基本逻辑）</li></ul></li><li>上述示例的两种解决方法：<ol><li>不要让 Square 继承 Rectangle ，而是让它们继承同一个更抽象的接口，比如 Shape，各自实现自己的 area(), <strong>不要滥用 “is-a” 关系</strong></li><li>如果确实要有矩形和正方形的继承关系，就不要重写 setWidth 和 setHeight, 或者把它们设计成不允许单独修改长或宽，只通过 setSide() 一次性设置，这样，基类的逻辑就不会被破坏</li></ol></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">(<span class="hljs-type">const</span> Shape &amp;)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">double</span> w)</span> </span>&#123; width_ = w; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> </span>&#123; height_ = h; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> width_ * height_; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> width_, height_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSide</span><span class="hljs-params">(<span class="hljs-type">double</span> s)</span></span>&#123; side_ = s; &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> side_ * side_; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> side_;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-Interface-Segregation-Principle"><a href="#4-Interface-Segregation-Principle" class="headerlink" title="4. Interface Segregation Principle"></a>4. Interface Segregation Principle</h2><ul><li>客户端不应被迫依赖它不使用的方法；大接口应拆分为多个专门接口<ul><li>客户端可以只关心自己使用的接口，避免被无关方影响</li><li>便于接口演化与实现</li></ul></li><li>违反 ISP 的示例</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IMultiFunctionDevice</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Document &amp;)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(Document &amp;)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IMultiFunctionDevice</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 使用方只需要使用 scan，却要实现 print，违背隔离</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> : <span class="hljs-keyword">public</span> IMultiFunctionDevice &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Document &amp;)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 空实现 */</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(Document &amp;doc)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 扫描 */</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>遵循 ISP 后</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IPrinter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Document &amp;)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IPrinter</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IScanner</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">scanner</span><span class="hljs-params">(Document &amp;)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IPrinter</span>() = <span class="hljs-keyword">default</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiFunctionPrinter</span> : <span class="hljs-keyword">public</span> IPrinter, <span class="hljs-keyword">public</span> IScanner &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Document &amp;)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 打印 */</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(Document &amp;)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 扫描 */</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-Dependency-Inversion-Principle"><a href="#5-Dependency-Inversion-Principle" class="headerlink" title="5. Dependency Inversion Principle"></a>5. Dependency Inversion Principle</h2><ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象<ul><li>通过依赖抽象（接口或抽象基类），降低模块间的耦合度</li></ul></li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>违反 DIP 的示例</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 高层逻辑直接依赖具体文件存储实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; message)</span> </span>&#123; <span class="hljs-comment">/* 写文件 */</span>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Order &amp; o)</span> </span>&#123;<br>        <span class="hljs-comment">// 其他处理</span><br>        logger_.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Order processed&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    FileLogger logger_;     <span class="hljs-comment">// 直接依赖具体类</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>遵循 DIP 原则后的修改</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 抽象接口（高层模块定义）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ILogger</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp;)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ILogger</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-comment">// 低层模块实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLogger</span> : <span class="hljs-keyword">public</span> ILogger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; message)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 写文件 */</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 低层模块实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogger</span> : <span class="hljs-keyword">public</span> ILogger &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; message)</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* 输出到控制台 */</span>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 高层模块</span><br><span class="hljs-comment">// 将接口实现通过构造函数或工厂注入到高层模块中</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">OrderProcessor</span>(std::unique_ptr&lt;ILogger&gt; lg) : <span class="hljs-built_in">logger_</span>(lg) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processOrder</span><span class="hljs-params">(Order &amp; o)</span> </span>&#123;<br>        <span class="hljs-comment">// 处理订单</span><br>        logger-&gt;<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Order processed&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::unique_ptr&lt;ILogger&gt; logger_;<br>&#125;;<br><br><br><span class="hljs-comment">// 使用时</span><br><br><span class="hljs-keyword">auto</span> processor = std::<span class="hljs-built_in">make_unique</span>&lt;OrderProcessor&gt; (<br>                std::<span class="hljs-built_in">make_unique</span>&lt;FileLogger&gt;() );<br>processor-&gt;<span class="hljs-built_in">processOrder</span>();<br></code></pre></td></tr></table></figure><ul><li><p>这是关于 DIP 的另一个例子</p><p>  <a href="https://github.com/kin12138/Multi-Program-during-learn-C-primer/tree/master/MessageSend">https://github.com/kin12138/Multi-Program-during-learn-C-primer/tree/master/MessageSend</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ OOP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> OOP </tag>
            
            <tag> SOLID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.8 容器与继承</title>
      <link href="/2025/05/10/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.8%20%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2025/05/10/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.8%20%E5%AE%B9%E5%99%A8%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li><strong>当使用容器存放继承体系中的对象时，必须采用间接存储方式</strong>。<ul><li>因为不允许容器中保存不同类型的元素，所以不能把具有继承关系的多种类型的对象存储到容器中</li></ul></li><li>当派生类对象被赋予基类对象时，其中的派生类部分将被切掉，因此容器和存在继承关系的类型间不能兼容</li></ul><h2 id="在容器中放置指针-智能指针-而非对象"><a href="#在容器中放置指针-智能指针-而非对象" class="headerlink" title="在容器中放置指针(智能指针) 而非对象"></a>在容器中放置指针(智能指针) 而非对象</h2><ul><li>当希望<strong>在容器中存放具有继承关系的对象时，实际上存放的通常是基类的指针(最好是智能指针)</strong><ul><li>这些指针所指对象的动态类型可能是基类，也可能是派生类</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::vector&lt;std::shared_ptr&lt;Quote&gt;&gt; basket;<br>basket.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_shared</span>&lt;Quote&gt; (<span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-number">10.1</span>));<br>basket.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_shared</span>&lt;Bulk_quote&gt; (<span class="hljs-string">&quot;sss&quot;</span>, <span class="hljs-number">10.1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0.3</span>));<br>std::cout &lt;&lt; basket.<span class="hljs-built_in">back</span>() -&gt; <span class="hljs-built_in">net_price</span>(<span class="hljs-number">20</span>) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><ul><li>basket.back() 返回的是一个 Quote 类型的智能指针，运行过程中实际指向的对象是 Bulk_quote 类型，因此运行的 net_price 是 Bulk_quote 派生类版本</li></ul><h2 id="编写-Basket-类"><a href="#编写-Basket-类" class="headerlink" title="编写 Basket 类"></a>编写 Basket 类</h2><ul><li>C++ 面向对象编程中有一个悖论：无法直接使用对象进行面向对象编程。相反，必须使用指针或引用，这会增加程序复杂性，因此通常定义一些辅助类来处理复杂情况</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basket</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Basket 使用合成默认构造函数和拷贝控制成员</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_item</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;Quote&gt; &amp; sale)</span></span><br><span class="hljs-function">        </span>&#123; items.<span class="hljs-built_in">insert</span>(sale); &#125;<br>    <span class="hljs-comment">// 打印每本书的总价，和购物篮中所有书的总价</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">total_receipt</span><span class="hljs-params">(std::ostream &amp;)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 该函数用于比较 shared_ptr，multiset 成员会用到它</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;Quote&gt; &amp; lhs,</span></span><br><span class="hljs-params"><span class="hljs-function">                        <span class="hljs-type">const</span> std::shared_ptr&lt;Quote&gt; &amp; rhs)</span></span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> lhs-&gt;<span class="hljs-built_in">isbn</span>() &lt; rhs-&gt;<span class="hljs-built_in">isbn</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> cmp = <span class="hljs-keyword">decltype</span>(compare)*;<br>    <span class="hljs-comment">// multiset 保存多个报价，按 compare 成员排序</span><br>    std::multiset&lt;std::shared_ptr&lt;Quote&gt;, cmp&gt; items&#123;compare&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>multiset 存放交易信息，可以保存同一本书的多条交易信息，而且同一本书的交易信息保存在一起</li><li>由于 multiset 中的元素是 shared_ptr，它没有定义小于运算符，因此需要自定义比较运算符 compare</li></ul><h3 id="定义-Basket-成员"><a href="#定义-Basket-成员" class="headerlink" title="定义 Basket 成员"></a>定义 Basket 成员</h3><ul><li><p>total_receipt 负责将购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Basket::total_receipt</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 保存实时计算的总价</span><br>    <span class="hljs-comment">// iter 指向 ISBN 相同的同一批元素中的第一个</span><br>    <span class="hljs-comment">// upper_bound 返回一个迭代器，该迭代器指向这批元素的尾后位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = items.<span class="hljs-built_in">cbegin</span>();<br>        iter != items.<span class="hljs-built_in">cend</span>();<br>        iter = items.<span class="hljs-built_in">upper_bound</span>(*iter)) &#123;<br>        <span class="hljs-comment">// 打印该书籍对应的项目</span><br>        sum += <span class="hljs-built_in">print_total</span>(os, **iter, items.<span class="hljs-built_in">count</span>(*iter));<br>    &#125;<br>    os &lt;&lt; <span class="hljs-string">&quot;Total Sale: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>for 循环中的递增表达式，直接令 iter 指向下一个关键字，调用 unpper_bound 跳过与当前关键字相同的所有元素</p></li><li>使用 print_total 打印购物篮中每本书的细节<ul><li><code>**iter</code> 是一个 Quote 对象或者其派生类的对象</li><li>调用 multiset 的 count 成员统计具有相同 ISBN 的书籍的数量</li><li>print_total 调用了虚函数 net_price, 因此最终的计算结果依赖于 <code>**iter</code> 的动态类型</li></ul></li></ul><h3 id="隐藏指针"><a href="#隐藏指针" class="headerlink" title="隐藏指针"></a>隐藏指针</h3><ul><li><p>Basket 的用户仍需处理动态内存，因为 add_item 接受一个 shared_ptr 参数，用户必须按照以下形式编写代码：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Basket bsk;<br>bsk.<span class="hljs-built_in">add_item</span>(<span class="hljs-built_in">make_shared</span>&lt;Quote&gt;(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">45</span>));<br>bsk.<span class="hljs-built_in">add_item</span>(<span class="hljs-built_in">make_shared</span>&lt;Bulk_quote&gt; (<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">45</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0.15</span>));<br></code></pre></td></tr></table></figure></li><li><p>重新定义 add_item 使得它接受一个 Quote 对象而非 shared_ptr。</p><ul><li>新版本 add_item 负责处理内存分配，这样用户就不必处理了</li><li>定义两个版本：一个拷贝给定对象，一个采取移动操作</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_item</span><span class="hljs-params">(<span class="hljs-type">const</span> Quote &amp; sale)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_item</span><span class="hljs-params">(Quote &amp;&amp; sale)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="模拟虚拷贝"><a href="#模拟虚拷贝" class="headerlink" title="模拟虚拷贝"></a>模拟虚拷贝</h3><ul><li>add_item 接受一个 Quote 引用或右值引用，在运行时，它有可能接受 Quote 实参或者 Bulk_quote 实参</li><li>在 add_item 中，由于要分配内存，可能有这样一条语句 <code>new Quote(sale)</code>, 当接受 Bulk_quote 实参时，该 Bulk_quote 对象可能被迫切掉一部分，只保留下了 Quote 部分</li><li>为解决这个问题，给 Quote 添加一个虚函数，负责申请一份当前对象的拷贝</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> Quote * <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp; </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Quote</span>(*<span class="hljs-keyword">this</span>); &#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> Quote * <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;&amp; </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Quote</span>(std::<span class="hljs-built_in">move</span>(*<span class="hljs-keyword">this</span>)); &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Bulk_quote * <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp; <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bulk_quote</span>(*<span class="hljs-keyword">this</span>); &#125;<br><span class="hljs-function">Bulk_quote * <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;&amp; <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bulk_quote</span>(std::<span class="hljs-built_in">move</span>(*<span class="hljs-keyword">this</span>)); &#125;<br></code></pre></td></tr></table></figure><ul><li>分别定义 clone 的左值版本和右值版本，每个 clone 函数分配当前类型的新对象<ul><li>const 左值引用成员将自己拷贝给新分配的对</li><li>const 右值引用成员将自己移动到新分配对象中</li></ul></li><li><p>新版本的 add_item :</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_item</span><span class="hljs-params">(<span class="hljs-type">const</span> Quote &amp; sale)</span></span><br><span class="hljs-function">        </span>&#123; items.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt;(sale.<span class="hljs-built_in">clone</span>())); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_item</span><span class="hljs-params">(Quote &amp;&amp; sale)</span> </span>&#123;<br>    items.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt; (std::<span class="hljs-built_in">move</span>(sale).<span class="hljs-built_in">clone</span>()));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在右值版本中，尽管 sale 的类型是右值引用类型，但实际上 sale 本身（和其他变量一样）是一个左值，因此使用 std::move 将一个右值引用绑定到 sale 上</strong></p></li><li>clone 是虚函数，Quote 的动态类型决定是运行 Quote 的函数还是 Bulk_quote 的函数</li><li>无论拷贝或移动数据，clone 都返回一个指向新分配对象的指针</li><li>因为 <strong>shared_ptr 支持派生类向基类的类型转换，所以可以将 <code>shared_ptr&lt;Quote&gt;</code> 绑定到 <code>Bulk_quote *</code> 上</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 容器与继承 </tag>
            
            <tag> 模拟虚拷贝 </tag>
            
            <tag> 多态深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.9 文本查询程序再探</title>
      <link href="/2025/05/10/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.9%20%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F%E5%86%8D%E6%8E%A2/"/>
      <url>/2025/05/10/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.9%20%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F%E5%86%8D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="查询文件-letter-txt"><a href="#查询文件-letter-txt" class="headerlink" title="查询文件 letter.txt"></a>查询文件 letter.txt</h3><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">Alice Emma has long flowing red hair.<br>Her Daddy says when the wind blows<br>through her hair, it looks almost alive,<br>like a fiery bird in flight.<br>A beautiful fiery bird, he tells her ,<br>magical but untamed.<br>&quot;Daddy, shush, there is no such things,&quot;<br>she tells him, at the same time wanting<br>him to tell her more.<br>Shyly, she asks, &quot;I mean, Daddy, is there?&quot;<br></code></pre></td></tr></table></figure><h3 id="支持的查询方式"><a href="#支持的查询方式" class="headerlink" title="支持的查询方式"></a>支持的查询方式</h3><ul><li>单词查询，用于匹配某个给定 string 的所有行</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure><ul><li>逻辑非查询，使用 ~运算符得到不匹配查询条件的所有行</li><li>逻辑或查询，使用 | 运算符返回匹配两个条件中任意一个的行</li><li>逻辑与查询，使用 &amp; 运算符返回匹配全部两个条件的行</li><li>还能够混合使用这些运算符</li></ul><h2 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h2><ul><li>将几种不同的查询建立成相互独立的类，这些类共享一个公共基类：<ul><li>WordQuery</li><li>NotQuery</li><li>OrQuery</li><li>AndQuery</li></ul></li><li>这些类只包含两个操作：<ul><li>eval, 接受一个 TextQuery 对象并返回一个 QueryResult，eval 函数使用给定的 TextQuery 对象查找与之匹配的行</li><li>rep, 返回基础查询的 string 表示形式，eval 函数使用 rep 创建一个表示匹配结果的 QueryResult，输出运算符使用 rep 打印查询表达式</li></ul></li></ul><h3 id="继承与组合"><a href="#继承与组合" class="headerlink" title="继承与组合"></a>继承与组合</h3><ul><li>面向对象设计准则：<ul><li>当令一个类公有的继承另一个类时，派生类应当反应与基类的“<strong>是一种(IS A)</strong>”关系</li><li>公有派生类的对象可以用在任何需要基类对象的地方</li></ul></li></ul><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><ul><li><p>四种查询之间从概念上说互为兄弟关系，因此<strong>这些类都共享同一个接口，所以定义一个抽象基类来表示该接口，命名为 Query_base</strong>，表示它是整个查询继承体系的根节点</p><ul><li>Query_base 将 eval 和 rep 定义为纯虚函数，其他特定查询类型的类必须覆盖这两个函数</li><li>Query_base 直接派生出 WordQuery 和 NotQuery</li><li><p>AndQuery 和 OrQuery 都具有特殊属性：各自包含两个运算对象。因此定义一个 BinaryQuery 抽象基类，用于表示含有两个运算对象的查询</p><ul><li>AndQuery 和 OrQuery 继承自 BinaryQuery ，BinaryQuery 继承自 Query_base</li></ul><pre class="mermaid">    classDiagramdirection TB    class Query_base {    }    class WordQuery {    }    class NotQuery {    }    class BinaryQuery {    }    class AndQuery {    }    class OrQuery {    }    Query_base <|-- WordQuery    Query_base <|-- NotQuery    Query_base <|-- BinaryQuery    BinaryQuery <|-- AndQuery    BinaryQuery <|-- OrQuery</pre></li></ul></li></ul><h3 id="将层次关系隐藏在接口类中"><a href="#将层次关系隐藏在接口类中" class="headerlink" title="将层次关系隐藏在接口类中"></a>将层次关系隐藏在接口类中</h3><ul><li><p>为使程序正常运行，首先创建查询命令，最简单的办法是 C++ 表达式</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Query q = <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;fiery&quot;</span>) &amp; <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;Bird&quot;</span>) | <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;wind&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>用户代码不会直接使用这些继承的类，而是通过名为 Query 的接口类，它负责隐藏整个继承体系。</p></li><li>Query 类将保存一个 Query_base 指针，该指针绑定到 Query_base 的派生类对象上。</li><li>Query 类与 Query_base 提供的操作相同，eval 用于求查询的结果，rep 用于生成查询的 string 版本，同时 Query 定义一个重载的输出运算符用于显示查询</li><li>用户通过 Query 对象间接的创建并处理 Query_base 对象。</li><li>定义 Query 对象的三个重载运算符以及一个接受 string 参数的 Query 构造函数，这些函数动态分配一个新的 Query_base 派生类对象：<ul><li>&amp; 运算符生成一个绑定到新的 AndQuery 对象的 Query 对象</li><li>| 运算符生成一个绑定到新的 OrQuery 对象的 Query 对象</li><li>~ 运算符生成一个绑定到新的 NotQuery 对象 的 Query 对象</li><li>接受 string 参数的构造函数生成一个新的 WordQuery 对象</li></ul></li></ul><h2 id="详细程序设计"><a href="#详细程序设计" class="headerlink" title="详细程序设计"></a>详细程序设计</h2><h3 id="Query-程序接口类和操作"><a href="#Query-程序接口类和操作" class="headerlink" title="Query 程序接口类和操作"></a>Query 程序接口类和操作</h3><div class="table-container"><table><thead><tr><th>Class/Operation</th><th>Description</th></tr></thead><tbody><tr><td>TextQuery</td><td>该类读入一个给定文件，并创建查找图。<br> 这个类包含一个 query 操作，接受一个 string 实参，返回一个 QueryResult 对象。该 QueryResult 对象表示 string 出现的行</td></tr><tr><td>QueryResult</td><td>该类保存一个 query 操作的结果</td></tr><tr><td>Query q(s)</td><td>将 Query 对象 q 绑定到一个存放这 string s 的新 WordQuery 对象上</td></tr><tr><td>q1 &amp; q2</td><td>返回一个 Query 对象，该对象绑定到一个存放 q1 和 q2 的新 AndQuery 对象上</td></tr><tr><td>q1 \</td><td>q2</td><td>返回一个 Query 对象， 该对象绑定到一个存放 q1 和 q2 的新 OrQuery 对象上</td></tr><tr><td>~ q</td><td>返回一个 Query 对象，该对象绑定到一个存放 q 的新 NotQuery 对象上</td></tr></tbody></table></div><h3 id="Query-程序实现类"><a href="#Query-程序实现类" class="headerlink" title="Query 程序实现类"></a>Query 程序实现类</h3><div class="table-container"><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>Query_base</td><td>查询类的抽象基类</td></tr><tr><td>WordQuery</td><td>Query_base 的派生类，用于查找某个给定的单词</td></tr><tr><td>NotQuery</td><td>Query_base 的派生类，查询结果是 Query 运算对象没有出现的行的集合</td></tr><tr><td>BinaryQuery</td><td>Query_base 派生的另一个抽象基类，表示有两个运算对象的查询</td></tr><tr><td>OrdQuery</td><td>BinaryQuery 的派生类，返回它的两个运算对象分别出现的行的并集</td></tr><tr><td>AndQuery</td><td>BinaryQuery 的派生类，返回它的两个运算对象分别出现的行的交集</td></tr></tbody></table></div><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Query-base-类"><a href="#Query-base-类" class="headerlink" title="Query_base 类"></a>Query_base 类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TextQuery.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;QueryResult.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Query_base</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Query</span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">using</span> line_no = TextQuery::line_no;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Query_base</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// eval 返回与当前 Query 匹配的 QueryResult</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> QueryResult &amp; <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp;)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// rep 是表示查询的一个 string</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>eval 和 rep 是纯虚函数，因此 Query_base 是一个抽象基类</li><li>不希望用户或派生类代码直接使用 Query_base，所以没有 public 成员，所有对 Query_base 的使用都需要通过 Query 对象</li><li>因为 Query 需要调用 Query_base 的虚函数，所以将 Query 声明为 Query_base 的友元</li></ul><h3 id="Query-类"><a href="#Query-类" class="headerlink" title="Query 类"></a>Query 类</h3><ul><li>Query 类对外提供接口，同时隐藏 Query_base 的继承体系</li><li>每个 Query 对象都含有一个指向 Query_base 对象的 shared_ptr</li><li>因为 Query 是 Query_base 的唯一接口，所以 Query 必须定义自己的 eval 和 rep 版本</li><li>接受 string 参数的 Query 构造函数将创建一个新的 WordQuery 对象，然后将它的 shared_ptr 成员绑定到这个新创建的对象上</li><li>&amp; 、|、~ 运算符分别创建 AndQuery、OrQuery、NotQuery 对象，这些运算符返回一个绑定到新创建对象上的 Query 对象<ul><li>为支持这些运算符，Query 还需要另一个构造函数，它接受 Query_base 的 shared_ptr 并且存储给定的指针</li><li>由于不希望一般的用户代码随便定义 Query_base 对象，因此将这个构造函数声明为 private，并且将三个运算符函数声明为友元</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这是一个管理 Query_base 继承体系的接口类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Query</span> &#123;<br>    <span class="hljs-comment">// 这些运算符需要访问接受 shared_ptr 的构造函数，而该函数是私有的</span><br>    <span class="hljs-keyword">friend</span> Query <span class="hljs-keyword">operator</span>~(<span class="hljs-type">const</span> Query &amp;);<br>    <span class="hljs-keyword">friend</span> Query <span class="hljs-keyword">operator</span>&amp;(<span class="hljs-type">const</span> Query &amp;, <span class="hljs-type">const</span> Query &amp;);<br>    <span class="hljs-keyword">friend</span> Query <span class="hljs-keyword">operator</span>|(<span class="hljs-type">const</span> Query &amp;, <span class="hljs-type">const</span> Query &amp;);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Query</span>(<span class="hljs-type">const</span> std::string &amp; );    <span class="hljs-comment">// 构建一个新的 WordQuery</span><br>    <span class="hljs-comment">// 接口函数：调用对应的 Query_base 操作</span><br>    <span class="hljs-function">QueryResult <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp; t)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> q-&gt;<span class="hljs-built_in">eval</span>(t); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> q-&gt;<span class="hljs-built_in">rep</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Query</span>(std::shared_ptr&lt;Query_base&gt; query) : <span class="hljs-built_in">q</span>(query) &#123; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;Query_base&gt; q;<br>&#125;;<br><br>Query <span class="hljs-keyword">operator</span>~(<span class="hljs-type">const</span> Query &amp;);<br>Query <span class="hljs-keyword">operator</span>&amp;(<span class="hljs-type">const</span> Query &amp;, <span class="hljs-type">const</span> Query &amp;);<br>Query <span class="hljs-keyword">operator</span>|(<span class="hljs-type">const</span> Query &amp;, <span class="hljs-type">const</span> Query &amp;);<br></code></pre></td></tr></table></figure><ul><li>eval 和 rep 公有成员是 Query_base 的接口，Query 操作使用它的 Query_base 指针来调用各自的 Query_base 虚函数。<strong>实际调用哪个函数版本由 q 指向的对象类型决定，并且直到运行时才能确定下来</strong></li></ul><h4 id="Query-的输出运算符"><a href="#Query-的输出运算符" class="headerlink" title="Query 的输出运算符"></a>Query 的输出运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> Query &amp; query) &#123;<br>    os &lt;&lt; query.<span class="hljs-built_in">rep</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运算符函数通过指针成员虚调用当前 Query 所指对象的 rep 成员</li></ul><h3 id="WordQuery-类"><a href="#WordQuery-类" class="headerlink" title="WordQuery 类"></a>WordQuery 类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordQuery</span> : <span class="hljs-keyword">public</span> Query_base&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Query</span>;     <span class="hljs-comment">// Query 使用 WordQuery 的构造函数</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">WordQuery</span>(<span class="hljs-type">const</span> std::string &amp; s) : <span class="hljs-built_in">query_word</span>(s) &#123; &#125;<br>    <span class="hljs-comment">// 具体的类，WordQuery 将定义所有继承而来的纯虚函数</span><br>    <span class="hljs-function">QueryResult <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp; t)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">            </span>&#123; <span class="hljs-keyword">return</span> t.<span class="hljs-built_in">query</span>(query_word); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> query_word; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string query_word;     <span class="hljs-comment">// 要查询的单词</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>WordQUery 没有 public 成员，Query 必须作为 WordQuery 的友元，才能访问 WordQuery 的构造函数</li><li>eval 调用其 TextQuery 参数的 query 成员，由 query 成员实际在文件中进行查找</li><li>rep 返回这个 WordQuery 表示的 string</li></ul><h4 id="定义接受-string-的-Query-构造函数"><a href="#定义接受-string-的-Query-构造函数" class="headerlink" title="定义接受 string 的 Query 构造函数"></a>定义接受 string 的 Query 构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-title">Query::Query</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span> : q(new WordQuery(s)) &#123;</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="NotQuery-类及-运算符"><a href="#NotQuery-类及-运算符" class="headerlink" title="NotQuery 类及 ~ 运算符"></a>NotQuery 类及 ~ 运算符</h3><ul><li>~ 运算符生成一个 NotQuery，其中保存着一个需要将其取反的 Query</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NotQuery</span> : <span class="hljs-keyword">public</span> Query_base&#123;<br>    <span class="hljs-keyword">friend</span> Query <span class="hljs-keyword">operator</span>~(<span class="hljs-type">const</span> Query &amp;);<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">NotQuery</span>(<span class="hljs-type">const</span> Query &amp; q) : <span class="hljs-built_in">query</span>(q) &#123; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;~(&quot;</span> + query.<span class="hljs-built_in">rep</span>() + <span class="hljs-string">&quot;)&quot;</span>; &#125;<br>    <span class="hljs-function">QueryResult <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">private</span>:<br>    Query query;<br>&#125;;<br><br><span class="hljs-keyword">inline</span><br>Query <span class="hljs-keyword">operator</span>~(<span class="hljs-type">const</span> Query &amp; operand) &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;Query_base&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">NotQuery</span>(operand));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>NotQuery 的 rep 成员中对 rep 的调用是一个虚调用：</strong><ul><li>query.rep() 是对 Query 类的 rep 成员的非虚调用</li><li>接着 Query::rep 将调用 q-&gt;rep() ，这是一个通过 Query_base 指针进行的虚调用</li></ul></li><li><strong>~ 运算符动态分配一个新的 NotQuery 对象，其 return 语句隐式的使用一个接受 shared_ptr\<Query_base> 的 Query 构造函数</strong></li></ul><h3 id="BinaryQuery-类"><a href="#BinaryQuery-类" class="headerlink" title="BinaryQuery 类"></a>BinaryQuery 类</h3><ul><li>BinaryQuery 类也是一个抽象基类</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryQuery</span> : <span class="hljs-keyword">public</span> Query_base &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">BinaryQuery</span>(<span class="hljs-type">const</span> Query &amp; l, <span class="hljs-type">const</span> Query &amp; r, std::string &amp; s) :<br>                <span class="hljs-built_in">lhs</span>(l), <span class="hljs-built_in">rhs</span>(r), <span class="hljs-built_in">opSym</span>(s) &#123; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">rep</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + lhs.<span class="hljs-built_in">rep</span>() + <span class="hljs-string">&quot; &quot;</span> + opSym + <span class="hljs-string">&quot; &quot;</span> + rhs.<span class="hljs-built_in">rep</span>() + <span class="hljs-string">&quot;)&quot;</span> ;&#125;<br><span class="hljs-keyword">protected</span>:<br>    Query lhs, rhs;     <span class="hljs-comment">// 左侧和右侧运算对象</span><br>    std::string opSym;  <span class="hljs-comment">// 运算符的名字</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>BinaryQuery 的数据成员是两个运算对象以及一个运算符</li><li>构造函数接受两个运算对象和一个运算符符号，然后将它们存入数据成员中</li><li>rep 一个 BinaryQuery ，需要生成一个带括号的表达式<ul><li>对 rep 的调用最终是对 lhs 和 rhs 所指的 Query_base 对象的 rep 函数进行虚调用</li></ul></li><li>BinaryQuery 不定义 eval ，而是继承该纯虚函数，因此 BinaryQuery 是一个抽象基类，不能创建 BinaryQuery 类型的对象</li></ul><h3 id="AndQuery-类、OrQuery-类及相应的运算符"><a href="#AndQuery-类、OrQuery-类及相应的运算符" class="headerlink" title="AndQuery 类、OrQuery 类及相应的运算符"></a>AndQuery 类、OrQuery 类及相应的运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AndQuery</span> : <span class="hljs-keyword">public</span> BinaryQuery&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> Query <span class="hljs-keyword">operator</span>&amp;(<span class="hljs-type">const</span> Query&amp;, <span class="hljs-type">const</span> Query &amp;);<br>    <span class="hljs-built_in">AndQuery</span>(<span class="hljs-type">const</span> Query &amp;left, <span class="hljs-type">const</span> Query &amp;right) :<br>                                            <span class="hljs-built_in">BinaryQuery</span>(left, right, <span class="hljs-string">&quot;&amp;&quot;</span>) &#123; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 具体的类：AndQuery 继承了 rep ，并定义了其他纯虚函数</span><br>    <span class="hljs-function">QueryResult <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp;)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">inline</span><br>Query <span class="hljs-keyword">operator</span>&amp;(<span class="hljs-type">const</span> Query &amp; lhs, <span class="hljs-type">const</span> Query &amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;Query_base&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">AndQuery</span>(lhs, rhs));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrQuery</span> : <span class="hljs-keyword">public</span> BinaryQuery&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> Query <span class="hljs-keyword">operator</span>|(<span class="hljs-type">const</span> Query &amp;, <span class="hljs-type">const</span> Query&amp;);<br>    <span class="hljs-built_in">OrQuery</span>(<span class="hljs-type">const</span> Query &amp; left, <span class="hljs-type">const</span> Query &amp; right) :<br>            <span class="hljs-built_in">BinaryQuery</span>(left, right, <span class="hljs-string">&quot;|&quot;</span>) &#123; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 具体的类，OrQuery 继承了 rep，定义了其他纯虚函数</span><br>    <span class="hljs-function">QueryResult <span class="hljs-title">eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp; )</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">inline</span><br>Query <span class="hljs-keyword">operator</span>|(<span class="hljs-type">const</span> Query &amp; lhs, <span class="hljs-type">const</span> Query &amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;Query_base&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">OrQuery</span>(lhs, rhs));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="eval-函数实现"><a href="#eval-函数实现" class="headerlink" title="eval 函数实现"></a>eval 函数实现</h3><ul><li>OrQuery 的 eval 操作返回两个运算对象查询结果的并集</li><li>AndQuery 的 eval 操作返回两个运算对象查询结果的交集</li><li>NotQuery 需要返回运算对象没有出现的文本行</li></ul><h4 id="OrQuery-eval"><a href="#OrQuery-eval" class="headerlink" title="OrQuery::eval"></a>OrQuery::eval</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueryResult <span class="hljs-title">OrQuery::eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp; text)</span> <span class="hljs-type">const</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;OrQuery::eval&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 通过 Query 成员 lhs 和 rhs 进行的虚调用</span><br>    <span class="hljs-comment">// 调用 eval 返回每个运算对象的 QueryResult</span><br>    <span class="hljs-keyword">auto</span> right = rhs.<span class="hljs-built_in">eval</span>(text), left = lhs.<span class="hljs-built_in">eval</span>(text);<br>    <span class="hljs-comment">// 将左侧运算对象的行号 set 拷贝到结果 set 中</span><br>    <span class="hljs-keyword">auto</span> ret_lines = std::make_shared&lt;std::set&lt;line_no&gt;&gt;(left.<span class="hljs-built_in">begin</span>(), left.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 插入右侧运算对象所得的行号</span><br>    ret_lines-&gt;<span class="hljs-built_in">insert</span>(right.<span class="hljs-built_in">begin</span>(), right.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">// 返回一个新的 QueryResult，表示 lhs 和 rhs 的并集</span><br>    <span class="hljs-keyword">return</span> QueryResult&#123;<span class="hljs-built_in">rep</span>(), ret_lines, left.<span class="hljs-built_in">get_file</span>()&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ret_lines 先将左侧运算对象的行号 set 拷贝进来，然后将右侧运算对象的行号进行插入，最终 ret_lines 中将包含左侧与右侧运算对象的所有行号</li></ul><h4 id="AndQuery-eval"><a href="#AndQuery-eval" class="headerlink" title="AndQuery::eval"></a>AndQuery::eval</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueryResult <span class="hljs-title">AndQuery::eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp; text)</span> <span class="hljs-type">const</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;AndQuery::eval&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 通过 Query 运算对象进行的虚调用，以获得运算对象的查询结果 set</span><br>    <span class="hljs-keyword">auto</span> right = rhs.<span class="hljs-built_in">eval</span>(text), left = lhs.<span class="hljs-built_in">eval</span>(text);<br>    <span class="hljs-comment">// 创建保存 left 与 right 交集的 set</span><br>    <span class="hljs-keyword">auto</span> ret_lines = std::make_shared&lt;std::set&lt;line_no&gt;&gt;();<br>    <span class="hljs-comment">// 将两个范围的交集写入一个目的迭代器中</span><br>    <span class="hljs-comment">// 本次调用的目的迭代器向 ret_lines 中添加元素</span><br>    std::<span class="hljs-built_in">set_intersection</span>(left.<span class="hljs-built_in">begin</span>(), left.<span class="hljs-built_in">end</span>(),<br>                          right.<span class="hljs-built_in">begin</span>(), right.<span class="hljs-built_in">end</span>(),<br>                          std::<span class="hljs-built_in">inserter</span>(*ret_lines, ret_lines-&gt;<span class="hljs-built_in">begin</span>()));<br>    <span class="hljs-comment">// 返回一个新的 QueryResult 对象，表示两个运算对象的交集</span><br>    <span class="hljs-keyword">return</span> QueryResult&#123;<span class="hljs-built_in">rep</span>(), ret_lines, left.<span class="hljs-built_in">get_file</span>()&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用标准库算法 set_intersection 来合并两个 set，计算它们的交集<ul><li>set_intersection 接受五个参数，前四个参数表示两个输入序列，最后一个参数表示目的位置，在上述代码中，传入了一个 ret_lines 的插入迭代器来作为目的位置</li></ul></li></ul><h4 id="NotQuery-eval"><a href="#NotQuery-eval" class="headerlink" title="NotQuery::eval"></a>NotQuery::eval</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">QueryResult <span class="hljs-title">NotQuery::eval</span><span class="hljs-params">(<span class="hljs-type">const</span> TextQuery &amp;text)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-comment">// 通过 Query 对象对 eval 进行虚调用</span><br>    <span class="hljs-keyword">auto</span> result = query.<span class="hljs-built_in">eval</span>(text);<br>    <span class="hljs-comment">// 创建一个空 set 用来保存没有出现运算对象的行号</span><br>    <span class="hljs-keyword">auto</span> ret_lines = std::make_shared&lt;std::set&lt;line_no&gt;&gt;();<br>    <span class="hljs-comment">// 必须在运算对象出现的所有行进行迭代</span><br>    <span class="hljs-keyword">auto</span> beg = result.<span class="hljs-built_in">begin</span>(), end = result.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-comment">// 对于输入文件的每一行，如果该行不在 result 中，则将其添加到 ret_lines 中</span><br>    <span class="hljs-keyword">auto</span> sz = result.<span class="hljs-built_in">get_file</span>()-&gt;<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> n = <span class="hljs-number">0</span>; n != sz; ++n) &#123;<br>        <span class="hljs-comment">// 如果还没有处理完 result 的所有行</span><br>        <span class="hljs-comment">// 检查当前行是否在 result 中</span><br>        <span class="hljs-keyword">if</span> (beg == end || *beg != n )<br>            ret_lines-&gt;<span class="hljs-built_in">insert</span>(n);   <span class="hljs-comment">// 如果不在 result 中，添加这一行</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beg != end)<br>            ++beg;                  <span class="hljs-comment">// 否则继续获取 result 的下一个行号</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> QueryResult&#123;<span class="hljs-built_in">rep</span>(), ret_lines, result.<span class="hljs-built_in">get_file</span>()&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要想得到最终结果，需要从 0 遍历不超过文件大小的整数，并将所有不在 result 中的行号添加到 ret_lines 中</li><li>在上面 for 循环中判断当前整数 n 是否在 result 中的逻辑如下<ul><li>n 从 0 开始按升序递增，而 result 中的行号序列 set 也是按升序排列</li><li>beg 与 n 在for 循环中的递增是不同步的，<strong>类似于快慢指针</strong></li><li>当 n 与 beg 指向的行号不等时，意味着 n 不在 result 中，beg 不动，n 继续递增</li><li>当 n 与 beg 指向的行号相等时，意味着当前 n 在 result 中，此时 beg 递增，n 也递增，继续比较 result 的下一个元素</li></ul></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;../Resource/letter.txt&quot;</span>)</span></span>;<br><span class="hljs-function">TextQuery <span class="hljs-title">tq</span><span class="hljs-params">(ifs)</span></span>;<br>Query q = <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;fiery&quot;</span>) &amp; <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;bird&quot;</span>) | <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;wind&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; q;<br></code></pre></td></tr></table></figure><h3 id="构造函数执行过程"><a href="#构造函数执行过程" class="headerlink" title="构造函数执行过程"></a>构造函数执行过程</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Query q = <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;fiery&quot;</span>) &amp; <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;bird&quot;</span>) | <span class="hljs-built_in">Query</span>(<span class="hljs-string">&quot;wind&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Mermaid">flowchart TD<br>  subgraph Build_Fiery<br>    A1[&quot;调用 Query(&#x27;fiery&#x27;)&quot;]<br>    A2[&quot;Query 构造 → new WordQuery(&#x27;fiery&#x27;)&quot;]<br>    A1 --&gt; A2<br>  end<br><br>  subgraph Build_Bird<br>    B1[&quot;调用 Query(&#x27;bird&#x27;)&quot;]<br>    B2[&quot;Query 构造&lt;br/&gt;→ new WordQuery(&#x27;bird&#x27;)&quot;]<br>    B1 --&gt; B2<br>  end<br><br>  subgraph And_Op<br>    A2 --&gt; C1[&quot;inline operator&amp;&quot;]<br>    B2 --&gt; C1<br>    C2[&quot;new AndQuery(lhs, rhs)&quot;]<br>    C1 --&gt; C2<br>    C3[&quot;AndQuery(rep=&#x27;(fiery &amp; bird)&#x27;)&quot;]<br>    C2 --&gt; C3<br>  end<br><br>  subgraph Build_Wind<br>    D1[&quot;调用 Query(&#x27;wind&#x27;)&quot;]<br>    D2[&quot;Query 构造 → new WordQuery(&#x27;wind&#x27;)&quot;]<br>    D1 --&gt; D2<br>  end<br><br>  subgraph Or_Op<br>    C3 --&gt; E1[&quot;inline operator|&quot;]<br>    D2 --&gt; E1<br>    E2[&quot;new OrQuery(lhs, rhs)&quot;]<br>    E1 --&gt; E2<br>    E3[&quot;OrQuery(rep=&#x27;((fiery &amp; bird) | wind)&#x27;)&quot;]<br>    E2 --&gt; E3<br>  end<br><br>  subgraph Assign_q<br>    E3 --&gt; F1[&quot;临时 Query 对象&quot;]<br>    F1 --&gt; F2[&quot;复制初始化 → q&quot;]<br>  end<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><blockquote><ol><li>文本处理层<ul><li>TextQuery 读取文件，保存每一行文本，并建立“单词—-&gt;行号集合”映射</li><li>QueryResult 保存查询结果</li></ul></li><li>查询接口层<ul><li>Query_base 抽象基类，定义纯虚接口 eval 和 rep</li><li>派生类<ul><li>WordQuery 查单词</li><li>NotQuery 取反</li><li>BinaryQuery 中间抽象<ul><li>AndQuery 并集</li><li>OrQuery 交集</li></ul></li></ul></li></ul></li><li>用户界面层<ul><li>Query：对外唯一接口，内部以 <code>std::shared_ptr&lt;Query_base&gt;</code> 持有一颗查询表达式树，并重载 <code>~</code>，<code>|</code>，<code>&amp;</code> 构造复合查询</li></ul></li></ol></blockquote><h3 id="面向对象与多态"><a href="#面向对象与多态" class="headerlink" title="面向对象与多态"></a>面向对象与多态</h3><blockquote><ol><li><strong>策略模式</strong><ul><li>抽象出 Query_base （策略接口）和多个派生类（ WordQuery, NotQuery, AndQuery, OrQuery），每个派生类都实现同一组接口 eval 和 rep，<strong>从而将算法与使用它的上下文分离</strong></li></ul></li><li>接口与实现分离<ul><li>客户端（其他用户代码）只面对 Query 这一 “句柄” 类，无需了解底层继承体系，也不直接 new/delete 派生类对象</li><li>将公共接口（eval 和 rep）与具体实现放在不同的类层次中，增强可维护性和可扩展性</li></ul></li><li>多态深拷贝<ul><li>如果改用裸指针而不是智能指针，则需要为基类添加 <code>virtual clone()</code> 接口, 让拷贝构造时能<strong>根据动态类型生成完整拷贝</strong>，避免对象“切片”</li></ul></li></ol></blockquote><h3 id="C-资源管理"><a href="#C-资源管理" class="headerlink" title="C++ 资源管理"></a>C++ 资源管理</h3><blockquote><ol><li>智能指针(std::shared_ptr)<ul><li>自动管理声明周期，无需手工 delete；多个 Query 实例可共享同一底层对象</li><li>避免内存泄漏和悬空指针</li></ul></li><li>RAII 原则<ul><li>构造即获取资源，析构即释放资源。所有 new 都被智能指针封装，不会漏掉 delete</li></ul></li><li>值语义与引用语义结合<ul><li>Query 对象本身可按值拷贝，实际上是共享底层对象（引用计数），即“轻量句柄”模式</li></ul></li></ol></blockquote><h3 id="模块化与可扩展性"><a href="#模块化与可扩展性" class="headerlink" title="模块化与可扩展性"></a>模块化与可扩展性</h3><blockquote><ol><li>松耦合设计<ul><li>新增查询类型时，只要继承 Query_base、实现 eval/rep，接着为它定义一个运算符，整个系统就能无缝支持新功能</li></ul></li><li>单一职责原则<ul><li>每个类仅承担一件事<ul><li>TextQuery 负责文件读取与索引</li><li>QueryResult 负责结果封装</li><li>各 Query_base 派生类负责一种查询策略</li><li>Query 负责对外接口和组合表达式</li></ul></li></ul></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 文本查询程序 </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.7 构造函数与拷贝控制</title>
      <link href="/2025/05/09/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.7%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
      <url>/2025/05/09/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.7%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>位于继承体系中的类也需要控制当其对象执行一系列操作时发生什么行为，这些<strong>操作包括创建、拷贝、移动、赋值、销毁</strong></li><li>如果一个类没有定义拷贝控制操作，编译器将合成一个版本。这个合成版本也可以定义为被删除的函数</li></ul><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><ul><li>当 delete 一个动态分配对象的指针时执行析构函数</li><li>如果<strong>该指针指向继承体系中的某个类型，则就有可能出现指针的静态类型与被删除对象的动态类型不符的情况</strong>，此时使用 delete ，编译器就必须清楚执行的是哪个类型的析构函数</li><li><strong>如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的指针将产生未定义行为</strong></li><li>对于<strong>普通类型</strong>，有一条经验准则：<strong>如果一个类需要析构函数，则它也需要拷贝和赋值操作</strong>。而<strong>基类的析构函数是例外，并不遵循这一准则</strong></li></ul><h3 id="虚析构函数将阻止合成移动操作"><a href="#虚析构函数将阻止合成移动操作" class="headerlink" title="虚析构函数将阻止合成移动操作"></a>虚析构函数将阻止合成移动操作</h3><ul><li><strong>如果一个类定义了析构函数，即使它通过 <code>=default</code> 的形式使用了合成版本，编译器也不会为这个类提供合成的移动操作</strong>，它的移动操作实际使用拷贝构造函数来完成</li></ul><h2 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h2><ul><li>基类或派生类中的合成拷贝控制成员与其他合成的构造函数、赋值运算符、析构函数类似：<ul><li>它们对类本身的成员依次进行初始化、赋值、销毁</li><li>这些合成的成员还负责使用其直接基类中的对应操作对一个对象的直接基类部分进行初始化、赋值、销毁</li></ul></li></ul><h3 id="派生类中删除的拷贝控制与基类的关系"><a href="#派生类中删除的拷贝控制与基类的关系" class="headerlink" title="派生类中删除的拷贝控制与基类的关系"></a>派生类中删除的拷贝控制与基类的关系</h3><ul><li>基类或派生类可以将其合成的构造函数或拷贝控制成员定义为被删除的函数(deleted function)</li><li>某些<strong>定义基类的方式也可能使得派生类成员成为被删除的函数</strong>：<ul><li><strong>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符、析构函数是 deleted function 或者不可访问，则派生类中的对应成员也是 deleted function</strong>。原因是编译器不能使用基类成员来指向派生类中基类部分的构造、赋值、销毁</li><li><strong>如果基类中有一个不可访问或被删除掉的析构函数，则派生类中合成的默认构造函数、拷贝构造函数将是被删除的</strong>，因为编译器无法销毁派生类对象的基类部分</li><li><strong>编译器将不会合成一个删除掉的移动操作</strong>。当使用 =default 请求一个移动操作时，如果基类中的移动操作是 deleted 或是不可访问的，那么派生类中该函数将是 deleted function，<strong>原因是派生类对象中的基类部分不能被移动</strong></li></ul></li></ul><h3 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h3><ul><li>因为基类中缺少移动操作会阻止派生类拥有自己的移动操作，所以当确实需要移动操作时应先在基类中进行定义</li><li>Quote 可以使用合成的版本，不过必须显式的定义这些成员，一旦显式的定义了移动操作，就必须显式的定义拷贝操作</li></ul><h2 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h2><ul><li>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，<strong>也要拷贝和移动基类部分的成员</strong>。派生类的赋值运算符<strong>也需要为其基类部分赋值</strong></li><li>析构函数只负责销毁派生类自己分配的资源，同时其基类析构函数也会隐式销毁基类部分</li></ul><h3 id="定义派生类的拷贝或移动构造函数"><a href="#定义派生类的拷贝或移动构造函数" class="headerlink" title="定义派生类的拷贝或移动构造函数"></a>定义派生类的拷贝或移动构造函数</h3><ul><li>为派生类定义拷贝或移动构造函数时，通常使用基类的构造函数初始化对象的基类部分</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;....&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认情况下，基类的默认构造函数初始化对象的基类部分</span><br>    <span class="hljs-comment">// 要想使用拷贝或移动构造函数，必须在构造函数初始化列表中显式的调用该构造函数</span><br>    <span class="hljs-built_in">D</span> (<span class="hljs-type">const</span> D &amp; d) : <span class="hljs-built_in">Base</span>(d) <span class="hljs-comment">// 拷贝基类成员</span><br>                      ...     <span class="hljs-comment">// D 的成员初始值</span><br>                    &#123; ... &#125;<br>    <span class="hljs-built_in">D</span> (D &amp;&amp; d) : <span class="hljs-built_in">Base</span>(std::<span class="hljs-built_in">move</span>(d)) <span class="hljs-comment">// 移动基类成员</span><br>                ...      <span class="hljs-comment">// D 的成员初始值</span><br>                &#123; ... &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>在 D 派生类中，如果没有提供基类 Base 的初始值，则对象的<strong>基类部分就执行默认初始化，而不是拷贝</strong></li></ul><h3 id="派生类赋值运算符"><a href="#派生类赋值运算符" class="headerlink" title="派生类赋值运算符"></a>派生类赋值运算符</h3><ul><li>派生类的赋值运算符也必须显式的为其基类部分赋值</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Base::operator=(const Base &amp; rhs) 不会被自动调用</span><br>D &amp; D::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> D &amp; rhs) &#123;<br>    Base::<span class="hljs-keyword">operator</span>=(rhs);   <span class="hljs-comment">// 为基类部分赋值</span><br>    <span class="hljs-comment">// 为派生类成员赋值</span><br>    <span class="hljs-comment">// 酌情处理自赋值及释放已有资源等情况</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="派生类析构函数"><a href="#派生类析构函数" class="headerlink" title="派生类析构函数"></a>派生类析构函数</h3><ul><li>在析构函数体执行完毕，对象的成员会被隐式销毁，对象的基类部分也是隐式销毁的</li><li>对象的销毁顺序正好与创建顺序相反，派生类的析构函数首先执行，然后是基类的析构函数</li></ul><h3 id="在构造函数与析构函数中调用虚函数"><a href="#在构造函数与析构函数中调用虚函数" class="headerlink" title="在构造函数与析构函数中调用虚函数"></a>在构造函数与析构函数中调用虚函数</h3><ul><li>如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本</li></ul><h2 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h2><ul><li>新标准中，<strong>派生类能够重用其直接基类的构造函数</strong></li><li>一个类只能初始化它的直接基类，<strong>一个类也只能继承它直接基类的构造函数</strong></li><li><strong>类不能继承默认、拷贝、移动构造函数</strong>，如果派生类没有定义这些构造函数，编译器会自动合成</li><li><p>派生类继承基类构造函数的方式：</p><ul><li>使用一条注明了直接基类名的 using 声明语句</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span> : <span class="hljs-keyword">public</span> Disc_quote &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Disc_quote::Disc_quote;   <span class="hljs-comment">// 继承 Disc_quote 的构造函数</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>通常情况下，using 语句只是令某个名字在作用域内可见。当 using 作用于构造函数时，将令编译器产生代码。对于基类的每个构造函数，编译器都会在派生类中生成一个形参列表完全相同的构造函数</p></li><li><p>Bulk_quote 继承的构造函数等价于 ：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Bulk_quote::<span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-type">const</span> std::string &amp;book, <span class="hljs-type">double</span> p, std::<span class="hljs-type">size_t</span> qty, <span class="hljs-type">double</span> disc) :<br>        <span class="hljs-built_in">Disc_quote</span>(book, p, qty, disc) &#123; &#125;<br></code></pre></td></tr></table></figure></li><li><p>如果派生类含有自己的数据成员，则将这些数据成员默认初始化</p></li></ul><h3 id="继承的构造函数的特点"><a href="#继承的构造函数的特点" class="headerlink" title="继承的构造函数的特点"></a>继承的构造函数的特点</h3><ul><li><strong>与普通成员的 using 声明不同，一个构造函数的 using 声明不会改变它的访问级别</strong>：<ul><li>不管 using 声明出现在哪里，基类的 private 构造函数在派生类中还是一个 private 构造函数，protected 和 public 同样如此</li></ul></li><li><strong>一个 using 声明不能指定 explicit 或 constexpr</strong>：<ul><li>如果基类的构造函数是 explicit 或 constexpr，则继承的构造函数也有相同的属性</li></ul></li><li><strong>当一个基类构造函数含有默认实参，这些实参并不会被继承，相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参</strong>：<ul><li>如果基类构造函数接受两个形参，第二个形参有默认实参，则派生类获得两个构造函数，一个构造函数接受两个形参（没有默认实参），一个构造函数只接受一个形参，对应基类中没有默认值的那个形参</li></ul></li><li><strong>派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本</strong>。<ul><li>如果派生类定义的构造函数与基类的构造函数有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 继承拷贝控制成员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.3 虚函数</title>
      <link href="/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.3%20%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.3%20%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li><strong>当使用基类的引用或指针调用虚函数时会发生动态绑定</strong>，直到运行时才能知道到底调用了哪个版本的函数，因此<strong>所有的虚函数都必修有定义</strong></li></ul><h2 id="对虚函数的调用可能在运行时才被解析"><a href="#对虚函数的调用可能在运行时才被解析" class="headerlink" title="对虚函数的调用可能在运行时才被解析"></a>对虚函数的调用可能在运行时才被解析</h2><ul><li>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。<strong>被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个</strong></li><li>当<strong>通过一个普通类型(非引用或指针) 的表达式调用虚函数时，在编译时就会将调用的版本确定下来</strong></li></ul><h2 id="C-的多态性"><a href="#C-的多态性" class="headerlink" title="C++ 的多态性"></a>C++ 的多态性</h2><ul><li>OOP 的核心思想是<strong>多态性(polymorphism)</strong></li><li>把具有继承关系的多个类型称为多态模型，引用或指针的静态类型与动态类型不同这一事实正是 C++ 支持多态性的根本</li></ul><blockquote><ul><li><font size=4>当且仅当**使用引用或指针调用虚函数时，才会发生动态绑定，才会在运行时解析该调用，也只有在这种情况下对象的动态类型和静态类型才可能不同**</font></li></ul></blockquote><ul><li>对<strong>非虚函数在编译时就进行绑定。通过对象调用的虚函数或非虚函数也在编译时进行绑定。对象的类型是确定不变的</strong></li></ul><h2 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h2><ul><li><strong>某个函数一旦被声明为虚函数，则它在所有派生类中都是虚函数</strong></li><li>在派生类中如果覆盖了基类的某个虚函数，则：<ul><li><strong>它的形参类型要与基类函数一致</strong></li><li>函数的<strong>返回类型也必须与基类函数匹配</strong>，但是有一个例外，<strong>如果类的返回类型是类本身的引用或指针时，这个规则无效</strong>：例如：D 是 由 B 派生的，则基类的虚函数可以返回 B<em>，而派生类的虚函数可以返回 D</em> ，这样的返回类型要求从 D 到 B 的类型转换是可访问的</li></ul></li></ul><h3 id="final-和-override-说明符"><a href="#final-和-override-说明符" class="headerlink" title="final 和 override 说明符"></a>final 和 override 说明符</h3><ul><li><strong>派生类中定义与基类虚函数名字相同但形参列表不同的函数</strong>是合法行为，编译器将认为新定义的这个函数与基类的虚函数相互独立，这时，<strong>派生类的函数并没有覆盖掉基类的虚函数</strong>，但是通常希望派生类中定义的这个函数可以覆盖掉基类的虚函数</li><li><strong><code>override</code> 说明符</strong>：可以使用 <strong><code>override</code> 说明符</strong>，使得意图更加明显，编译器可以发现错误: 如果<strong>使用了 override 标记某个函数，当这个函数没有覆盖基类虚函数时，编译器会报错</strong></li><li><strong><code>final</code> 说明符</strong>：使用 <strong>final 说明符标记某个函数，则之后任何尝试覆盖该函数的行为都会报错</strong></li><li>final 和 override 说明符出现在形参列表(包括 const 或 引用修饰符)以及尾置返回类型之后</li></ul><h3 id="虚函数和默认实参"><a href="#虚函数和默认实参" class="headerlink" title="虚函数和默认实参"></a>虚函数和默认实参</h3><ul><li><strong>虚函数也可以有默认实参</strong>：如果某次调用使用了默认实参，则该<strong>实参值由本次调用的静态类型决定</strong><ul><li>基类的引用或指针调用该函数，则使<strong>用基类中定义的默认实参</strong>。<strong>即使实际运行的是派生类中的函数也是如此</strong>。此时，<strong>传入派生类函数中的参数将是基类中定义的默认实参</strong></li></ul></li><li>如果虚函数使用默认实参，则<strong>基类和派生类中的默认实参最好保持一致</strong></li></ul><h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><ul><li>某些情况下，希望<strong>对虚函数的调用不要进行动态绑定</strong>，<strong>而是强迫执行虚函数的某个特定版本 —— 使用作用域运算符可以实现</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 强调使用基类中的虚函数版本，而不管 baseP 的动态类型是什么</span><br><span class="hljs-type">double</span> undiscounted = baseP-&gt;Quote::<span class="hljs-built_in">net_price</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><ul><li>通常情况下，只有成员函数(或友元函数) 中的代码才需要使用作用域运算符来回避虚函数</li><li>通常，<strong>当一个派生类的虚函数调用它所覆盖的基类的虚函数时，需要使用回避虚函数的默认机制</strong></li><li>如果一个<strong>派生类函数调用其基类版本时，没有使用作用域运算符</strong>，则<strong>在运行时被解析为对派生类版本自身的调用</strong>，<strong>导致无限递归</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.5 访问控制与继承</title>
      <link href="/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.5%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.5%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>每个类控制自己的成员初始化过程</li><li>每个类分别控制自己的成员对于派生类来说是否<strong>可访问(accessible)</strong></li></ul><h2 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h2><ul><li><p>使用 <strong><code>protected</code> 关键字</strong>声明那些希望<strong>与派生类共享，但不想被其他公共访问使用的成员</strong></p><ul><li>和 private 成员类似，protected 成员<strong>对于类的用户来说不可访问</strong></li><li>和 public 成员类似，protected 成员<strong>对于派生类的成员和友元来说是可访问的</strong></li><li><font size=5>**派生类的成员或友元只能通过派生类对象来访问基类的受保护成员**。**派生类对于一个基类对象中的受保护成员没有访问权限**</font><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> prot_mem;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sneaky</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky&amp;)</span></span>;   <span class="hljs-comment">// 可以访问 Sneaky::prot_mem</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base&amp;)</span></span>;     <span class="hljs-comment">// 不能访问 Base::prot_mem</span><br><span class="hljs-type">int</span> j;      <span class="hljs-comment">// 默认是 private</span><br>&#125;;<br><br><span class="hljs-comment">// 正确，clobber 能访问 Sneaky 对象的 private 成员和 protected 成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky &amp; s)</span> </span>&#123; s.j = s.prot_mem = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-comment">// 错误，clobber 不能访问 Base 的 protected 成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base &amp; b)</span>  </span>&#123; b.prot_mem = <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="公有、私有、受保护继承"><a href="#公有、私有、受保护继承" class="headerlink" title="公有、私有、受保护继承"></a>公有、私有、受保护继承</h2><ul><li>某个类对继承而来的成员的访问权限受两个因素影响：<ul><li>基类中该成员的访问说明符</li><li>派生类的派生列表中的访问说明符</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pub_mem</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prot_mem</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">priv_mem</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pub_Derv</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">prot_mem</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">p</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">pub_mem</span>(); &#125;<br>    <span class="hljs-comment">// 错误，基类的 private 成员对于派生类来说是不可访问的 </span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">priv_mem</span>(); &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Priv_Derv</span> : <span class="hljs-keyword">private</span> Base &#123;<br>    <span class="hljs-comment">// 派生列表的 private 不影响派生类对基类的访问权限</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">prot_mem</span>(); &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Prot_Derb</span> : <span class="hljs-keyword">protected</span> Base &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">prot_mem</span>();&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">k</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">pub_mem</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>派生访问说明符对于派生类的成员(及友元)访问其直接基类的成员没影响。对基类成员的访问权限只与基类中的访问说明符有关</strong></li><li>派生访问说明符的<strong>目的是控制派生类的用户（包括派生类的派生类在内）对于基类成员的访问权限</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Pub_Derv d1;        <span class="hljs-comment">// 继承自 Base 的成员是 public 的</span><br>Priv_Derv d2;       <span class="hljs-comment">// 继承自 Base 的成员是 private 的</span><br>d<span class="hljs-number">1.</span><span class="hljs-built_in">pub_mem</span>();        <span class="hljs-comment">// 正确， pub_mem 在派生类中是 public 的</span><br>d<span class="hljs-number">2.</span><span class="hljs-built_in">pub_mem</span>();       <span class="hljs-comment">//  错误， pub_mem 在派生类中是 private 的</span><br></code></pre></td></tr></table></figure><ul><li>派生访问说明符还可以控制继承自派生类的新类的访问权限</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived_from_Private</span> : <span class="hljs-keyword">public</span> Priv_Derv &#123;<br>    <span class="hljs-comment">// 错误，Base::prot_mem() 在 Priv_Derv 中是 private 的</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">use_base</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">prot_mem</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>派生类如果是 <strong>protected 继承</strong>，<strong>基类的所有 public 成员和 protected 成员在后续所有新定义的派生类中都是 protected</strong> ; 派生类的<strong>用户不能访问</strong>基类的 public 成员和 protected 成员， 但它的成员和友元可以访问。</li></ul><h2 id="派生类向基类转换的可访问性"><a href="#派生类向基类转换的可访问性" class="headerlink" title="派生类向基类转换的可访问性"></a>派生类向基类转换的可访问性</h2><ul><li>派生类向基类转换的可访问性由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响：</li><li>假定 D 继承自 B：<ul><li><strong>只有当 D public 继承 B 时，用户代码才可以使用派生类向基类的转换</strong>。如果是 private 继承或 protected 继承，则用户代码不能使用该转换</li><li><strong>无论 D 以什么方式继承 B，D 的成员和友元都可以使用派生类向基类的转换</strong>；派生类向其直接基类的转换对于派生类的成员和友元来说是永远可访问的</li><li><strong>如果 D 以 public 或 protected 方式继承 B，则 D 的派生类可以使用 D 向 B 的转换。</strong> 反之，如果 D 是以 private 方式继承 B ，则 D 的派生类不能使用该转换</li></ul></li></ul><h2 id="友元与继承"><a href="#友元与继承" class="headerlink" title="友元与继承"></a>友元与继承</h2><ul><li><strong>友元关系不能传递，同样也不能继承</strong></li></ul><h2 id="改变个别成员的可访问性"><a href="#改变个别成员的可访问性" class="headerlink" title="改变个别成员的可访问性"></a>改变个别成员的可访问性</h2><ul><li>通过 using 声明可以改变派生类继承的某个名字的访问级别</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> n;&#125;<br><span class="hljs-keyword">protected</span>:<br>    std::<span class="hljs-type">size_t</span> n;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">private</span> Base &#123;      <span class="hljs-comment">// 这里是 private 继承</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::size;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">using</span> Base::n;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Derived 使用了 private 继承，默认情况下，size 和 n 是 Derived 的私有成员</li><li>使用 using 声明之后，Derived 的用户可以使用 size, 而 Derived 的派生类可以使用 n</li><li>如果一条 <strong>using 语句出现在 public 部分</strong>，则该名字<strong>可以被类的所有用户使用</strong></li><li>如果 <strong>using 语句出现在 private 部分</strong>，则改名字<strong>只能被类的成员和友元使用</strong></li><li>如果 <strong>using 语句出现在 protected 部分</strong>，则该名字<strong>对于成员、友元和派生类是可访问的</strong></li><li><strong>注意：派生类只能为它可以访问的名字提供 using 声明</strong></li></ul><h2 id="默认的继承保护级别"><a href="#默认的继承保护级别" class="headerlink" title="默认的继承保护级别"></a>默认的继承保护级别</h2><ul><li>默认情况下，使用 <strong><code>class</code> 关键字</strong>定义的派生类是 <strong>private 继承</strong>；</li><li>使用 <strong><code>struct</code> 关键字</strong>定义的派生类是 <strong>public 继承</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> public 继承 </tag>
            
            <tag> protected 继承 </tag>
            
            <tag> private 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.4 抽象基类</title>
      <link href="/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.4%20%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/"/>
      <url>/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.4%20%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><ul><li>假设需要扩展书店程序，令其支持多种不同的折扣政策，每个策略都需要一个购买量的值和一个折扣值。<strong>新定义一个 Disc_quote 类来支持不同的折扣政策，负责保存购买量的值和折扣值</strong></li><li>其他表示某种特定策略的类分别继承自 Disc_quote，每个派生类定义自己的 net_price 函数来实现各自的折扣政策</li><li><strong>Disc_quote 类</strong>与任何特定的折扣政策都无关，<strong>它的 net_price 函数无实际意义，在用户使用的过程中，不需要创建 Disc_quote 对象</strong></li><li>可以将 net_price 函数定义为<strong>纯虚函数(pure virtual)</strong>，清晰的告知用户当前这个 net_price 函数无实际意义</li><li>一个<strong>纯虚函数无需定义</strong>，通常<strong>使用 <code>=0</code> 代替函数体</strong>，说明它是纯虚函数，其中 <strong><code>=0</code> 只能出现在类内部的虚函数声明处</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Disc_quote</span> : <span class="hljs-keyword">public</span> Quote&#123;<br>    <span class="hljs-built_in">Disc_quote</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Disc_quote</span>(<span class="hljs-type">const</span> std::string &amp; book, <span class="hljs-type">double</span> price, std::<span class="hljs-type">size_t</span> qty, <span class="hljs-type">double</span> disc) :<br>            <span class="hljs-built_in">Quote</span>(book, price), <span class="hljs-built_in">quantity</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> )</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>    std::<span class="hljs-type">size_t</span> quantity = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 折扣适用的购买量</span><br>    <span class="hljs-type">double</span> discount = <span class="hljs-number">0.0</span>;      <span class="hljs-comment">// 表示折扣的小数值</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>尽管不能直接定义 Disc_quote 对象，但是可以使用它的构造函数来创建各个派生类中的 Disc_quote 部分</li><li><strong>注意：也可以为纯虚函数提供定义，但是函数体必须定义在类的外部，在类内部不能为一个 <code>=0</code> 的函数提供函数体</strong></li></ul><h2 id="含有纯虚函数的类是抽象基类"><a href="#含有纯虚函数的类是抽象基类" class="headerlink" title="含有纯虚函数的类是抽象基类"></a>含有纯虚函数的类是抽象基类</h2><ul><li><strong>含有(或者未经覆盖直接继承)纯虚函数的类是抽象基类(abstract base class)</strong></li><li><strong>抽象基类负责定义接口</strong>，而后续其他类可以覆盖该接口</li><li><strong>不能直接创建一个抽象基类的对象</strong></li></ul><h2 id="派生类构造函数只初始化它的直接基类"><a href="#派生类构造函数只初始化它的直接基类" class="headerlink" title="派生类构造函数只初始化它的直接基类"></a>派生类构造函数只初始化它的直接基类</h2><ul><li>重新实现 Bulk_quote 类，令它继承 Disc_quote</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span> : <span class="hljs-keyword">public</span> Disc_quote&#123;        <span class="hljs-comment">// Bulk_quote 继承自 Quote</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-type">const</span> std::string &amp;, <span class="hljs-type">double</span> , std::<span class="hljs-type">size_t</span> , <span class="hljs-type">double</span> );<br>    <span class="hljs-comment">// 覆盖基类的函数版本以实现基于大量购买的折扣政策</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> cnt)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Bulk_quote 的直接基类是 Disc_quote，间接基类是 Quote</li><li>每个 Bulk_quote 对象包含三个子对象：<ul><li>一个空的 Bulk_quote 部分</li><li>一个 Disc_quote 子对象</li><li>一个 Quote 子对象</li></ul></li><li><strong>每个类各自控制其对象的初始化过程</strong>：因此，即使 Bulk_quote 类没有数据成员，它的构造函数也需要四个参数，并将它们传递给 Disc_quote 的构造函数, Disc_quote 构造函数继续调用 Quote 的构造函数，从而初始化Bulk_quote 中的 Disc_quote 子对象和 Quote 子对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 抽象基类 </tag>
            
            <tag> 纯虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.2 定义基类和派生类</title>
      <link href="/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.2%20%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB/"/>
      <url>/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.2%20%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>定义一个 Qutoe 类，作为基类。Quote 类表示原价销售的书籍</li><li>Quote 类派生出一个名为 Bulk_quote 的类，表示可以打折销售的书籍</li><li>这些类包含两个成员函数<ul><li>isbn(), 返回书籍的 ISBN 编号。该操作不涉及派生类的特殊性，因此只定义在基类中</li><li>net_price(size_t) ，返回书籍的实际销售价格，前提是用户购买该书的数量达到一定标准。这个操作类型相关，Quote 类和 Bulk_quote 类都应包含该函数</li></ul></li></ul><h2 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Quote</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Quote</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-built_in">Quote</span>(<span class="hljs-type">const</span> std::string &amp; book, <span class="hljs-type">double</span> sale_price) :<br>            <span class="hljs-built_in">bookNo</span>(book), <span class="hljs-built_in">price</span>(sale_price) &#123; &#125;<br><br>    <span class="hljs-comment">// 返回给定数量的书籍的销售总额</span><br>    <span class="hljs-comment">// 派生类负责改写并使用不同的折扣计算算法</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n * price;<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Quote</span>() = <span class="hljs-keyword">default</span>;     <span class="hljs-comment">// 对析构函数进行动态绑定</span><br><br><span class="hljs-keyword">private</span>:<br>    std::string bookNo;         <span class="hljs-comment">// 书籍的 ISBN 编号</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">double</span> price = <span class="hljs-number">0.0</span>;         <span class="hljs-comment">// 代表普通状态下不打折的价格</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>基类通常定义一个<strong>虚析构函数</strong>，即使该函数不执行任何操作</li></ul><h3 id="成员函数与继承"><a href="#成员函数与继承" class="headerlink" title="成员函数与继承"></a>成员函数与继承</h3><ul><li>基类必须将它的两种成员函数区分开：<ul><li>一类是基类希望派生类进行 <strong>覆盖(override)</strong> 基类中旧定义的函数，基类通常将其定义为虚函数(virtual function)</li><li>一类是基类希望派生类直接继承而不要改变的函数</li></ul></li><li><strong>使用引用或指针调用虚函数时，该调用被动态绑定</strong>。<strong>根据引用或指针所绑定的对象的类型不同，该调用选取基类版本执行或者派生类版本执行</strong></li><li>任何<strong>构造函数之外的非静态函数</strong>都可以是虚函数</li><li><strong>关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义</strong></li><li><strong>基类将一个函数声明为虚函数，则该函数在派生类中隐式的也是虚函数</strong></li><li>如果函数<strong>没有被声明为虚函数，则其解析过程发生在编译时而不是运行时</strong></li></ul><h3 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h3><ul><li><strong>派生类可以继承定义基类的成员，但是派生类的成员函数不一定有权限访问从基类继承来的成员</strong><ul><li>派生类<strong>可以访问基类的 public 成员</strong>，<strong>不能访问 private 成员</strong></li><li>还有一种成员，基类希望派生类有权访问而禁止其他用户访问，使用<strong>受保护的 (protected) 访问运算符</strong>声明这样的成员</li></ul></li></ul><h2 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h2><ul><li>派生类必须通过 <strong>派生类列表(class derivation list)</strong> 明确指出继承自哪个(哪些)基类<ul><li>形式是冒号后根以逗号分隔的基类列表</li><li>每个基类前可以有三种访问运算符的其中一种：<strong>public, private, protected</strong></li></ul></li><li>派生类必须将从基类继承的成员函数中的<strong>虚函数重新声明</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span> : <span class="hljs-keyword">public</span> Quote&#123;        <span class="hljs-comment">// Bulk_quote 继承自 Quote</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-type">const</span> std::string &amp;, <span class="hljs-type">double</span> , std::<span class="hljs-type">size_t</span> , <span class="hljs-type">double</span> );<br>    <span class="hljs-comment">// 覆盖基类的函数版本以实现基于大量购买的折扣政策</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> n)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::<span class="hljs-type">size_t</span> min_qty = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 适用折扣政策的最低限购量</span><br>    <span class="hljs-type">double</span> discount = <span class="hljs-number">0.0</span>;          <span class="hljs-comment">// 用小数表示的折扣额</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>访问说明符的作用是<strong>控制派生类从基类继承来的成员是否对派生类的用户可见</strong><ul><li>如果一个<strong>派生是 public 的</strong>，则<strong>基类的公有成员也是派生类接口的组成部分</strong></li><li><strong>可以将 public 派生类型的对象绑定到其基类的引用或指针</strong></li></ul></li><li>大多数类只继承自一个基类，这种形式的继承称为<strong>单继承</strong></li></ul><h3 id="派生类中的虚函数"><a href="#派生类中的虚函数" class="headerlink" title="派生类中的虚函数"></a>派生类中的虚函数</h3><ul><li>派生类经常（但不总是）覆盖它所继承的虚函数</li><li><strong>如果派生类中没有覆盖虚函数，则派生类会直接继承其在基类中的版本</strong></li><li>新标准中允许派生类显式的注明它使用了某个成员函数覆盖了继承的虚函数：<ul><li>在<strong>形参列表后</strong>或 <strong>const 成员函数的 const 关键字之后</strong>或者<strong>引用成员函数的引用限定符之后</strong>加上 <strong><code>override</code></strong></li></ul></li></ul><h3 id="派生类对象及派生类向基类的类型转换"><a href="#派生类对象及派生类向基类的类型转换" class="headerlink" title="派生类对象及派生类向基类的类型转换"></a>派生类对象及派生类向基类的类型转换</h3><ul><li>一个派生类对象包含多个组成部分：<ul><li>一个含有派生类自己定义的非静态成员的子对象</li><li>一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个</li></ul></li></ul><pre class="mermaid">classDiagramdirection LR    class Bulk_quote {        +string bookNo        +double price        +size_t min_qty        +double discount    }    note for Bulk_quote "bookNo, price: inherit from Quote"    note for Bulk_quote "min_qty, discount: custom"</pre><ul><li>在一个派生类对象中，<strong>继承自基类的部分与派生类自定义的部分不一定是连续存储的</strong></li><li><p>因为在派生类中含有与其基类对应的部分</p><ul><li>所以<strong>可以将派生类的对象当成基类对象来使用</strong></li><li><p>也能<strong>将基类的指针或引用绑定到派生类对象中的基类部分上</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Quote item;         <span class="hljs-comment">// 基类对象</span><br>Bulk_quote bulk;    <span class="hljs-comment">// 派生类对象</span><br>Quote *p = &amp;item;   <span class="hljs-comment">// p 指向 Quote 对象</span><br>p = bulk;           <span class="hljs-comment">// p 指向 bulk 的 Quote 部分</span><br>Quote &amp; r = bulk;   <span class="hljs-comment">// r 绑定到 bulk 的 Quote 部分</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>这种转换通常称为<strong>派生类到基类(derived-to-base)</strong> 的类型转换，<strong>编译器会隐式的执行派生类到基类的转换</strong></p><ul><li>可以将派生类对象的引用用在需要基类引用的地方</li><li>也可以将派生类对象的指针用在需要基类指针的地方</li></ul></li><li><strong>派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键</strong></li></ul><h3 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h3><ul><li><strong>每个类控制自己的成员初始化过程</strong><ul><li>尽管派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员，<strong>派生类必须使用基类的构造函数来初始化它的基类部分</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Bulk_quote::<span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-type">const</span> std::string &amp;book, <span class="hljs-type">double</span> p, std::<span class="hljs-type">size_t</span> qty, <span class="hljs-type">double</span> disc) :<br>                <span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">min_qty</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123; &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化</strong></li><li>如果想使用基类的其他构造函数，需要以类名加圆括号内的实参列表形式为构造函数提供初始值</li><li><strong>首先初始化基类部分，然后按声明的顺序依次初始化派生类的数据成员</strong></li></ul><h3 id="派生类使用基类的成员"><a href="#派生类使用基类的成员" class="headerlink" title="派生类使用基类的成员"></a>派生类使用基类的成员</h3><ul><li><strong>派生类可以访问基类的 public 成员和 protected 成员</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 如果达到购买书籍的某个最低限量值，就可以使用折扣</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Bulk_quote::net_price</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> cnt)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt &gt;= min_qty)<br>        <span class="hljs-keyword">return</span> cnt * (<span class="hljs-number">1</span> - discount) * price;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> cnt * price;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>派生类的作用域嵌套在基类的作用域之内</strong>。因此，对于派生类的一个成员来说，它使用派生类成员和基类成员的方式没区别</li></ul><h3 id="遵循基类的接口"><a href="#遵循基类的接口" class="headerlink" title="遵循基类的接口"></a>遵循基类的接口</h3><ul><li>必须明确：<strong>每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类对象的基类部分</strong><ul><li><strong>派生类对象不能直接初始化基类的成员</strong>。派生类应该遵循基类的接口，并且<strong>通过调用基类的构造函数来初始化从基类继承过来的成员</strong></li></ul></li></ul><h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><ul><li><strong>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义</strong>。不论从基类派生出多少派生类，对于静态成员来说都只存在唯一实例</li><li>静态成员遵循通用的访问控制规则：<ul><li>如果<strong>基类中的静态成员是 private，则派生类无法访问</strong>。</li><li>如果<strong>静态成员是可访问的，则既可以通过基类访问，也可以通过派生类访问</strong></li></ul></li></ul><h3 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h3><ul><li>与其他类相同，<strong>声明中包含类名但是不包含它的派生列表</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span> : <span class="hljs-keyword">public</span> Quote;        <span class="hljs-comment">// 错误</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bulk_quote</span>;                       <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><h3 id="被用作基类的类"><a href="#被用作基类的类" class="headerlink" title="被用作基类的类"></a>被用作基类的类</h3><ul><li><strong>如果想将某个类作为基类，该类必须已经被定义而不仅仅只是声明</strong><ul><li>原因是派生类中包含并且可以使用它从基类继承而来的成员</li><li>该规定还有一层意思：<strong>一个类不能派生它本身</strong></li></ul></li><li>一个类是基类，同时也可以是派生类</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D1</span> : <span class="hljs-keyword">public</span> Base &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D2</span> : <span class="hljs-keyword">public</span> D1 &#123; ... &#125;;<br></code></pre></td></tr></table></figure><ul><li>在这个继承关系中，Base 是 D1 的<strong>直接基类(direct base)</strong> ，是 D2 的<strong>间接基类(indirect base)</strong></li><li><strong>每个类都会继承直接基类的所有成员</strong>。对于一个<strong>最终的派生类，它将包含它的直接基类的子对象以及每个间接基类的子对象</strong></li></ul><h3 id="防止继承的发生"><a href="#防止继承的发生" class="headerlink" title="防止继承的发生"></a>防止继承的发生</h3><ul><li>对于一个<strong>不希望其他类继承</strong>或者<strong>不考虑作为其他类的基类</strong>的类，在<strong>类名后跟关键字 final</strong> ，防止继承的发生</li></ul><h2 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h2><ul><li><strong><em>理解基类和派生类之间的类型转换是理解 C++ 面向对象编程的关键</em></strong></li><li>通常情况下，要把指针或引用绑定到一个对象上，需要指针或引用的类型与所绑对象类型一致，或者对象的类型含有一个可接受的 const 类型转换规则</li><li><strong>存在继承关系的类是个重要例外：可以将基类的指针或引用绑定到派生类对象上</strong><ul><li>这意味着：  <strong>当使用基类的指针或引用时，实际上不清楚该指针或引用所绑对象的真实类型</strong>。该对象可能是基类对象，也可能是派生类对象</li></ul></li><li>智能指针也支持派生类向基类的类型转换，可以将一个派生类对象存储到一个基类的智能指针中</li></ul><h3 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h3><ul><li>当使用存在继承关系的类型时，<strong>必须将一个变量或表达式的静态类型(static type)与该表达式表示对象的动态类型(dynamic type)区分开：</strong><ul><li><strong>表达式的静态类型在编译时总是已知的</strong>，它是变量声明时的类型或表达式生成的类型；</li><li>动态类型则是变量或表达式表示的内存中的对象的类型，<strong>动态类型直到运行时才可知</strong></li></ul></li><li>例如在 print_total 中调用 net_price 时：<code>double ret = item.net_price(n);</code><ul><li><strong>item 的静态类型是 Quote &amp;，它的动态类型依赖于 item 绑定的实参，动态类型直到在运行时调用该函数才会知道</strong></li></ul></li><li>如果<strong>表达式不是指针也不是引用，则它的动态类型和静态类型一致</strong></li></ul><h3 id="不存在从基类向派生类的隐式类型转换"><a href="#不存在从基类向派生类的隐式类型转换" class="headerlink" title="不存在从基类向派生类的隐式类型转换"></a>不存在从基类向派生类的隐式类型转换</h3><ul><li>之所以存在<strong>派生类向基类的类型转换</strong>，是因为<strong>每个派生类对象都包含一个基类部分，而基类的指针或引用可以绑定该基类部分</strong></li><li>一个<strong>基类对象既可以独立存在</strong>，<strong>也可以作为派生类对象的一部分存在</strong>，<strong>所以不存在从基类向派生类的类型转换</strong></li><li><p>还有一个特别情况，即使一个基类指针或引用绑定到派生类对象，也不能执行从基类向派生类的转换</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Bulk_quote bulk;<br>Quote * itemP = &amp;bulk;      <span class="hljs-comment">// 基类指针绑定到派生类，动态类型是 Bulk_quote</span><br>Bulk_quote * bulkP = itemP; <span class="hljs-comment">// 错误：不能将基类转换为派生类</span><br></code></pre></td></tr></table></figure></li><li><p><strong>编译器只能通过检查引用或指针的静态类型来推断该转换是否合法，无法确定某个特定的转换在运行时是否安全</strong></p></li><li>如果基类中含有一个或多个虚函数，可以<strong>使用 <code>dynamic_cast</code> 请求一个类型转换, 该转换的安全检查在运行时执行</strong></li><li>如果<strong>已知某个基类向派生类的转换是安全的，则可以使用 <code>static_cast</code> 来强制覆盖掉编译器的检查工作</strong></li></ul><h3 id="在对象之间不存在类型转换"><a href="#在对象之间不存在类型转换" class="headerlink" title="在对象之间不存在类型转换"></a>在对象之间不存在类型转换</h3><ul><li>派生类到基类的<strong>自动类型转换只存在于指针或引用</strong>，在派生类类型对象与基类类型对象之间不存在这样的转换</li><li>当<strong>初始化或赋值一个基类对象</strong>时，实际调用的是某个函数，<strong>这些成员函数接受引用作为参数，所以派生类向基类的转换允许给某个基类的拷贝/赋值操作传递一个派生类的对象</strong>，这些操作不是虚函数，当给基类的构造函数传递一个派生类对象时，实际运行的是基类的构造函数，基类的构造函数只能处理基类自己的成员</li><li><strong>当用一个派生类对象为一个基类对象初始化或赋值时，只有派生类对象中基类的部分被拷贝、移动、赋值，它的派生类部分将被忽略掉</strong></li></ul><h3 id="存在继承关系的类型之间的转换规则"><a href="#存在继承关系的类型之间的转换规则" class="headerlink" title="存在继承关系的类型之间的转换规则"></a>存在继承关系的类型之间的转换规则</h3><ul><li><strong>从派生类向基类的类型转换只对指针或引用有效</strong></li><li><strong>基类向派生类不存在隐式类型转换</strong></li><li>和其他成员一样，<strong>派生类向基类的类型转换也可能由于访问权限的限制而变得不可行</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 基类 </tag>
            
            <tag> 派生类 </tag>
            
            <tag> 派生类向基类的类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.6 继承中的类作用域</title>
      <link href="/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.6%20%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2025/04/28/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.6%20%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>每个类定义自己的作用域，在作用域内定义自己的成员</li><li>当类之间有继承关系时，<strong>派生类的作用域嵌套在其基类的作用域之内</strong>，如果一个名字在派生类的作用域内无法正确解析，编译器将会继续在其基类的作用域内寻找该名字的定义</li></ul><h2 id="在编译时进行名字查找"><a href="#在编译时进行名字查找" class="headerlink" title="在编译时进行名字查找"></a>在编译时进行名字查找</h2><ul><li>一个对象、引用、指针的<strong>静态类型决定了该对象的哪些成员是可见的</strong></li><li>即使静态类型和动态类型可能不一致(当使用基类的指针或引用时会发生这种情况), 但是能用户代码能<strong>使用哪些成员仍是由静态类型决定的</strong></li><li>名字的查找先从静态类型所定义的作用域开始，如果找不到，就到其所嵌套的上层作用域中寻找</li></ul><h2 id="名字冲突与继承"><a href="#名字冲突与继承" class="headerlink" title="名字冲突与继承"></a>名字冲突与继承</h2><ul><li><strong>派生类的成员将隐藏基类的同名成员</strong></li></ul><h2 id="通过作用域运算符来使用隐藏的成员"><a href="#通过作用域运算符来使用隐藏的成员" class="headerlink" title="通过作用域运算符来使用隐藏的成员"></a>通过作用域运算符来使用隐藏的成员</h2><ul><li>使用作用域运算符 <code>::</code> 可以使用被隐藏的成员</li><li>但是除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</li></ul><h2 id="名字查找与继承"><a href="#名字查找与继承" class="headerlink" title="名字查找与继承"></a>名字查找与继承</h2><ul><li>函数调用解析过程：假定调用 <code>p-&gt;mem()</code> (或者 <code>p.mem()</code> ), 则依次执行以下四个步骤：<ul><li><strong>首先确定 p 的静态类型。</strong> 因为调用的是一个成员，所以 p 的类型必然是一个类类型</li><li><strong>在 p 的静态类型对应的类中查找 mem</strong>。如果找不到，则依次在其直接基类中不断查找，直至继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错</li><li><strong>一旦找到 mem，就进行常规的类型检查，以确认对于当前找到的 mem ，本次调用是否合法</strong></li><li><strong>假设调用合法，编译器将根据调用的是否是虚函数而产生不同的代码</strong>：<ul><li>假设 mem 是虚函数且通过引用或指针调用的它，则编译器产生的代码将在运行时确定到底执行该虚函数的哪个版本，依据是对象的动态类型</li><li>反之如果 mem 不是虚函数或者是通过对象(而非引用或指针)进行的调用，则编译器将产生一个常规函数调用</li></ul></li></ul></li></ul><h2 id="名字查找先于类型检查"><a href="#名字查找先于类型检查" class="headerlink" title="名字查找先于类型检查"></a>名字查找先于类型检查</h2><ul><li><strong>声明在内层作用域中的函数并不会重载声明在外层作用域中的函数</strong>（重名的函数）</li><li>如果派生类中的某个成员与基类中的某个成员重名，则派生类在其作用域内会隐藏该基类的成员，<strong>即使派生类成员的参数列表与基类成员的参数列表不一致，基类成员也会被隐藏</strong></li></ul><h2 id="虚函数与作用域"><a href="#虚函数与作用域" class="headerlink" title="虚函数与作用域"></a>虚函数与作用域</h2><ul><li>为什么基类与派生类的虚函数必须有形同的参数列表：<ul><li><strong>假如基类与派生类虚函数接受的实参不同，就无法通过基类的引用或指针调用派生类的虚函数了</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> fcn<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D1</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 隐藏基类的 fcn , 这里的 fcn 不是虚函数</span><br><span class="hljs-comment">// D1 成绩继承了 Base::fcn() 的定义</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;   <span class="hljs-comment">// 形参列表与 Base 中的 fcn() 不一致</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 这是一个新的虚函数，在 Base 中并不存在</span><br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D2</span> : <span class="hljs-keyword">public</span> D1 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;   <span class="hljs-comment">// 是一个非虚函数，隐藏了 D1::fcn(int)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 覆盖了 Base 中的虚函数 fcn()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 覆盖了 D1 中的虚函数 f2()</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="通过基类调用隐藏的虚函数"><a href="#通过基类调用隐藏的虚函数" class="headerlink" title="通过基类调用隐藏的虚函数"></a>通过基类调用隐藏的虚函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Base bobj;  D1 d1obj; D2 d2obj;<br><br>Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;<br><br>bp1-&gt;<span class="hljs-built_in">fcn</span>(); <span class="hljs-comment">// 虚调用，在运行时调用 Base::fcn()</span><br>bp2-&gt;<span class="hljs-built_in">fcn</span>(); <span class="hljs-comment">// 虚调用，在运行时调用 Base::fcn()</span><br>bp3-&gt;<span class="hljs-built_in">fcn</span>(); <span class="hljs-comment">// 虚调用，在运行时调用 D2::fcn()   </span><br><br>D1 *d1p = &amp;d1obj;   D2 *d2p = &amp;d2obj;<br><br>bp2-&gt;<span class="hljs-built_in">f2</span>();      <span class="hljs-comment">// 错误，Base 中没有 f2() 成员</span><br>d1p-&gt;<span class="hljs-built_in">f2</span>();      <span class="hljs-comment">// 虚调用，在运行时调用 D1::f2()</span><br>d2p-&gt;<span class="hljs-built_in">f2</span>();      <span class="hljs-comment">// 虚调用，在运行时调用 D2::f2()</span><br><br>Base *p1 = &amp;b1obj;  D1 *p2 = &amp;d2obj;    D2 *p3 = &amp;d2obj;<br><br>p1-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);    <span class="hljs-comment">// 错误，Base 中没有接受 int 的 fcn</span><br>p2-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);    <span class="hljs-comment">// 静态绑定，调用 D1::fcn(int)</span><br>p3-&gt;<span class="hljs-built_in">fcn</span>(<span class="hljs-number">42</span>);    <span class="hljs-comment">// 静态绑定，调用 D2::fcn(int)</span><br></code></pre></td></tr></table></figure><h2 id="覆盖重载的函数"><a href="#覆盖重载的函数" class="headerlink" title="覆盖重载的函数"></a>覆盖重载的函数</h2><ul><li><strong>成员函数无论是否是虚函数都可以被重载，派生类可以覆盖重载函数的 0 个或多个实例</strong></li><li><strong>如果派生类希望所有的重载版本对于它来说都是可见的，那么它需要覆盖所有版本，或者一个也不覆盖</strong></li><li><strong>为重载成员提供一条 <code>using</code> 语句，可以避免覆盖基类中的每个重载版本</strong>了。using 声明语句指定一个名字而不指定参数列表，所以一条基类成员函数的 using 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数即可，而无需为其他继承而来的函数重新定义</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 继承中的作用域 </tag>
            
            <tag> 名字查找 </tag>
            
            <tag> 虚函数与作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.1 OPP 概述</title>
      <link href="/2025/04/27/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.1%20OPP%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/04/27/15.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/15.1%20OPP%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="面向对象程序设计-object-oriented-programming"><a href="#面向对象程序设计-object-oriented-programming" class="headerlink" title="面向对象程序设计(object-oriented programming)"></a>面向对象程序设计(object-oriented programming)</h3><ul><li>核心思想是<strong>数据抽象、继承、动态绑定</strong><ul><li>数据抽象：将类的接口与实现分离</li><li>继承：可以定义相似的类型并对相似关系建模</li><li>动态绑定：可以在一定程度上忽略相似类的区别，而以统一的方式使用功它们的对象</li></ul></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>通过<strong>继承(inheritance)</strong> 联系在一起的类之间构成一种层次关系：<ul><li>在层次关系的根部有一个<strong>基类(basic class)</strong>，其他类通过直接或间接的从基类继承得来，统称为<strong>派生类(derived class)</strong></li><li><strong>基类负责定义在层次关系中所有类共同拥有的成员</strong></li><li><strong>派生类负责定义各自特有的成员</strong></li></ul></li><li><strong>虚函数</strong>：某些函数，基类希望派生类定义自己的版本，<strong>基类就会将它们声明为虚函数 (virtual function)</strong></li><li><strong>派生类列表</strong>：派生类必须通过 <strong>派生类列表(class derivaiton list)</strong> 明确指出它是继承自哪个基类<ul><li><strong>派生类必须在其内部对所有重新定义的虚函数进行声明</strong>，在虚函数前加上 <code>virtual</code> 关键字，但不是必须</li><li>新标准允许派生类显式的注明它将使用哪个成员函数改写基类的虚函数，需要在<strong>该函数的形参列表之后加上 <code>override</code> 关键字</strong></li></ul></li></ul><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><ul><li>通过<strong>动态绑定(dynamic binding), 能用同一段代码处理基类和派生类的对象</strong></li><li>动态绑定又称为<strong>运行时绑定(run-time binding)</strong></li><li><strong>在 C++ 中，当使用基类的引用或指针调用一个虚函数时将发生动态绑定</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> OPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.9 重载、类型转换与运算符</title>
      <link href="/2025/04/25/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.9%20%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/04/25/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.9%20%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>通过定义类型转换运算符，可以定义类类型的转换</li><li><strong>转换构造函数</strong>(只接受一个参数的构造函数) 和<strong>类型转换运算符</strong>共同定义了<strong>类类型转换(class-type conversions)</strong>, 也称为<strong>用户定义的类型转换(user-defined conversions)</strong></li></ul><h2 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h2><ul><li><strong>类型转换运算符(conversion operator) 是类的一种特殊成员函数，负责将一个类的类型值转换为其他类型</strong></li><li>一般形式：<code>operator type() const</code><ul><li><code>type</code> 表示某种类型</li></ul></li><li>类型转换运算符可以面向任何类型(void 除外), 只要<strong>该类型可以作为返回类型</strong><ul><li><strong>不允许转换成数组或函数类型</strong></li><li>但<strong>允许转换成指针(包括数组指针和函数指针) 或者引用类型</strong></li></ul></li><li>一个<strong>类型转换运算符<em>必须是类的成员函数</em></strong><ul><li><strong><em>不能声明返回类型</em></strong></li><li><strong><em>形参列表必须为空</em></strong></li><li><strong><em>通常也应该是 const</em></strong></li></ul></li></ul><h3 id="定义含有类型转换运算符的类"><a href="#定义含有类型转换运算符的类" class="headerlink" title="定义含有类型转换运算符的类"></a>定义含有类型转换运算符的类</h3><ul><li><p>例子：一个表示 0~255 之间的一个整数的类</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmallInt</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SmallInt</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>) : <span class="hljs-built_in">val</span>(i) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">255</span>)<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Bad SmallInt value&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::<span class="hljs-type">size_t</span> val;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>这个类中既定义了其他类型向类类型的转换，也定义了类类型向其他类型的转换</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SmallInt si;<br>si = <span class="hljs-number">4</span>;     <span class="hljs-comment">// 首先将 4 隐式的转换为 SmallInt，然后调用 SmallInt::operator=</span><br>si + <span class="hljs-number">3</span>;     <span class="hljs-comment">// 首先将 si 隐式的转换为 int ，然后执行整数的加法运算</span><br></code></pre></td></tr></table></figure></li><li><p><strong>编译器一次只能执行一个用户定义的类型转换</strong></p></li><li><p>但，<strong>隐式的用户定义类型转换可以置于一个标准(内置)类型转换之前或者之后</strong>，两者可以一起使用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 内置类型转换将 double 实参转换为 int</span><br>SmallInt si = <span class="hljs-number">3.14</span>;     <span class="hljs-comment">// 调用 SmallInt(int) 构造函数</span><br><span class="hljs-comment">// SmallInt 的类型转换运算符将 si 转换为 int</span><br>si + <span class="hljs-number">3.14</span>;      <span class="hljs-comment">// 内置类型转换将所得的 int 继续转换为 double</span><br></code></pre></td></tr></table></figure></li><li><p>如果在<strong>类类型与转换类型之间不存在明显的映射关系</strong>，就不应该定义类型转换运算符，因为这样的转换可能具有误导性</p></li></ul><h3 id="类型转换运算符可能产生意外结果"><a href="#类型转换运算符可能产生意外结果" class="headerlink" title="类型转换运算符可能产生意外结果"></a>类型转换运算符可能产生意外结果</h3><ul><li>在实践中一般很少提供类型转换运算符，但有例外，定义向 bool 类型的类型转换比较普遍</li><li>对象可以被隐式的转换为 bool 可能会导致一些无法预测的错误产生，而编译器不能检测出这些错误</li></ul><h3 id="显式的类型转换运算符-explicit-conversion-operator"><a href="#显式的类型转换运算符-explicit-conversion-operator" class="headerlink" title="显式的类型转换运算符(explicit conversion operator)"></a>显式的类型转换运算符(explicit conversion operator)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 编译器不会自动执行这一类型转换</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SmallInt si = <span class="hljs-number">3</span>;    <span class="hljs-comment">// 正确，SmallInt 的构造函数不是显式的</span><br>si + <span class="hljs-number">4</span>;     <span class="hljs-comment">// 错误，此处需要隐式转换，但类的运算符是显式的</span><br><span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt; (si) + <span class="hljs-number">3</span>;      <span class="hljs-comment">// 正确，显式的请求类型转换</span><br></code></pre></td></tr></table></figure><ul><li><strong>当类型转换运算符被定义为 explicit 的，必须显式的使用强制类型转换</strong></li><li>有一种例外：<strong>如果表达式被用作条件，编译器会自动应用显示的类型转换</strong></li><li>当表达式出现在下面位置，显式的类型转换将被隐式的执行：<ul><li>if, while, do 的条件部分</li><li>for 语句的条件部分</li><li>逻辑非(<code>!</code>)、逻辑或(<code>||</code>)、逻辑与(<code>&amp;&amp;</code>)运算符的运算对象</li><li>条件运算符( <code>? :</code>) 的条件表达式</li></ul></li></ul><h3 id="转换为-bool"><a href="#转换为-bool" class="headerlink" title="转换为 bool"></a>转换为 bool</h3><ul><li>新标准中，IO 标准库定义了向 bool 的显示类型转换</li><li><p>当在条件中使用流对象时，都会使用 IO 类型定义的 <code>operator bool</code></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(std::cin &gt;&gt; value)<br></code></pre></td></tr></table></figure></li></ul><h2 id="避免有二义性的类型转换"><a href="#避免有二义性的类型转换" class="headerlink" title="避免有二义性的类型转换"></a>避免有二义性的类型转换</h2><ul><li>如果一个类中包含一个或多个类型转换，则<strong>必须确保在类类型和目标类型之间只存在唯一的转换方式</strong></li><li>两种情况下可能产生多重转换路径：<ol><li><strong>两个类提供相同的类型转换</strong>：例如当 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符</li><li><strong>类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系到一起</strong></li></ol></li><li>通常情况下，不要为类定义相同的类型转换</li><li>也不要在类中定义两个及两个以上转换源或转换目标是算数类型的转换，特别是已经定义了一个转换成算数类型的类型转换时：<ul><li>不要再定义接受算数类型的运算符</li><li>不要定义转换到多种算数类型的类型转换</li></ul></li></ul><h3 id="重载函数与转换构造函数"><a href="#重载函数与转换构造函数" class="headerlink" title="重载函数与转换构造函数"></a>重载函数与转换构造函数</h3><ul><li>如果两个或多个类型转换都提供了同一种可行匹配，这些类型的优先级相同</li><li>当几个重载函数的参数分属于不同的类类型，而这些类都恰好定义了同样的转换构造函数，将产生严重的二义性问题</li></ul><h3 id="重载函数与用户定义的类型转换"><a href="#重载函数与用户定义的类型转换" class="headerlink" title="重载函数与用户定义的类型转换"></a>重载函数与用户定义的类型转换</h3><ul><li>重载函数所要求的<strong>用户定义的类型转换(UDC)不止一个且彼此不同，则该调用具有二义性</strong>，在这种情况下，<strong>即使一个重载函数需要额外的类型转换而另一个精确匹配，编译器也不会再向下比较，而是视为有二义性</strong></li></ul><h2 id="函数匹配与重载运算符"><a href="#函数匹配与重载运算符" class="headerlink" title="函数匹配与重载运算符"></a>函数匹配与重载运算符</h2><ul><li>如果我们对一个<strong>类既提供了转换目标是算数类型的类型转换，也提供了重载的运算符</strong>，则<strong>将会遇到重载运算符与内置运算符的二义性问题</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 类型转换运算符 </tag>
            
            <tag> 重载决议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.7 成员访问运算符</title>
      <link href="/2025/04/24/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.7%20%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/04/24/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.7%20%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>箭头运算符必须是类的成员；解引用运算符通常也是类的成员</strong></li><li>strBlobPtr 的成员访问运算符</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::string &amp; strBlobPtr::<span class="hljs-keyword">operator</span>*() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;dereference past end&quot;</span>);<br>    <span class="hljs-keyword">return</span> (*p)[curr];      <span class="hljs-comment">// *p 是 对象所指的 vector</span><br>&#125;<br><br>std::string * strBlobPtr::<span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> &amp; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-keyword">operator</span>*();     <span class="hljs-comment">// 将实际工作委托给解引用运算符</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>由于它们<strong>只获取元素而不会改变对象的状态</strong>，因此定义为 const 成员函数</li></ul><h2 id="对箭头运算符返回值的限定"><a href="#对箭头运算符返回值的限定" class="headerlink" title="对箭头运算符返回值的限定"></a>对箭头运算符返回值的限定</h2><ul><li>箭头运算符永远不能丢掉<strong>访问成员</strong>这一基本含义</li><li><strong>重载箭头运算符时，改变的是它从哪个对象获取成员，而箭头获取成员这一事实永远不变</strong></li><li><p>三种等价的访问成员表达式</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">pointer-&gt;mem;<br>(*pointer).mem;<br>pointer.<span class="hljs-built_in">operator</span>()-&gt;mem;<br></code></pre></td></tr></table></figure></li><li><p>pointer 必须是<strong>指向类对象的指针</strong>或者是一个<strong>重载了 <code>operator-&gt;</code> 的类的对象</strong></p></li><li><code>pointer-&gt;mem</code> 的执行过程：<ol><li>如果 <strong>pointer 是指针</strong>，则<strong>应用内置的箭头运算符</strong>，表达式等价于 <code>(*pointer).mem</code>，首先解引用指针，然后从所得对象中获取指定成员</li><li>如果 <strong>pointer 是定义了 <code>operator-&gt;</code> 的类的一个对象</strong>，则<strong>使用 <code>pointer.operator-&gt;()</code> 来获取 mem</strong>。其中，<strong>如果该结果是个指针</strong>，<strong>则执行第 i 步</strong>; <strong>如果该结果本身含有重载的 <code>operator-&gt;()</code></strong>，<strong>则重复调用当前步骤</strong>。最终这一过程结束时，程序或者返回所需的内容，或者返回一些错误信息</li></ol></li><li><strong>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 解引用运算符 </tag>
            
            <tag> 箭头运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.8 函数调用运算符</title>
      <link href="/2025/04/24/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.8%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/04/24/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.8%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>如果<strong>类重载了函数调用运算符，则可以像使用函数一样使用该类的对象</strong>，这样的类同时也能存储状态，比普通函数更加灵活</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">absInt</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> val &lt; <span class="hljs-number">0</span> ? -val : val;<br>    &#125;<br>&#125;；<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">-42</span>;<br>abdInt absobj;<br><span class="hljs-type">int</span> ui = <span class="hljs-built_in">absobj</span>(i);     <span class="hljs-comment">// 将 i 传递给 abdobj.operator()</span><br></code></pre></td></tr></table></figure><ul><li><strong>函数调用运算符必须是成员函数</strong>，一个类可以定义多个不同版本的函数调用运算符，相互之间<strong>在参数数量或类型上进行区别</strong></li><li>如果类定义了函数调用运算符，则<strong>该类的对象称为<em>函数对象(function object)</em></strong></li></ul><h3 id="含有状态的函数对象类"><a href="#含有状态的函数对象类" class="headerlink" title="含有状态的函数对象类"></a>含有状态的函数对象类</h3><ul><li>函数对象类通常也包含其他数据成员，用于定制调用运算符中的操作</li><li><p>定义一个重载了函数调用运算符的类</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintString</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PrintString</span>(std::ostream &amp; o = std::cout, <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27; &#x27;</span>) : <br>                <span class="hljs-built_in">os</span>(o), <span class="hljs-built_in">sep</span>(c) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str)</span> <span class="hljs-type">const</span> </span>&#123; os &lt;&lt; str &lt;&lt; sep; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::ostream &amp; os;  <span class="hljs-comment">// 用于写入的目的流</span><br>    <span class="hljs-type">char</span> sep;       <span class="hljs-comment">// 用于将不同输出隔开的字符</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>使用 PrintString</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">PrintString printer;        <span class="hljs-comment">// 使用默认值，打印到 std::cout</span><br><span class="hljs-built_in">printer</span>(s);                 <span class="hljs-comment">// 在 std::cout 中打印 s, 后跟一个空格</span><br><span class="hljs-function">PrintString <span class="hljs-title">errors</span><span class="hljs-params">(std::cerr, <span class="hljs-string">&#x27;\n&#x27;</span>)</span></span>;<br><span class="hljs-built_in">errors</span>(s);                  <span class="hljs-comment">// 在 std::cerr 中打印 s ，后跟一个换行符</span><br></code></pre></td></tr></table></figure></li><li><p>函数对象常常作为泛型算法的实参。例如，在 for_each 中使用自定义的函数对象来打印容器内容</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::for_each(vs.<span class="hljs-built_in">begin</span>(), vs.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">PrintString</span>(cerr, <span class="hljs-string">&#x27;\n&#x27;</span>));<br></code></pre></td></tr></table></figure></li></ul><h2 id="lambda-是函数对象"><a href="#lambda-是函数对象" class="headerlink" title="lambda 是函数对象"></a>lambda 是函数对象</h2><ul><li>写一个 <strong>lambda，编译器会将其翻译成未命名的类的未命名函数对象</strong></li><li>lambda 表达式产生的类中只含有一个重载的函数调用运算符</li><li>默认情况下，lambda 不能改变它捕获的变量，因此<strong>默认情况下，lambda 产生的类中重载函数调用运算符是 const 成员函数</strong>，如果 lambda 被声明为可变的，则函数调用运算符就不是 const 成员了</li></ul><h3 id="表示-lambda-及相应捕获行为的类"><a href="#表示-lambda-及相应捕获行为的类" class="headerlink" title="表示 lambda 及相应捕获行为的类"></a>表示 lambda 及相应捕获行为的类</h3><ul><li>当 lambda 通过<strong>引用捕获变量</strong>时，由程序负责确保 lambda 执行时引用所引的对象是存在的。<strong>编译器可以直接使用该引用而无需在生成的类中将其存储为一个数据成员</strong></li><li>当 lambda 通过<strong>值捕获变量</strong>时，lambda 产生的类<strong>必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员</strong></li><li><strong>lambda 产生的类不含有默认构造函数、赋值运算符、默认析构函数</strong>；</li><li>它<strong>是否含有拷贝构造函数或移动构造函数要视捕获的数据成员类型来看</strong></li></ul><h2 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h2><ul><li>标准库定义了一组表示算术运算符、关系运算符、逻辑运算符的类，每个类分别定义了一个执行所命名操作的调用运算符</li><li>这些类都是模板形式，可以为其指定具体的应用类型，即调用运算符的形参类型</li><li>这些类都定义在 <strong>functional 头文件</strong>中</li><li><p>标准库函数对象：</p><p>  | 算数 | 关系 | 逻辑 |<br>  | —- | —- | —- |<br>  | <code>plus&lt;Type&gt;</code> | <code>equal_to&lt;Type&gt;</code> | <code>logical_and&lt;Type&gt;</code> |<br>  | <code>minus&lt;Type&gt;</code> | <code>not_equal_to&lt;Type&gt;</code> | <code>logical_or&lt;Type&gt;</code> |<br>  | <code>multiplies&lt;Type&gt;</code> | <code>greater&lt;Type&gt;</code> | <code>logical_not&lt;Type&gt;</code> |<br>  | <code>divides&lt;Type&gt;</code> | <code>greater_equal&lt;Type&gt;</code> | |<br>  | <code>modulus&lt;Type&gt;</code> | <code>less&lt;Type&gt;</code> | |<br>  | <code>negate&lt;Type&gt;</code> | <code>less_equal&lt;Type&gt;</code> | |</p></li></ul><h3 id="在算法中使用标准库函数对象"><a href="#在算法中使用标准库函数对象" class="headerlink" title="在算法中使用标准库函数对象"></a>在算法中使用标准库函数对象</h3><ul><li><p><strong>表示运算符的函数对象常用来替换算法中的默认运算符</strong></p><ul><li><p>例如默认情况排序算法使用 <code>operator&lt;</code> 将序列按升序排序，可以对算法传入一个 greater 类型的对象来将序列按降序排序，该类将产生一个调用运算符并执行待排序列类型的大于运算</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 传入一个临时函数对象用于执行两个 string 对象的 &gt; 比较运算</span><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;string&gt;());<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>特别注意，标准库规定其函数对象对于指针同样适用</strong></p><ul><li><strong>直接比较两个无关指针将会产生未定义行为</strong></li><li><p>但可以使用标准库函数对象来实现比较指针的目的</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector&lt;string*&gt; vec;<br><br><span class="hljs-comment">// 错误，vec 中的指针之间没有关系，所以 &lt; 将产生未定义行为</span><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <br>        [](string *a, string *b) &#123; <span class="hljs-keyword">return</span> a &lt; b; &#125;);<br><br><span class="hljs-comment">// 正确，可以使用标准库的 less 来比较指针</span><br><span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">less</span>&lt;string*&gt; ());<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>关联容器使用 <code>less&lt;key_type&gt;</code> 对元素排序，因此定义一个指针作为关键字的 set 或 map 可以无需声明 less</strong></p></li></ul><h2 id="可调用对象与-function"><a href="#可调用对象与-function" class="headerlink" title="可调用对象与 function"></a>可调用对象与 function</h2><ul><li>c++ 中的可调用对象：<ul><li><strong>函数</strong></li><li><strong>函数指针</strong></li><li><strong>lambda</strong> 表达式</li><li><strong>bind</strong> 创建的对象</li><li><strong>重载了函数调用运算符的类</strong></li></ul></li><li>可调用对象也有自己的类型<ul><li>lambda 表达式有唯一的（未命名）类类型</li><li>函数和函数指针的类型取决于其返回值类型和实参类型</li></ul></li></ul><h3 id="不同类型可能具有相同的调用形式"><a href="#不同类型可能具有相同的调用形式" class="headerlink" title="不同类型可能具有相同的调用形式"></a>不同类型可能具有相同的调用形式</h3><ul><li>不同类型的可调用对象可能共享同一种<strong>调用形式(call signature)</strong><ul><li>调用形式指明了调用返回的类型，以及传递给调用的实参类型，例如 <code>int(int, int)</code></li></ul></li><li><p>下面几个不同的可调用对象有一个<strong>共享的调用形式</strong>：<code>int(int, int)</code></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> i + j; &#125;<br><span class="hljs-comment">// lambda, 其产生一个未命名的函数对象类</span><br><span class="hljs-keyword">auto</span> mod = [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> i % j; &#125;<br><span class="hljs-comment">// 函数对象类</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">divide</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">int</span> denominator, <span class="hljs-type">int</span> divisor)</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> denominator / divisor; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="函数表-function-table"><a href="#函数表-function-table" class="headerlink" title="函数表(function table)"></a>函数表(function table)</h4><ul><li>可定义一个<strong>函数表(function table) 用于存储指向这些可调用对象的“指针”</strong></li><li>当程序需要执行某个特定操作时，从表中查找该调用的函数</li><li><p>函数表可通过 map 来实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">map&lt;string, (<span class="hljs-type">int</span>*) (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; function_table;<br></code></pre></td></tr></table></figure></li><li><p>但这种定义方式，<strong>只能向 map 中添加 <code>(int*) (int, int)</code> 类型的函数指针，而不能添加 lambda 或者重载了调用运算符的类</strong></p></li></ul><h3 id="标准库-function-类型"><a href="#标准库-function-类型" class="headerlink" title="标准库 function 类型"></a>标准库 function 类型</h3><ul><li>function 用来<strong>解决如何定义函数表 map 的 mapped_type 类型问题</strong></li><li>function 定义在<strong>头文件 functional</strong> 中</li><li><p><strong>function 定义的操作</strong></p><p>  | Operatoration | Description |<br>  | —- | —- |<br>  | <code>function&lt;T&gt; f;</code> | f 是用来存储可调用对象的空 function <br> <strong>这些调用对象的调用形式应该与函数类型 T 相同</strong> <em>(即 T 是 retType(args))</em> |<br>  | <code>function&lt;T&gt; f(nullptr);</code> | 显式的构造一个空 function |<br>  | <code>function&lt;T&gt; f(obj);</code> | 在 f 中存储可调用对象 obj 的副本 |<br>  | <code>f</code> | <strong>将 f 作为条件：当 f 中含有一个可调用对象时为真，否则为假</strong> |<br>  | <code>f(args)</code> | 调用 f 中的对象，参数是 args |</p></li><li><p>定义为 <strong><code>function&lt;T&gt;</code> 的成员的类型</strong></p><p>  | Type | Description |<br>  | —- | —- |<br>  | <code>result_type</code> | 该 function 类型的<strong>可调用对象的返回类型</strong> |<br>  | <code>argument_type</code> <br> <code>first_argument_type</code> <br> <code>second_argument_type</code> | <strong>当 T 有一个或两个实参时定义的类型</strong> <br> <strong>如果 T 只有一个实参，则 argument_type 是该类型的同义词(argument_type 等价于 T)</strong> <br> 如果有两个实参，则 <strong>firse_argument_type 和 second_argument_type 分别代表两个实参的类型</strong> |</p></li><li><p>function 是一个<strong>模板</strong>，当创建 function 时必须提供额外信息(例如<strong>对象的调用形式</strong>)</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt;<br></code></pre></td></tr></table></figure></li><li><p>重新声明几种可调用对象</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f1 = add;    <span class="hljs-comment">// 函数指针</span><br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f2 = <span class="hljs-built_in">divide</span>();   <span class="hljs-comment">// 函数对象类的对象</span><br>function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt; f3 = [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)        <span class="hljs-comment">// lambda</span><br>                            &#123;<span class="hljs-keyword">return</span> i * j; &#125;<br><br>cout &lt;&lt; <span class="hljs-built_in">f1</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;        <span class="hljs-comment">// print 6</span><br>cout &lt;&lt; <span class="hljs-built_in">f2</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;        <span class="hljs-comment">// print 2</span><br>cout &lt;&lt; <span class="hljs-built_in">f3</span>(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>) &lt;&lt; endl;        <span class="hljs-comment">// print 8</span><br></code></pre></td></tr></table></figure></li><li><p>使用 function 定义函数表</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 所有的可调用对象必须接受两个 int 、返回一个 int</span><br><span class="hljs-comment">// map 中的元素可以是函数指针、函数对象、lambda</span><br>map&lt;string, funciton&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt;&gt; function_table;<br></code></pre></td></tr></table></figure></li><li><p>向这个 map 中添加可调用对象：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">map&lt;string, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt;&gt; function_tables = &#123;<br>    &#123;<span class="hljs-string">&quot;+&quot;</span>, add&#125;,                                 <span class="hljs-comment">// 函数指针</span><br>    &#123;<span class="hljs-string">&quot;-&quot;</span>, std::<span class="hljs-built_in">minus</span>&lt;<span class="hljs-type">int</span>&gt; ()&#125;,                  <span class="hljs-comment">// 标准库函数对象</span><br>    &#123;<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-built_in">divide</span>()&#125;,                            <span class="hljs-comment">// 用户定义的函数对象</span><br>    &#123;<span class="hljs-string">&quot;*&quot;</span>, [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> i*j; &#125;&#125;,    <span class="hljs-comment">// 未命名的 lambda 对象</span><br>    &#123;<span class="hljs-string">&quot;%&quot;</span>, mod&#125;                                  <span class="hljs-comment">// 命名了的 lambda 对象</span><br>    &#125;;<br></code></pre></td></tr></table></figure></li><li><p>尽管这些<strong>可调用对象的类型不同</strong>，但是它们都<strong>共享一个调用形式</strong>，所以仍然能够把这些所有类型都存储在同一个 <code>function&lt;int(int,int)&gt;</code> 类型中</p></li><li><p>function 类型重载了调用运算符，该运算符<strong>接受它自己的实参</strong>然后<strong>将其传递给存好的可调用对象</strong></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">function_table[<span class="hljs-string">&quot;+&quot;</span>] (<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// 调用 add</span><br>function_table[<span class="hljs-string">&quot;-&quot;</span>] (<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// 使用 minus&lt;int&gt; 对象的调用运算符</span><br>funciton_table[<span class="hljs-string">&quot;/&quot;</span>] (<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// 使用 divide 对象的调用运算符</span><br>function_table[<span class="hljs-string">&quot;*&quot;</span>] (<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// 调用 lambda 对象</span><br>function_table[<span class="hljs-string">&quot;%&quot;</span>] (<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// 调用 lambda 对象</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="重载的函数与-function"><a href="#重载的函数与-function" class="headerlink" title="重载的函数与 function"></a>重载的函数与 function</h3><ul><li><p>不能直接将重载函数的名字存入 function 类型的对象中，有命名二义性的问题</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123; <span class="hljs-keyword">return</span> i + j; &#125;<br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp; lhs, <span class="hljs-type">const</span> Sale_data &amp; rhs)</span></span>;<br>map&lt;string, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)&gt;&gt; function_table;<br>function_table.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;+&quot;</span>, add&#125;);      <span class="hljs-comment">// 错误，哪个 add ?</span><br></code></pre></td></tr></table></figure></li><li><p>可以通过<strong>存储函数指针</strong>解决二义性问题</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">int</span> (*fp) (<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> i + j; &#125;<br>function_table.<span class="hljs-built_in">insert</span>( &#123;<span class="hljs-string">&quot;+&quot;</span>, fp&#125;);<br></code></pre></td></tr></table></figure></li><li><p>也可以<strong>使用 lambda</strong> 解决</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用 lambda 来指定希望使用的 add 版本</span><br>function_table.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;+&quot;</span>, [](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(i,j); &#125; &#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 函数调用运算符 </tag>
            
            <tag> 标准库函数对象 </tag>
            
            <tag> function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.1 重载运算基本概念</title>
      <link href="/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.1%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>重载运算符是具有特殊名字的成员函数，名字由<strong>关键字 <code>operator</code></strong> 和其后要定义的<strong>运算符</strong>组成</li><li>重载运算符也具有返回类型，参数列表和函数体</li><li>重载运算符的<strong>参数数量与该运算符的运算对象数量一样多</strong><ul><li>一元运算符有一个参数</li><li>二元运算符有两个，二元运算符左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数</li></ul></li><li><strong>除了重载的函数调用运算符 <code>operator ()</code> 之外，其他运算符都不能有默认实参</strong></li><li>如果<strong>运算符函数是成员函数</strong>，则它的<strong>第一个(左侧)运算对象绑定到 this 指针上</strong></li><li>对于一个运算符函数，它<strong>要么是类的成员，要么至少含有一个类类型的参数</strong>，当运算符的运算对象都是内置类型时，无法重载</li></ul><h2 id="可被重载的运算符"><a href="#可被重载的运算符" class="headerlink" title="可被重载的运算符"></a>可被重载的运算符</h2><div class="table-container"><table><thead><tr><th>Op</th><th>Op</th><th>Op</th><th>Op</th><th>Op</th><th>Op</th></tr></thead><tbody><tr><td><code>+</code></td><td><code>-</code></td><td><code>*</code></td><td><code>/</code></td><td><code>%</code></td><td><code>^</code></td></tr><tr><td><code>&amp;</code></td><td>`\</td><td>`</td><td><code>~</code></td><td><code>!</code></td><td><code>,</code></td><td><code>=</code></td></tr><tr><td><code>&lt;</code></td><td><code>&gt;</code></td><td><code>&lt;=</code></td><td><code>&gt;=</code></td><td><code>++</code></td><td><code>--</code></td></tr><tr><td><code>&lt;&lt;</code></td><td><code>&gt;&gt;</code></td><td><code>==</code></td><td><code>!=</code></td><td><code>&amp;&amp;</code></td><td>`\</td><td>\</td><td>`</td></tr><tr><td><code>+=</code></td><td><code>-=</code></td><td><code>/=</code></td><td><code>%=</code></td><td><code>^=</code></td><td><code>&amp;=</code></td></tr><tr><td>`\</td><td>=`</td><td><code>*=</code></td><td><code>&lt;&lt;=</code></td><td><code>&gt;&gt;=</code></td><td><code>[]</code></td><td><code>()</code></td></tr><tr><td><code>-&gt;</code></td><td><code>-&gt;*</code></td><td><code>new</code></td><td><code>new[]</code></td><td><code>delete</code></td><td><code>delete[]</code></td></tr></tbody></table></div><h2 id="不能被重载的运算符"><a href="#不能被重载的运算符" class="headerlink" title="不能被重载的运算符"></a>不能被重载的运算符</h2><div class="table-container"><table><thead><tr><th>Op</th><th>Op</th><th>Op</th><th>Op</th></tr></thead><tbody><tr><td><code>::</code></td><td><code>.*</code></td><td><code>.</code></td><td><code>? :</code></td></tr></tbody></table></div><h2 id="直接调用重载的运算符"><a href="#直接调用重载的运算符" class="headerlink" title="直接调用重载的运算符"></a>直接调用重载的运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一个非成员运算符函数的等价调用</span><br>data1 + data2;      <span class="hljs-comment">// 普通表达式调用</span><br><span class="hljs-keyword">operator</span>+(data1, data2);    <span class="hljs-comment">// 等价的直接调用</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一个成员运算符函数的等价调用</span><br>data1 += data2;     <span class="hljs-comment">// 普通表达式调用</span><br>data<span class="hljs-number">1.</span><span class="hljs-keyword">operator</span>+=(data2);        <span class="hljs-comment">// 等价的直接调用</span><br></code></pre></td></tr></table></figure><h2 id="某些运算符不应该被重载"><a href="#某些运算符不应该被重载" class="headerlink" title="某些运算符不应该被重载"></a>某些运算符不应该被重载</h2><ul><li>对于<strong>逻辑与运算符、逻辑或运算符、逗号运算符、&amp;&amp; 运算符、|| 运算符</strong>，这些运算符的重载版本无法保留求值顺序或短路求值属性，因此<strong>不建议重载</strong></li><li>一般也不重载都<strong>逗号运算符</strong>和<strong>取地址运算符</strong></li></ul><h2 id="使用内置类型一致的含义"><a href="#使用内置类型一致的含义" class="headerlink" title="使用内置类型一致的含义"></a>使用内置类型一致的含义</h2><ul><li>设计一个类时，<strong>先确定类需要完成哪些操作</strong>，<strong>再思考可以把哪些操作设为重载的运算符</strong><ul><li>如果类<strong>执行 IO 操作</strong>，则<strong>定义移位运算符使其与内置类型 IO 保持一致</strong></li><li>如果类操作是<strong>检查相等性</strong>，<strong>则定义 <code>operator==</code></strong>; 如果有了 <code>operator==</code>, 也应该<strong>定义 <code>operator!=</code></strong></li><li>如果类有内在的<strong>单序比较操作</strong>，则<strong>定义 <code>operator&lt;</code></strong>。如果定义了 <code>operator&lt;</code>, 则也应该<strong>定义其他比较操作</strong></li><li><strong>重载运算符的返回类型通常与其内置版本的返回类型兼容：</strong><ul><li><strong>逻辑运算符和关系运算符返回 bool 值</strong></li><li><strong>算术运算符返回一个类类型的值</strong></li><li><strong>赋值运算符和复合赋值运算符应该返回左侧对象的一个引用</strong></li></ul></li></ul></li></ul><h2 id="选择成为非成员还是成员"><a href="#选择成为非成员还是成员" class="headerlink" title="选择成为非成员还是成员"></a>选择成为非成员还是成员</h2><ul><li>准则：<ul><li><strong>赋值<code>=</code>、下标<code>[]</code>、调用<code>()</code>、成员访问箭头<code>-&gt;</code>必须是成员</strong></li><li>复合赋值运算符一般是成员，但并非必须</li><li><strong>改变对象状态</strong>的运算符和<strong>与给定类型关系密切</strong>的运算符，<strong>如递增、递减和解引用</strong>，<strong>通常应该是成员</strong></li><li><strong>具有对称性的运算符可能转换任意一端的运算对象</strong>，例如<strong>算数、相等性、关系、位</strong>运算符，通常应该是<strong>非成员</strong></li></ul></li><li>将运算符定义为成员后，它的左侧运算对象必须是所属类的一个对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 可以被重载的运算符 </tag>
            
            <tag> 不能被重载的运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.2 输入输出运算符</title>
      <link href="/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.2%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.2%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="重载输出运算符-lt-lt"><a href="#重载输出运算符-lt-lt" class="headerlink" title="重载输出运算符&lt;&lt;"></a>重载输出运算符&lt;&lt;</h2><ul><li>输出运算符<strong>第一个参数是非常量 ostream 对象的引用</strong><ul><li>非常量是因为向流输入内容会改变它的状态</li><li>引用类型是因为不能拷贝 ostream 对象</li></ul></li><li><strong>第二个参数一般是要输出对象的一个常量引用</strong><ul><li>常量是因为一般输出不会改变对象内容</li><li>引用是为了避免拷贝</li></ul></li><li>与其他输出运算符保持一致，<strong><code>operator&lt;&lt;</code> 一般要返回它的 ostream 形参</strong></li></ul><h3 id="输出运算符尽量减少格式化操作"><a href="#输出运算符尽量减少格式化操作" class="headerlink" title="输出运算符尽量减少格式化操作"></a>输出运算符尽量减少格式化操作</h3><ul><li>通常输出运算符应该主要负责打印对象内容而不是控制格式，输出运算符不应该打印换行符</li></ul><h3 id="输出运算符必须是非成员函数"><a href="#输出运算符必须是非成员函数" class="headerlink" title="输出运算符必须是非成员函数"></a>输出运算符必须是非成员函数</h3><ul><li>IO 运算符必须是<strong>非成员函数</strong>，一般<strong>声明为友元</strong></li></ul><h2 id="重载输入运算符"><a href="#重载输入运算符" class="headerlink" title="重载输入运算符"></a>重载输入运算符</h2><ul><li>输入运算符第一个参数是运算符将要读取的<strong>流的引用</strong></li><li>第二个参数是将要<strong>读入到的对象的引用</strong></li><li>返回某个给定流的引用</li></ul><h3 id="Sale-data-的输入运算符"><a href="#Sale-data-的输入运算符" class="headerlink" title="Sale_data 的输入运算符"></a>Sale_data 的输入运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::istream &amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream &amp; is, Sale_data &amp; item)&#123;<br>    <span class="hljs-type">double</span> price;<br>    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>    <span class="hljs-keyword">if</span> (is)     <span class="hljs-comment">// 检查输入是否成功</span><br>        item.revenue = item.units_sold * price;<br>    <span class="hljs-keyword">else</span><br>        item = <span class="hljs-built_in">Sale_data</span>();     <span class="hljs-comment">// 输入失败，对象被赋予默认状态</span><br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>输入运算符必须处理输入可能失败的情况</strong>，而输出运算符不需要</li><li>上例中，使用 if 检查读取操作是否成功</li></ul><h3 id="输入时的错误"><a href="#输入时的错误" class="headerlink" title="输入时的错误"></a>输入时的错误</h3><ul><li>执行输入运算符时可能发生以下错误<ul><li>当流含有错误类型的数据时读取操作可能失败</li><li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败</li></ul></li><li><strong>如果发生错误时已经有一部分对象被改变，则需要适时地将对象置为合法状态</strong></li></ul><h3 id="标志错误"><a href="#标志错误" class="headerlink" title="标志错误"></a>标志错误</h3><ul><li>一些输入运算符<strong>应该设置更多数据验证工作</strong>，除了检查读取是否成功，<strong>还检查数据输入格式等是否正确</strong><ul><li>通常，输入运算符只设置 failbit</li><li>设置 eofbit 表示文件耗尽</li><li>设置 badbit 表示流被破坏</li></ul></li><li>若格式检查错误，则设置流的条件状态以标示出失败信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 重载输入运算符 </tag>
            
            <tag> 重载输出运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.3 算数和关系运算符</title>
      <link href="/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.3%20%E7%AE%97%E6%95%B0%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.3%20%E7%AE%97%E6%95%B0%E5%92%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>通常将算数和关系运算符<strong>定义为非成员函数</strong>，<strong>以允许对左侧或右侧运算对象进行转换</strong></li><li>这些运算符一般不需要改变对象的状态，所以<strong>形参都是 const 引用</strong></li><li>算数运算符通常计算两个运算对象得到一个新值，是个局部变量，操作结束<strong>返回该局部变量的副本</strong><ul><li>定义了算术运算一般也会定义对应的复合赋值运算符</li></ul></li><li><strong>如果定义了复合赋值运算符，一般使用复合赋值运算符定义算术运算符</strong></li></ul><h2 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h2><ul><li>只有当所有数据成员都相等时，两个对象才相等</li><li><p>Sale_data 的相等运算符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Sale_data &amp; lhs, <span class="hljs-type">const</span> Sale_data &amp; rhs)&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>() &amp;&amp;<br>            lhs.units_sold == rhs.units_sold &amp;&amp;<br>            lhs.revenue == rhs.revenue;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Sale_data &amp; lhs, <span class="hljs-type">const</span> Sale_data &amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果一个类含有判断两个对象是否相等的操作，就应该重载 <code>operator==</code></p></li><li>如果定义了 <code>operator==</code>，该运算符应该能判断一组给定对象中是否含有重复数据</li><li>通常情况下，相等运算符应该具有传递性，即 <code>a==b</code> 和 <code>b==c</code> 都为真，则 <code>a==b</code> 也为真</li><li>定义了 <code>operator==</code> 也应该定义 <code>operator!=</code></li><li><code>operator==</code> 和 <code>operator!=</code> 的其中一个应该把工作委托给另一个</li></ul><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><ul><li>通常，关系运算符应该：<ol><li><strong>定义顺序关系</strong>，令其与关联容器中对关键字的要求一样</li><li>如果<strong>类同时有相等运算符</strong>，则定义另一种关系令其<strong>与 <code>==</code> 保持一致</strong>。特别是,<strong>如果两个对象是 <code>!=</code> 的，则一个对象应该 <code>&lt;</code> 另一个对象</strong></li></ol></li><li>如果<strong>存在唯一一种逻辑可靠的 <code>&lt;</code> 定义</strong>，则应该考虑为这个类定义 <code>operator&lt;</code></li><li>如果类同时还包含 <code>==</code>，<strong>当且仅当 <code>&lt;</code> 的定义和 <code>==</code> 产生的结果一致时才定义 <code>operator&lt;</code></strong></li></ul><h2 id="String-的相等和关系运算符"><a href="#String-的相等和关系运算符" class="headerlink" title="String 的相等和关系运算符"></a>String 的相等和关系运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> String &amp; lhs, <span class="hljs-type">const</span> String &amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span> (lhs.<span class="hljs-built_in">size</span>() != rhs.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">memcmp</span>(lhs.elements, rhs.elements, lhs.<span class="hljs-built_in">size</span>()) == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> String &amp; lhs, <span class="hljs-type">const</span> String &amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> String &amp; lhs, <span class="hljs-type">const</span> String &amp; rhs) &#123;<br>    <span class="hljs-comment">// 使用 std::lexicographical_compare 按字典序逐个字符比较</span><br>    <span class="hljs-comment">// 遇到第一个不同字符，按该字符的 &lt; 关系决定结果</span><br>    <span class="hljs-comment">// 如果所有字符都相同，则长度短的序列 &lt; 长度较长的序列</span><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">lexicographical_compare</span>(lhs.elements, lhs.first_free, rhs.elements, rhs.first_free);<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> String &amp; lhs, <span class="hljs-type">const</span> String &amp; rhs) &#123; <span class="hljs-keyword">return</span> rhs &lt; lhs; &#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> String &amp; lhs, <span class="hljs-type">const</span> String &amp; rhs) &#123; <span class="hljs-keyword">return</span> !(rhs &lt; lhs); &#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> String &amp; lhs, <span class="hljs-type">const</span> String &amp; rhs) &#123; <span class="hljs-keyword">return</span> !(lhs &lt; rhs); &#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 算数运算符 </tag>
            
            <tag> 关系运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.4 赋值运算符</title>
      <link href="/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.4%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.4%20%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>拷贝赋值和移动赋值运算符将<strong>类的一个对象赋值给该类的另一个对象</strong></li><li>类还可以定义其他赋值运算符，<strong>将其他类型的对象作为右侧运算对象</strong></li><li><p>例如 StrVec 的可以接受 initializer_list 对象的赋值运算符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec &amp; StrVec::<span class="hljs-keyword">operator</span>=(std::initializer_list&lt;std::string&gt; il) &#123;<br>    <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">alloc_n_copy</span>(il.<span class="hljs-built_in">begin</span>(), il.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">free</span>();<br>    elements = data.first;<br>    first_free = cap = data.second;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以重载赋值运算符。无论形参类型是什么，<strong>赋值运算符都必须被定义为成员函数</strong></p></li></ul><h2 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h2><ul><li>复合赋值运算符不一定非得是类的成员，但一般定义为类成员</li><li><p>Sale_data 的复合赋值运算符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 作为成员的二元运算符，左侧对象隐式绑定到 this 指针</span><br><span class="hljs-comment">// 假定两个对象表示的是同一本书</span><br>Sale_data &amp; Sale_data::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Sale_data &amp;rhs) &#123;<br>    units_sold += rhs.units_sold;<br>    revenue += rhs.revenue;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>赋值运算符和复合赋值运算符<strong>都应该返回左侧运算对象的引用</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 赋值运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.5 下标运算符</title>
      <link href="/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.5%20%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.5%20%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<ul><li>表示容器的类通常可以根据元素在容器中的位置来访问元素，这些类一般定义下标运算符 <code>operator[]</code></li><li><strong>下标运算符必须是成员函数</strong></li><li>下标运算符通常<strong>以所访问元素的引用作为返回值</strong><ul><li>返回元素引用的好处是下标可以出现在赋值运算符的任意一侧</li><li>最好<strong>同时定义常量版本和非常量版本</strong>, 当作用于一个常量对象时，返回常量引用确保不会给返回的对象赋值</li></ul></li><li><p>StrVec 的下标运算符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::string &amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> n) &#123; <span class="hljs-keyword">return</span> elements[n]; &#125;<br>    <span class="hljs-type">const</span> std::string &amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> n) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> elements[n]; &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 下标运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.6 递增和递减运算符</title>
      <link href="/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.6%20%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/04/23/14.%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/14.6%20%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>在迭代器类中通常实现递增 <strong>(<code>++</code>)</strong> 递减 <strong>(<code>--</code>)</strong> 运算符</li><li>它们改变的是所操作对象的状态，所以建议<strong>定义为成员函数</strong></li><li>内置类型的递增递减运算符有<strong>前置版本</strong>和<strong>后置版本</strong>，，所以重载它们时也应该定义两个版本</li></ul><h2 id="定义前置递增-递减运算符"><a href="#定义前置递增-递减运算符" class="headerlink" title="定义前置递增/递减运算符"></a>定义前置递增/递减运算符</h2><ul><li><strong>前置运算符应该返回递增/递减后对象的引用</strong></li><li><p>strBlobPtr 的前置运算符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">strBlobPtr &amp; strBlobPtr::<span class="hljs-keyword">operator</span>++() &#123;<br>    <span class="hljs-comment">// 如果 curr 已经指向了尾后位置，则无法递增它</span><br>    <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;increment past end of strBlobPtr&quot;</span>);<br>    ++curr;     <span class="hljs-comment">// 将 curr 在当前状态下向向移动一个元素</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>strBlobPtr &amp; strBlobPtr::<span class="hljs-keyword">operator</span>--() &#123;<br>    <span class="hljs-comment">// 如果 curr 是 0，则递减它将产生一个无效下标</span><br>    --curr;<br>    <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;decrement past begin of strBlobPtr&quot;</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>首先调用 check 检查 strBlobPtr 是否有效，再检查给定的索引值是否有效</p></li></ul><h2 id="区分前置和后置运算符"><a href="#区分前置和后置运算符" class="headerlink" title="区分前置和后置运算符"></a>区分前置和后置运算符</h2><ul><li><strong>前置和后置运算符形式上相同</strong>(同一个符号，名字相同，运算对象的数量和类型也相同)，<strong>普通重载无法区分</strong></li><li>给后置版本<strong>多提供一个额外的 int 型参数(不被使用)</strong>，当使用后置运算符时，编译器为这个形参提供一个值为 0 的实参。<ul><li>从语法上来讲，可以使用这个形参，但是一般不这样做，这个形参<strong>唯一的作用就是区分前置和后置</strong></li></ul></li><li><p>strBlobPtr 的后置运算符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">strBlobPtr strBlobPtr::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 此处无需检查有效性，调用前置运算符时才需要检查</span><br>    strBlobPtr ret = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 记录当前值</span><br>    ++*<span class="hljs-keyword">this</span>;    <span class="hljs-comment">// 向前移动一个元素，前置++会检查递增的有效性</span><br>    <span class="hljs-keyword">return</span> ret; <span class="hljs-comment">// 返回之前记录的状态</span><br>&#125;<br><br>strBlobPtr strBlobPtr::<span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 此处无需检查有效性，调用前置运算符时才需要检查</span><br>    strBlobPtr ret = *<span class="hljs-keyword">this</span>;<br>    --*<span class="hljs-keyword">this</span>;    <span class="hljs-comment">// 向前移动一个元素，前置++会检查递增的有效性</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>后置运算符各自调用对应的前置运算符来完成实际工作</p></li><li>后置运算符最终效果是：<strong>对象本身向前移动一个元素，返回的结果仍然反映对象未移动之前的值</strong></li></ul><h2 id="显式的调用后置运算符"><a href="#显式的调用后置运算符" class="headerlink" title="显式的调用后置运算符"></a>显式的调用后置运算符</h2><ul><li>后置运算符也可以显式的调用</li><li>如果要显式的调用后置版本的运算符，就必须为其传递一个实参</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">strBlobPtr <span class="hljs-title">bp</span><span class="hljs-params">(a1)</span></span>;<br>bp.<span class="hljs-keyword">operator</span>++(<span class="hljs-number">0</span>);   <span class="hljs-comment">// 显式的调用后置运算符</span><br>bp.<span class="hljs-keyword">operator</span>++();    <span class="hljs-comment">// 显式的调用前置运算符</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 递增运算符 </tag>
            
            <tag> 递减运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.6 对象移动</title>
      <link href="/2025/04/22/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.6%20%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8/"/>
      <url>/2025/04/22/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.6%20%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>新标准提供了<strong>移动而非拷贝对象</strong>的能力</li><li>在某些情况下，<strong>对象拷贝后就被立即销毁，在重新分配内存的过程中，从旧内存空间将元素拷贝到新内存是不必要的</strong>，移动元素会大幅提升性能</li><li><strong>IO 类和 unique_ptr 这样的类，都包含不能被共享的资源(如指针和 IO 缓冲)</strong>, 这些类型的对象不能被拷贝但<strong>可以被移动</strong></li><li>新标准中，<strong>标准库容器、string、shared_ptr 类既支持拷贝也支持移动，IO 类和 unique_ptr 类可以移动但不能拷贝</strong></li></ul><h2 id="右值引用-rvalue-reference"><a href="#右值引用-rvalue-reference" class="headerlink" title="右值引用(rvalue reference)"></a>右值引用(rvalue reference)</h2><h3 id="左值与右值的概念"><a href="#左值与右值的概念" class="headerlink" title="左值与右值的概念"></a>左值与右值的概念</h3><ul><li>当一个<strong>对象被用作右值</strong>时，用的是<strong>对象的值(内容)</strong>，当<strong>对象被用作左值</strong>时，用的是<strong>对象的身份(在内存中的位置)</strong></li><li>一个重要原则：<ul><li><strong>在需要右值的地方可以使用左值来代替</strong>，但是<strong>不能将右值当成左值(也就是位置) 来使用</strong></li><li>当一个<strong>左值被当成右值</strong>时，<strong>实际使用的是它的内容(值)</strong></li></ul></li></ul><h3 id="右值引用概念"><a href="#右值引用概念" class="headerlink" title="右值引用概念"></a>右值引用概念</h3><ul><li>所谓右值引用，就是<strong>必须绑定到右值的引用</strong></li><li><strong>通过 <code>&amp;&amp;</code> 获取右值引用</strong></li><li>一个<strong>重要性质</strong>：<strong>只能绑定到一个将要销毁的对象</strong></li></ul><h3 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h3><ul><li><strong>左值引用</strong>(常规引用，<strong>使用 <code>&amp;</code> 获取</strong>)：<strong>不能将其绑定到要求转换的表达式、字面常量、返回右值的表达式</strong></li><li><strong>右值引用</strong>：对象的另一个名字，绑定特性与左值引用完全相反<ul><li><strong>可以将右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式</strong></li><li>但是不能绑定到左值</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp; r = i;     <span class="hljs-comment">// 正确，r 引用 i</span><br><span class="hljs-type">int</span> &amp;&amp; rr = i;   <span class="hljs-comment">// 错误，不能将右值引用绑定到左值</span><br><br><span class="hljs-type">int</span> &amp; r2 = i * <span class="hljs-number">42</span>;  <span class="hljs-comment">// 错误，不能将左值引用绑定到右值表达式</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; r3 = i * <span class="hljs-number">42</span>;    <span class="hljs-comment">// 正确，可以将一个 const 引用绑定到右值表达式</span><br><span class="hljs-type">int</span> &amp;&amp; rr2 = i * <span class="hljs-number">42</span>;    <span class="hljs-comment">// 正确，右值引用 rr2 绑定到了右值表达式</span><br></code></pre></td></tr></table></figure><ul><li><strong>返回左值引用的函数：</strong><ul><li>例如<strong>赋值、下标、解引用、前置递增/递减运算符</strong>，<strong>都返回左值表达式</strong></li><li>可以将一个左值引用绑定到这类表达式的结果上</li></ul></li><li><strong>返回非引用类型的函数：</strong><ul><li>例如<strong>算数、关系、位、后置递增/递减运算符</strong>，<strong>都生成右值</strong></li><li>不能将左值引用绑定到此类表达式</li><li><strong>可以将一个 const 的左值引用</strong>或<strong>一个右值引用</strong>绑定到这类表达式</li></ul></li></ul><h3 id="左值持久，右值短暂"><a href="#左值持久，右值短暂" class="headerlink" title="左值持久，右值短暂"></a>左值持久，右值短暂</h3><ul><li>左值拥有持久的状态，而<strong>右值要么是字面常量，要么是在表达式求值过程中创建的临时对象</strong></li><li>由于右值只能绑定到临时对象：<ul><li>右值所引用的对象即将被销毁</li><li>该对象没有其他用户</li></ul></li><li><strong>使用右值引用的代码可以自由接管所引用对象的资源</strong></li></ul><h3 id="变量是左值"><a href="#变量是左值" class="headerlink" title="变量是左值"></a>变量是左值</h3><ul><li>变量表达式是左值，因此<strong>不能将右值引用绑定到变量上</strong>，<strong>即使这个变量是右值引用类型也不行</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp; rr1 = <span class="hljs-number">42</span>;    <span class="hljs-comment">// 正确，字面常量是右值</span><br><span class="hljs-type">int</span> &amp;&amp; rr2 = rr1;   <span class="hljs-comment">// 错误，表达式 rr1 是左值</span><br></code></pre></td></tr></table></figure><h3 id="标准库-move-函数"><a href="#标准库-move-函数" class="headerlink" title="标准库 move 函数"></a>标准库 move 函数</h3><ul><li><strong>右值引用不能直接绑定到左值上</strong>，<strong>但可以显式的将一个左值转换为对应的右值引用类型</strong></li><li>还可以使用 <strong>move 函数</strong>获取绑定到左值上的右值引用</li><li>move 函数定义在<strong>头文件 utility</strong> 中</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;&amp; rr3 = std::<span class="hljs-built_in">move</span>(rr1); <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><ul><li><strong>调用 std::move 意味着：可以销毁移后源对象，也可以对它赋予新值，但是不能使用移后源对象的值</strong></li><li>使用 move 的代码应该直接使用 <strong><code>std::move</code></strong> 而不是 <code>move</code>, 避免潜在的名字冲突</li></ul><h2 id="移动构造函数与移动赋值运算符"><a href="#移动构造函数与移动赋值运算符" class="headerlink" title="移动构造函数与移动赋值运算符"></a>移动构造函数与移动赋值运算符</h2><ul><li>这两个成员类似对应的拷贝操作，<strong>但它们从给定对象“窃取”资源而不是拷贝资源</strong></li><li>移动构造函数：<ul><li><strong>第一个参数是该类类型的右值引用</strong></li><li><strong>其他额外参数都必须有默认实参</strong></li></ul></li><li>除了完成资源移动，移动构造函数还必须确保<strong>移后源对象处于这样一个状态——销毁它是无害的</strong>。特别是，一旦完成移动操作，<strong>源对象必须不再指向被移动的资源——这些资源的所有权已归属于新创建的对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec::<span class="hljs-built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span>     <span class="hljs-comment">// 移动构造函数不应该抛出任何异常</span><br>        <span class="hljs-comment">// 成员初始化器接管 s 中的资源</span><br>        :<span class="hljs-built_in">elements</span>(s.elements), <span class="hljs-built_in">first_free</span>(s.first_free), <span class="hljs-built_in">cap</span>(s.cap)&#123;<br>    <span class="hljs-comment">// 令 s 进入这样一种状态——对其运行析构函数是安全的</span><br>    s.elements = s.first_free = s.cap = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>与拷贝构造函数不同，<strong>移动构造函数不分配任何新内存</strong>，它接管给定 StrVec 中的内存</li><li><strong>接管给定内存之后，将给定对象中的指针都设为 nullptr</strong>，这样就完成了从给定对象的移动操作，此对象将继续存在</li><li>最终移后源对象将被销毁，在其上执行析构函数</li></ul><h3 id="移动操作、标准库容器和异常"><a href="#移动操作、标准库容器和异常" class="headerlink" title="移动操作、标准库容器和异常"></a>移动操作、标准库容器和异常</h3><ul><li>移动操作不分配新内存，因此通常不抛出任何异常</li><li><strong>不抛出异常的移动构造函数与移动赋值运算符必须标记为 <code>noexcept</code></strong></li></ul><h4 id="异常安全-Exception-Safety"><a href="#异常安全-Exception-Safety" class="headerlink" title="异常安全(Exception Safety)"></a>异常安全(Exception Safety)</h4><ul><li>标准库容器对异常发生提供<strong>强异常安全性(strong guarantee)</strong>：<ul><li>即当调用 vector 的 push_back 时，要么操作成功，vector 发生修改，要么发生异常，此操作不改变原 vector</li><li><strong>实现 strong guarantee 的前提是 vector 能够“回滚”到异常发生前状态</strong>。它会释放为此次操作额外分配的内存，而保留原来那块内存和里面的元素</li></ul></li></ul><h4 id="搬运元素的两种方式"><a href="#搬运元素的两种方式" class="headerlink" title="搬运元素的两种方式"></a>搬运元素的两种方式</h4><ul><li><strong>拷贝构造(copy):</strong> 每个元素都会使用拷贝构造函数在新内存中重新构造；如果其中某次构造元素出现异常，这时旧元素仍然没有被动过，安全回滚即可</li><li><p><strong>移动构造(move):</strong> 如果元素类型提供了移动构造函数，新元素就可以“窃取”源对象的内部资源，比拷贝更高效。但是如果其中某次移动时出现异常，就会遇到“部分修改”问题：</p><ul><li>已经移动过的旧元素：状态被改变(资源被抽走了)</li><li>尚未构造的新元素：根本不存在。</li></ul><p>此时就无法回滚到操作之前的状态了</p></li></ul><h4 id="noexcept-的作用"><a href="#noexcept-的作用" class="headerlink" title="noexcept 的作用"></a>noexcept 的作用</h4><ul><li><strong>除非标准库知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数</strong></li><li><strong>如果希望标准库在重新分配内存这类情况下，对自定义类型的对象使用移动构造函数而不是拷贝</strong>，<strong>就必须显式的告诉标准库自定义类型的移动构造函数可以安全使用</strong>，通过将移动构造函数与移动赋值运算符<strong>标记为 noexcept</strong> 来做到这一点</li></ul><h3 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h3><ul><li><strong>移动赋值运算符</strong>执行与<strong>析构函数</strong>和<strong>移动构造函数</strong>相同的工作<ul><li>与移动构造函数一样，移动赋值运算符<strong>不能抛出任何异常</strong>，标记为 noexcept</li><li>类似拷贝赋值运算符，移动赋值运算符<strong>必须正确处理自赋值</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec &amp; StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> &#123;<br>    <span class="hljs-comment">// 直接进行自赋值检测</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;<br>        <span class="hljs-built_in">free</span>();     <span class="hljs-comment">// 释放已有元素</span><br>        <span class="hljs-comment">// 从 rhs 接管资源</span><br>        elements = rhs.elements;<br>        first_free = rhs.first_free;<br>        cap = rhs.cap;<br>        <span class="hljs-comment">// 将 rhs 置于可析构状态</span><br>        rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上例中，直接检查 <strong>this 指针与 rhs 的地址是否相同</strong>来<strong>判断是否是自赋值</strong></li><li>进行自赋值检查的原因：<ul><li><strong>此右值可能是调用 std::move 返回的结果</strong></li><li>与其他赋值运算符一样，<strong>不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源，因为可能是同一块资源</strong></li></ul></li></ul><h3 id="移后源对象必须可析构"><a href="#移后源对象必须可析构" class="headerlink" title="移后源对象必须可析构"></a>移后源对象必须可析构</h3><ul><li><strong>移动操作必须确保移后源对象进入可析构状态</strong></li><li><strong>移动操作还必须保证资源被“窃取”后，对象仍然是有效的</strong>(可以安全赋新值或者可以安全地使用而不依赖当前值)</li><li><strong>移动操作对移后源对象中留下的值没有任何要求</strong></li></ul><h3 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h3><ul><li>只有当一个<strong>类没有定义任何拷贝控制成员</strong>，<strong>且它的数据成员都能使用移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符</strong></li><li><strong>移动操作永远不会被隐式定义为删除的函数(deleted function)</strong>: 但是有例外情况，如果显式的要求编译器生成 =default 的移动操作，且编译器不能移动所有成员，则编译器会将此移动操作定义为 deleted function</li><li>除了上述例外情况，编译器什么时候将合成的移动操作定义为 deleted function 与 定义 deleted 合成拷贝操作类似：<ul><li><em>如果一个类<strong>有数据成员不能被移动</strong>，<strong>则类的移动构造函数与移动赋值运算符将被定义为 deleted function</strong></em></li></ul></li><li><strong>定义了一个移动构造函数或移动赋值运算符的类必须定义自己的拷贝操作，否则这些成员被默认定义为 deleted function</strong></li></ul><h3 id="移动右值，拷贝左值"><a href="#移动右值，拷贝左值" class="headerlink" title="移动右值，拷贝左值"></a>移动右值，拷贝左值</h3><ul><li>编译器使用普通的函数匹配来确定使用哪个构造函数</li></ul><h3 id="如果没有移动构造函数，右值也会被拷贝"><a href="#如果没有移动构造函数，右值也会被拷贝" class="headerlink" title="如果没有移动构造函数，右值也会被拷贝"></a>如果没有移动构造函数，右值也会被拷贝</h3><ul><li>如果一个类没有定义移动构造函数，<strong>函数匹配规则保证该类型的对象会被拷贝，即使传递的对象是 std::move 的返回值(右值引用)</strong></li></ul><h3 id="拷贝并交换赋值运算符和移动操作"><a href="#拷贝并交换赋值运算符和移动操作" class="headerlink" title="拷贝并交换赋值运算符和移动操作"></a>拷贝并交换赋值运算符和移动操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 添加的移动构造函数</span><br>    <span class="hljs-built_in">HasPtr</span>(HasPtr &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">ps</span>(rhs.ps), <span class="hljs-built_in">i</span>(rhs.i) &#123; rhs.ps = <span class="hljs-literal">nullptr</span>; &#125;<br>    <span class="hljs-comment">// 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符</span><br>    HasPtr &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HasPtr rhs);<br><span class="hljs-comment">// 其他成员</span><br><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">HasPtr &amp; HasPtr::<span class="hljs-keyword">operator</span>=(HasPtr rhs) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;executed the copy-assignment operator&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="新的-三-五法则"><a href="#新的-三-五法则" class="headerlink" title="新的 三/五法则"></a>新的 三/五法则</h3><ul><li><strong>所有五个拷贝控制成员都应该看成一个整体：如果一个类定义了任何一个拷贝操作，它就应该定义所有的五个操作</strong></li><li>这些类通常拥有一个资源，而拷贝成员必须拷贝此资源，一般拷贝一个资源需要一些额外开销，使用移动构造函数与移动赋值运算符就可以提高性能</li></ul><h3 id="Message-类的移动操作"><a href="#Message-类的移动操作" class="headerlink" title="Message 类的移动操作"></a>Message 类的移动操作</h3><ul><li>Message 的移动成员除了需要移动 folders 成员之外，还需更新每个包含原 Message 的 Folder。必须删除指向旧 Message 的指针，并添加指向新 Message 的指针。</li><li>移动构造函数与移动赋值运算符都需要完成这个工作，将这个操作定义为一个工具函数</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Message::move_Folders</span><span class="hljs-params">(Message *m)</span> </span>&#123;<br>    folders = std::<span class="hljs-built_in">move</span>(m-&gt;folders);    <span class="hljs-comment">// 调用 set 的移动赋值运算符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : folders) &#123;<br>        f-&gt;<span class="hljs-built_in">remMsg</span>(m);   <span class="hljs-comment">// 从 Folder 中删除旧 Message 指针</span><br>        f-&gt;<span class="hljs-built_in">addMsg</span>(<span class="hljs-keyword">this</span>);    <span class="hljs-comment">// 向 Folder 中添加新 Message 指针</span><br>    &#125;<br>    m-&gt;folders.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 确保销毁 m 是无害的</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>移动构造函数<ul><li>由于向 set 中插入元素可能抛出异常：向容器中添加元素要求分配内存，可能会抛出 bad_alloc 异常，所以不会将移动构造函数与移动赋值运算符标记为 noexcept</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Message::<span class="hljs-built_in">Message</span>(Message &amp;&amp;rhs) : <span class="hljs-built_in">contents</span>(std::<span class="hljs-built_in">move</span>(rhs.contents))&#123;<br>    <span class="hljs-built_in">move_Folders</span>(&amp;rhs);     <span class="hljs-comment">// 移动 folders 并更新 Folder 指针</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>移动赋值运算符</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Message &amp; Message::<span class="hljs-keyword">operator</span>=(Message &amp;&amp;rhs) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) &#123;                 <span class="hljs-comment">// 检查自赋值</span><br><span class="hljs-comment">//        remove_from_Folders();</span><br>        contents = std::<span class="hljs-built_in">move</span>(rhs.contents);<br>        <span class="hljs-built_in">move_Folders</span>(&amp;rhs);<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h3><ul><li>标准库中定义了一种<strong>移动迭代器(move iterator)适配器</strong><ul><li>一般迭代器的解引用运算符返回一个指向元素的左值</li><li><strong>移动迭代器返回一个右值引用</strong></li></ul></li><li>通过标准库的 <strong>make_move_iterator 将一个普通迭代器转换为一个移动迭代器</strong><ul><li>此函数接受一个迭代器参数，返回一个移动迭代器</li></ul></li><li>移动迭代器支持正常的迭代器操作，可以将一对移动迭代器传递给算法</li><li><p>重写 StrVec 的 alloc_n_move 成员</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::alloc_n_move</span><span class="hljs-params">(<span class="hljs-type">size_t</span> newCap)</span> </span>&#123;<br>    <span class="hljs-comment">// 分配空间</span><br>    <span class="hljs-keyword">auto</span> first = alloc.<span class="hljs-built_in">allocate</span>(newCap);<br>    <span class="hljs-comment">// 移动元素</span><br>    <span class="hljs-keyword">auto</span> last = std::<span class="hljs-built_in">uninitialized_copy</span>(std::<span class="hljs-built_in">make_move_iterator</span>(<span class="hljs-built_in">begin</span>()),<br>                                        std::<span class="hljs-built_in">make_move_iterator</span>(<span class="hljs-built_in">end</span>()),<br>                                        first);<br>    <span class="hljs-built_in">free</span>();     <span class="hljs-comment">// 释放旧空间</span><br>    <span class="hljs-comment">// 更新指针</span><br>    elements = first;<br>    first_free = last;<br>    cap = first + newCap;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>uninitialized_copy 对输入序列的每个元素调用 construct，当给它传递移动迭代器时，意味着 construct 调用将使用移动构造函数来构造元素</p></li><li>移动一个对象可能会销毁原对象，因此<strong>只有确定算法在为一个元素赋值或者将其传递给一个用户定义的函数后不再访问它，才能将移动迭代器传递给算法</strong></li><li><strong>在移动构造函数与移动赋值运算符这些类实现代码之外的地方，只有确定需要进行移动操作且移动操作是安全的，才可以使用 std::move</strong></li></ul><h2 id="右值引用和成员函数"><a href="#右值引用和成员函数" class="headerlink" title="右值引用和成员函数"></a>右值引用和成员函数</h2><ul><li>一个成员函数也可以同时提供拷贝和移动两个版本<ul><li>一个版本接受一个指向 const 的左值引用 <code>const T&amp;</code></li><li>一个版本接受一个指向非 const 的右值引用 <code>T &amp;&amp;</code></li></ul></li></ul><h3 id="StrVec-的两个版本的-push-back"><a href="#StrVec-的两个版本的-push-back" class="headerlink" title="StrVec 的两个版本的 push_back"></a>StrVec 的两个版本的 push_back</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str)</span> </span>&#123;<br>    <span class="hljs-built_in">chk_n_alloc</span>();  <span class="hljs-comment">// 确保有足够空间容纳新元素</span><br>    <span class="hljs-comment">// 在 first_free 指向的内存中构造 str 的副本</span><br>    alloc.<span class="hljs-built_in">construct</span>(first_free++, str);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::push_back</span><span class="hljs-params">(std::string &amp;&amp; str)</span> </span>&#123;<br>    <span class="hljs-built_in">chk_n_alloc</span>();<br>    alloc.<span class="hljs-built_in">construct</span>(first_free++, std::<span class="hljs-built_in">move</span>(str));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="右值和左值引用成员函数"><a href="#右值和左值引用成员函数" class="headerlink" title="右值和左值引用成员函数"></a>右值和左值引用成员函数</h3><ul><li>c++ 标准中，允许向右值进行赋值</li><li>可以<strong>强制左侧运算对象(即 this 指向的对象) 是一个左值，或右值</strong></li><li><p>指出 this 对象的左值/右值属性的方法与定义 const 成员函数相同：<strong>在参数列表后放置运一个引用限定符(reference qualifier)</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    Foo &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo &amp;) &amp;;   <span class="hljs-comment">// 只能向可修改的左值赋值</span><br>&#125;;<br><br>Foo &amp; Foo::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Foo &amp; rhs) &amp; &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用限定符可以是 <strong><code>&amp;</code> 或 <code>&amp;&amp;</code></strong>, 分别指出 this 可以指向一个左值或右值</p></li><li><strong>类似于 const 限定符，引用限定符只能用于(非 static)成员函数，且必须同时出现在函数的声明和定义中</strong></li><li>一个成员函数可以<strong>同时有 const 限定和 &amp; 限定</strong>，<strong>引用限定必须跟在 const 限定符之后</strong></li></ul><h3 id="重载和引用函数"><a href="#重载和引用函数" class="headerlink" title="重载和引用函数"></a>重载和引用函数</h3><ul><li>与 const 限定符一样，<strong>一个成员函数可以根据引用限定符来重载成员函数版本</strong></li><li>还可以<strong>综合使用 const 和 &amp; 来重载成员函数</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> &amp;&amp;</span>;<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp;</span>;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data;<br>&#125;;<br><br><span class="hljs-comment">// 本对象为右值，因此可以原址排序</span><br><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> &amp;&amp; </span>&#123;<br>  <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 本对象是 const 或是左值，都不能对其进行原址排序</span><br><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &amp; </span>&#123;<br>  <span class="hljs-function">Foo <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;   <span class="hljs-comment">// 拷贝一个副本</span><br>  <span class="hljs-built_in">sort</span>(ret.data.<span class="hljs-built_in">begin</span>(), ret.data.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对右值执行 sorted 时，可以安全的直接对 data 成员进行排序。右值意味着对象没有其他用户，因此可以改变对象</li><li>当对一个 const 右值或一个左值执行 sorted 时，不能改变对象，因此需要再排序前拷贝 data</li><li>当定义 <strong>const 成员函数</strong>时，可以有两个版本，<strong>唯一区别就是一个有 const 限定符，一个没有</strong></li><li><strong>如果一个成员函数有引用限定符，则具有相同参数列表的其他所有版本都必须有引用限定符</strong>，即 对于重载成员函数，要么都加引用限定符，要么都不加</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 右值引用 </tag>
            
            <tag> 移动构造函数 </tag>
            
            <tag> 移动赋值运算符 </tag>
            
            <tag> std::move </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.1 拷贝、赋值与销毁</title>
      <link href="/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.1%20%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81/"/>
      <url>/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.1%20%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>一个类通过定义五种特殊的成员函数来控制此类型的对象在拷贝、赋值、移动和销毁时做什么<ul><li><strong>拷贝构造函数 (copy constructor)</strong></li><li><strong>拷贝赋值运算符 (copy-assignment operator)</strong></li><li><strong>移动构造函数 (move constructor)</strong></li><li><strong>移动赋值运算符 (move-assignment operator)</strong></li><li><strong>析构函数 (destructor)</strong></li></ul></li></ul><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><ul><li>一个构造函数的<strong>第一个参数是自身类型的引用</strong>，且<strong>其他额外参数都有默认值</strong>，则这个构造函数就是拷贝构造函数</li><li>拷贝构造函数<strong>通常不应该是 explicit</strong></li></ul><h3 id="合成拷贝构造函数-synthesized-copy-constructor"><a href="#合成拷贝构造函数-synthesized-copy-constructor" class="headerlink" title="合成拷贝构造函数(synthesized copy constructor)"></a>合成拷贝构造函数(synthesized copy constructor)</h3><ul><li>一旦定义了一个构造函数，编译器就不会合成 <strong>synthesized default constructor</strong></li><li>但是，<strong>即使定义了其他构造函数，编译器还是会合成一个 synthesized copy constructor</strong></li><li>编译器从给定对象中依次将非 static 成员拷贝到正在创建的对象中</li><li>每个成员的类型决定了它将如何拷贝：<ul><li><strong>类类型成员</strong>：使用其拷贝构造函数来拷贝</li><li><strong>内置类型成员</strong>：直接拷贝</li><li><strong>不能直接拷贝数组</strong>，但 synthesized copy constructor 会<strong>逐元素地拷贝一个数组类型成员</strong>，如果数组元素是类类型，则使用元素的拷贝构造函数进行拷贝</li></ul></li><li>合成拷贝构造函数可以用来禁止该类型对象的拷贝</li></ul><h3 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h3><ul><li>直接初始化与拷贝初始化的区别<ul><li><strong>拷贝初始化(copy initialization)</strong>：<strong>使用 <code>=</code></strong> 来初始化一个变量</li><li><strong>直接初始化(direct initialization)</strong>：<strong>不使用 <code>=</code></strong> 来初始化变量</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">dots</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;.&#x27;</span>)</span></span>;               <span class="hljs-comment">// 直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(dots)</span></span>;                     <span class="hljs-comment">// 直接初始化</span><br><br>string s2 = dots;                   <span class="hljs-comment">// 拷贝初始化</span><br>string null_book = <span class="hljs-string">&quot;9999-8888-88&quot;</span>;  <span class="hljs-comment">// 拷贝初始化</span><br>string nines = <span class="hljs-built_in">string</span>(<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;9&#x27;</span>);    <span class="hljs-comment">// 拷贝初始化</span><br></code></pre></td></tr></table></figure><ul><li>直接初始化要求编译器<strong>使用函数匹配</strong>选择一个与所提供参数最匹配的构造函数</li><li>拷贝初始化要求编译器<strong>将右侧运算对象拷贝到正在创建的对象中</strong>，还会<strong>按需进行类型转换</strong></li><li><strong>拷贝初始化</strong>不仅可以<strong>使用拷贝构造函数</strong>，还可以<strong>使用移动构造函数</strong></li><li>拷贝初始化不仅在使用 <code>=</code> 定义变量时发生，以下情况也可能发生<ul><li>将一个对象作为实参<strong>传递给一个非引用类型的形参</strong></li><li><strong>从一个返回类型为非引用类型的函数返回一个对象</strong></li><li>用<strong>花括号列表初始化一个数组中的元素或一个聚合类中的成员</strong></li></ul></li></ul><h3 id="参数值和返回值"><a href="#参数值和返回值" class="headerlink" title="参数值和返回值"></a>参数值和返回值</h3><ul><li>拷贝构造函数<strong>自身的参数必须是引用类型</strong>，它用来<strong>初始化非引用类型的对象</strong></li></ul><h3 id="拷贝初始化的限制"><a href="#拷贝初始化的限制" class="headerlink" title="拷贝初始化的限制"></a>拷贝初始化的限制</h3><ul><li>如果使用的<strong>初始化值要求通过 explicit 的构造函数来进行类型转换</strong>，那么就必须<strong>显式的使用 explicit 构造函数</strong></li></ul><h3 id="编译器可以绕过拷贝构造函数"><a href="#编译器可以绕过拷贝构造函数" class="headerlink" title="编译器可以绕过拷贝构造函数"></a>编译器可以绕过拷贝构造函数</h3><ul><li><p>在拷贝初始化的过程中，<strong>编译器可以跳过拷贝/移动构造函数</strong>，即，可以将下面代码：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string null_book = <span class="hljs-string">&quot;1111-2222&quot;</span>; <span class="hljs-comment">// 拷贝初始化</span><br></code></pre></td></tr></table></figure></li><li><p>改写为</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">null_book</span><span class="hljs-params">(<span class="hljs-string">&quot;1111-2222&quot;</span>)</span></span>;  <span class="hljs-comment">// 编译器略过了拷贝构造函数</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h2><ul><li>如果类未定义自己的拷贝赋值运算符，编译器就会合成一个</li></ul><h3 id="重载赋值运算符"><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h3><ul><li>重载运算符<strong>本质上是函数</strong>，名字由 operator 关键字后跟要定义的运算符的符号组成</li><li><strong>运算符函数也有参数类型和返回类型</strong></li><li>重载运算符的<strong>参数表示运算符的运算对象</strong><ul><li><strong>某些运算符必须定义为成员函数</strong></li><li>如果<strong>运算符是成员函数</strong>，<strong>其左侧的运算对象就绑定到隐式的 this 参数</strong></li><li>对于一个<strong>二元运算符</strong>，<strong>其右侧运算对象作为显式参数传递</strong></li></ul></li><li>赋值运算符<strong>接受一个与其所在类相同类型的参数</strong>，通常<strong>返回一个指向其左侧运算对象的引用</strong></li></ul><h3 id="合成拷贝赋值运算符-synthesized-copy-assignment-operator"><a href="#合成拷贝赋值运算符-synthesized-copy-assignment-operator" class="headerlink" title="合成拷贝赋值运算符(synthesized copy-assignment operator)"></a>合成拷贝赋值运算符(synthesized copy-assignment operator)</h3><ul><li>如果没有定义自己的拷贝赋值运算符，编译器会生成一个合成拷贝赋值运算符</li><li>作用：将右侧对象的每个 <strong>非 static 成员</strong>赋予左侧对象</li><li><strong>对于数组类型成员，逐个赋值数组元素</strong></li><li>合成拷贝赋值运算符可以用来禁止该类型对象的赋值</li></ul><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ul><li>析构函数释放对象使用的资源，并销毁对象的非 static 成员</li><li><strong>析构函数没有返回值，也不接受参数，因此不能被重载</strong></li></ul><h3 id="析构函数完成什么工作"><a href="#析构函数完成什么工作" class="headerlink" title="析构函数完成什么工作"></a>析构函数完成什么工作</h3><ul><li>在一个<strong>构造函数中</strong><ul><li><strong>首先进行成员初始化</strong>，按照它们在类中出现的顺序进行初始化</li><li><strong>然后执行函数体</strong></li></ul></li><li><strong>析构函数</strong>中<ul><li><strong>首先执行函数体</strong></li><li><strong>然后销毁成员</strong>，成员<strong>按初始化顺序的逆序</strong>进行销毁</li></ul></li><li>析构函数中析构部分是隐式的，成员销毁时发生什么完全依赖于成员的类型</li><li><strong>隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象</strong></li></ul><h3 id="什么时候调用析构函数"><a href="#什么时候调用析构函数" class="headerlink" title="什么时候调用析构函数"></a>什么时候调用析构函数</h3><ul><li>一个对象被销毁，就会调用其析构函数<ul><li>变量离开作用域时，其成员被销毁</li><li>一个对象被销毁时，成员被销毁</li><li>容器(无论是标准库容器还是数组) 被销毁时，其元素被销毁</li><li>对于动态分配的对象，当指向它的指针执行 delete 运算符时被销毁</li><li>对于临时对象，当创建它的完整表达式结束时被销毁</li></ul></li><li><strong>当指向一个对象的引用或指针离开作用域时，不会执行析构函数</strong></li></ul><h3 id="合成析构函数-synthesized-destructor"><a href="#合成析构函数-synthesized-destructor" class="headerlink" title="合成析构函数(synthesized destructor)"></a>合成析构函数(synthesized destructor)</h3><ul><li>合成析构函数可以用来组织该类型的对象被销毁</li></ul><h2 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h2><h3 id="需要自定义析构函数的类也需要自定义拷贝和赋值操作"><a href="#需要自定义析构函数的类也需要自定义拷贝和赋值操作" class="headerlink" title="需要自定义析构函数的类也需要自定义拷贝和赋值操作"></a>需要自定义析构函数的类也需要自定义拷贝和赋值操作</h3><h3 id="需要自定义拷贝操作的类也需要自定义赋值操作，反之亦然"><a href="#需要自定义拷贝操作的类也需要自定义赋值操作，反之亦然" class="headerlink" title="需要自定义拷贝操作的类也需要自定义赋值操作，反之亦然"></a>需要自定义拷贝操作的类也需要自定义赋值操作，反之亦然</h3><h2 id="使用-default"><a href="#使用-default" class="headerlink" title="使用 =default"></a>使用 <code>=default</code></h2><ul><li>可以将拷贝控制成员定义为 <code>=default</code> 来显式的要求编译器生成合成的版本</li><li><strong>只能对具有合成版本的成员函数使用 <code>=default</code></strong>（即默认构造函数或拷贝控制成员）</li></ul><h2 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h2><ul><li>对于某些类来说，<strong>拷贝构造函数和拷贝赋值运算符没有意义</strong>，但是<strong>即使不定义，编译器还是会自动生成合成版本</strong>，此时就需要阻止拷贝或赋值</li></ul><h3 id="定义删除的函数"><a href="#定义删除的函数" class="headerlink" title="定义删除的函数"></a>定义删除的函数</h3><ul><li>通过将拷贝构造函数和拷贝赋值运算符定义为<strong>删除的函数(deleted function)</strong> 来阻止拷贝</li><li><strong>删除的函数(deleted function):</strong><ul><li><strong>虽然声明了函数，但是不能以任何方式使用它</strong></li><li>在函数参数列表后加上 <strong><code>=delete</code></strong> 指明函数被定义为 deleted function</li></ul></li><li>与 <code>=default</code> 不同， <strong><code>=delete</code> 必须出现在函数第一次声明的时候</strong><ul><li><strong><code>=default</code> 直到编译器生成代码时才需要</strong></li><li><code>=delete</code> 编译器需要直到一个函数是被删除的，以便禁止试图使用它的操作</li></ul></li><li><strong>可以对任何函数使用 <code>=delete</code></strong>，而只<strong>能对编译器可以合成的默认构造函数或拷贝控制成员使用 <code>=default</code></strong></li></ul><h3 id="析构函数不能是-deleted-function"><a href="#析构函数不能是-deleted-function" class="headerlink" title="析构函数不能是 deleted function"></a>析构函数不能是 deleted function</h3><ul><li>删除析构函数，就无法销毁此类型的对象</li><li>对于<strong>析构函数已经删除</strong>的类型<ul><li><strong>不能定义该类型的变量</strong></li><li><strong>不能释放指向该类型动态分配对象的指针</strong></li></ul></li></ul><h3 id="合成的拷贝控制成员可能是删除的"><a href="#合成的拷贝控制成员可能是删除的" class="headerlink" title="合成的拷贝控制成员可能是删除的"></a>合成的拷贝控制成员可能是删除的</h3><ul><li><p><strong>类的 synthesized destructor</strong> 被定义为 <strong>deleted function</strong></p><ul><li>如果类的<strong>某个成员的 destructor</strong> 是 deleted function 或是不可访问的 (例如是  private)</li></ul></li><li><p><strong>类的 synthesized copy constructor</strong> 被定义为 <strong>deleted function</strong></p><ul><li>如果类的 <strong>某个成员的 copy constructor</strong> 是 deleted function 或是不可访问的</li><li>如果类的 <strong>某个成员的 destructor</strong> 是 deleted function 或是不可访问的</li></ul></li><li><p><strong>类的 synthesized copy-assignment operator</strong> 被定义为 deleted function</p><ul><li>如果类的 <strong>某个成员的 copy-assignment operator</strong> 是 deleted function 或是不可访问的</li><li>或是<strong>类有 const 成员或引用成员</strong></li></ul></li><li><p><strong>类的 default constructor</strong> 被定义为 <strong>deleted function</strong></p><ul><li>如果类的<strong>某个成员的 destructor</strong> 是 deleted function 或是不可访问的</li><li>或是<strong>类有一个引用成员</strong>，它<strong>没有类内初始化器</strong></li><li>或是<strong>类有一个 const 成员</strong>，它<strong>没有类内初始化器</strong>，<strong>且其类型未显式定义 default constructor</strong></li></ul></li></ul><p><strong><em>本质上，这些规则的含义是：如果一个类有数据成员不能被默认构造、拷贝、赋值、销毁，则对应的成员函数将被定义为 deleted function</em></strong></p><h3 id="private-拷贝控制"><a href="#private-拷贝控制" class="headerlink" title="private 拷贝控制"></a>private 拷贝控制</h3><ul><li>新标准之前，<strong>将拷贝构造函数和拷贝赋值运算符声明为 private 来阻止拷贝</strong><ul><li>将拷贝控制成员声明为 private，<strong>用户代码将不能拷贝这个对象</strong></li><li>将拷贝控制成员声明为 private，但<strong>不定义它们</strong>，将<strong>阻止其他成员函数和友元函数进行拷贝</strong></li></ul></li><li><strong>试图拷贝对象的用户代码</strong>将在<strong>编译阶段被标记为错误</strong></li><li><strong>成员函数或友元函数的拷贝操作</strong>会<strong>导致链接时错误</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 拷贝构造函数 </tag>
            
            <tag> 拷贝赋值运算符 </tag>
            
            <tag> 析构函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.2 拷贝控制与资源管理</title>
      <link href="/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.2%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.2%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>通常，<strong>管理类外资源的类必须定义拷贝控制成员和析构函数</strong></li><li><strong>类外资源</strong>：例如通过 new 分配的动态内存、打开的文件句柄、socket、数据库连接等<ul><li>这些资源不由编译器自动管理，需要显式的申请和释放</li><li>默认的浅拷贝会出问题<ul><li>拷贝构造：新对象会把指针或句柄值直接拷贝过来，使得两个对象指向同一内存区域或同一个文件句柄</li><li>析构：两个对象各自析构都会尝试释放指向的内存区域，<strong>造成重复释放内存</strong>的未定义行为</li></ul></li></ul></li><li><strong>定义拷贝操作</strong>，使<strong>类的行为</strong>看起来<strong>像一个值</strong>或者<strong>像一个指针</strong><ul><li>类的行为<strong>像一个值</strong>：<strong>副本与原对象完全独立</strong>，改变副本不会影响原对象。类似于标准库中的 string</li><li>类的行为<strong>像一个指针</strong>：<strong>副本与原对象共用相同的底层数据</strong>，改变副本也会改变原对象。类似于标准库中的 shared_ptr</li></ul></li></ul><h2 id="定义行为像值的类"><a href="#定义行为像值的类" class="headerlink" title="定义行为像值的类"></a>定义行为像值的类</h2><h3 id="类值拷贝赋值运算符"><a href="#类值拷贝赋值运算符" class="headerlink" title="类值拷贝赋值运算符"></a>类值拷贝赋值运算符</h3><ul><li><strong>拷贝赋值运算符通常组合和析构函数和拷贝构造函数的操作</strong><ul><li>类似析构函数，<strong>赋值操作会销毁左侧运算对象的资源</strong></li><li>类似拷贝构造函数，<strong>赋值操作会从右侧运算对象拷贝数据</strong></li></ul></li><li>编写赋值运算符要注意：<ul><li><strong>如果将一个对象赋予它自身，赋值运算符必须能正常工作</strong></li><li>大多数赋值运算符组合了析构函数和拷贝构造函数的操作</li></ul></li><li>编写赋值运算符时，<strong>先将右侧运算对象拷贝到一个局部临时对象中</strong>，这样当拷贝完成后，<strong>销毁左侧运算对象的现有成员就是安全的</strong>。一旦左侧运算对象的资源被销毁，就可以将临时对象拷贝到左侧运算对象的成员中</li><li><p>下面写法是不安全的：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">HasPtr &amp; HasPtr::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HasPtr&amp; rhs) &#123;<br>    <span class="hljs-keyword">delete</span> ps;<br>    <span class="hljs-comment">// 如果 rhs 对象和 *this 对象是同一对象，下面代码将从已经释放的内存中拷贝数据</span><br>    ps = <span class="hljs-keyword">new</span> std::<span class="hljs-built_in">string</span>(*rhs.ps);<br>    i = rhs.i;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="定义行为像指针的类"><a href="#定义行为像指针的类" class="headerlink" title="定义行为像指针的类"></a>定义行为像指针的类</h2><ul><li>令一个类展现类似指针行为的最好方法是使用 shared_ptr 管理类中的资源</li><li>如果想要直接管理资源，可以使用<strong>引用计数(reference count)</strong></li></ul><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ul><li>工作方式：<ul><li><strong>每个构造函数（拷贝构造函数除外）：除了初始化对象外，都要创建一个引用计数</strong>，用来记录有多少对象与正在创建的对象共享资源</li><li><strong>拷贝构造函数：不分配新的计数器</strong>，<strong>只拷贝给定对象的数据成员，包括计数器</strong>，拷贝构造函数递增计数器</li><li><strong>析构函数：递减计数器</strong>。如果<strong>计数器值变为 0，析构函数释放资源</strong></li><li><strong>拷贝赋值运算符：递增右侧对象的引用计数，递减左侧对象的引用计数。</strong></li></ul></li><li>如何更新计数器：<ul><li>一种方法是<strong>将计数器保存到动态分配的内存中</strong><ul><li>当<strong>创建一个对象时，分配一个计数器</strong>。</li><li><strong>拷贝或赋值对象时，拷贝指向计数器的指针</strong></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 引用计数 </tag>
            
            <tag> 拷贝控制 </tag>
            
            <tag> 资源管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.3 交换操作</title>
      <link href="/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.3%20%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.3%20%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>管理资源的类通常还定义一个名为 <strong>swap</strong> 的函数</li><li>如果类定义了自己的 swap，那么算法将使用自定义版本。否则算法将使用标准库定义的 swap</li><li>使用 swap 交换指针比交换数据值性能更好</li></ul><h2 id="定义一个-swap-函数"><a href="#定义一个-swap-函数" class="headerlink" title="定义一个 swap 函数"></a>定义一个 swap 函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtr2</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr2 &amp;, HasPtr2 &amp;)</span></span>;<br>    <span class="hljs-comment">// 其他成员</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(HasPtr2 &amp;lhs, HasPtr2 &amp;rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>    <span class="hljs-built_in">swap</span>(lhs.ps2, rhs.ps2);     <span class="hljs-comment">// 交换指针，而不是 string 数据</span><br>    <span class="hljs-built_in">swap</span>(lhs.i2, rhs.i2);       <span class="hljs-comment">// 交换 i 数据</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>由于要交换的数据是内置类型，所以使用 std::swap</strong></li><li><strong>若要交换的数据是其他类类型，那么必须为这个类型定义自己的 swap 版本</strong></li></ul><h2 id="在赋值运算符中使用-swap"><a href="#在赋值运算符中使用-swap" class="headerlink" title="在赋值运算符中使用 swap"></a>在赋值运算符中使用 swap</h2><ul><li>定义了 swap 的类通常使用 swap 来定义它们的赋值运算符，运算符使用了<strong>拷贝并交换 (copy and swap) 技术</strong>：<strong>将左侧对象与右侧对象的一个副本进行交换</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 注意 rhs 按值传递，</span><br><span class="hljs-comment">// 意味着 HasPtr 的拷贝构造函数将右侧运算对象中的 string 拷贝到 rhs</span><br>HasPtr &amp; HasPtr::<span class="hljs-keyword">operator</span>=(HasPtr rhs) &#123;<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>rhs 是右侧运算对象的一个拷贝</li><li>调用 swap 来交换 rhs 和 <em>this 中的数据成员。这个**调用将左侧运算对象(</em>this)中原来保存的指针成员存入 rhs 中<strong>，并</strong>将 rhs 中的指针存入 <em>this 中*</em></li><li>swap 调用结束，<strong>*this 中的指针成员指向一个新分配的 string（右侧运算对象中 string 的一个拷贝）</strong></li><li>函数返回 *this 之后，销毁 rhs，执行 HasPtr 的析构函数，释放 rhs 指向的内存</li><li><strong>使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值</strong><ul><li>首先拷贝了右侧运算对象保证了自赋值的正确性</li><li>代码中唯一可能出现异常的地方是拷贝构造函数中的 new 表达式，即使真的发生了异常，也是在改变左侧运算符之前发生的</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 交换操作 </tag>
            
            <tag> 拷贝并交换技术 </tag>
            
            <tag> 定义 swap 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.4 拷贝控制示例</title>
      <link href="/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.4%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E7%A4%BA%E4%BE%8B/"/>
      <url>/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.4%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ul><li>定义两个类命名为 <strong>Message</strong> 和 <strong>Folder</strong>，分别表示<strong>电子邮件消息</strong>和<strong>消息目录</strong></li><li>每个 Message 可以出现在多个 Folder 中，但是任意给定 Message 的内容只有一个副本</li><li>如果一条 Message 内容被改变，则从它所在的任何 Folder 中浏览此 Message 都会看到改变后的内容</li><li>为了记录 Message 位于哪些 Folder 中，每个 Message 保存它所在 Folder 的指针 set</li><li>每个 Folder 保存它拥有的 Message 的指针的 set</li></ul><h2 id="Message-类"><a href="#Message-类" class="headerlink" title="Message 类"></a>Message 类</h2><ul><li>Message 提供 save 和 remove 操作：来向一个 Folder 添加一条 Message 或从 Folder 中删除一条 Message</li><li>为了<strong>创建一个新的 Message</strong>，会指明消息内容，但不会指出 Folder。将一条 Message 放入 Folder 中，必须调用 save</li><li><strong>拷贝一个 Message</strong> 时，副本和原对象将是不同的对象，但两个 Message 都出现在同一个 Folder 中，因此<strong>拷贝 Message 的操作包括拷贝 Message 内容和 Folder 指针 set 的拷贝</strong>，<strong>而且必须在每个包含此消息的 Folder 中都添加一个指向新创建的 Message 的指针</strong></li><li><strong>销毁一个 Message</strong> 时，必须从包含此消息的所有 Folder 中删除指向此条 Message 的指针</li><li><strong>将一个 Message 对象赋予另一个 Message 对象</strong>，左侧 Message 的内容将被右侧 Message 取代。还必须更新 Folder 集合，从原来包含左侧 Message 的 Folder 中将它删除，并将它添加到包含右侧 Message 的 Folder 中</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Folder</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Folder</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// folders 被隐式初始化为空集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Message</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str = <span class="hljs-string">&quot;&quot;</span>)</span> : contents(str) &#123;</span> &#125;<br>    <span class="hljs-comment">// 拷贝控制成员，用来管理指向本 Message 的指针</span><br>    <span class="hljs-built_in">Message</span>(<span class="hljs-type">const</span> Message &amp;);<br>    Message &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Message &amp;);<br>    ~<span class="hljs-built_in">Message</span>();<br>    <span class="hljs-comment">// 从给定 Folder 集合中添加或删除本条 Message</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Folder &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Folder &amp;)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 拷贝构造函数、拷贝赋值运算符、析构函数中所使用的工具函数</span><br>    <span class="hljs-comment">//将 Message 添加到指向参数的 Folder 中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_Folders</span><span class="hljs-params">(<span class="hljs-type">const</span> Message &amp;)</span></span>;<br>    <span class="hljs-comment">// 从 Folders 中的每个 Folder 中删除本条 Message</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_from_Folders</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    std::string contents;       <span class="hljs-comment">// 实际消息内容</span><br>    std::set&lt;Folder*&gt; folders;      <span class="hljs-comment">// 包含本条 Message 的 Folder</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Message-的-save-和-remove-成员"><a href="#Message-的-save-和-remove-成员" class="headerlink" title="Message 的 save 和 remove 成员"></a>Message 的 save 和 remove 成员</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Message::save</span><span class="hljs-params">(Folder &amp; f)</span> </span>&#123;<br>    <span class="hljs-comment">// 将给定的 Folder 添加到本 Message 的 folders 列表中</span><br>    folders.<span class="hljs-built_in">insert</span>(&amp;f);<br>    <span class="hljs-comment">// 将本 Message 添加到f 的 Message 集合中</span><br>    f.<span class="hljs-built_in">addMsg</span>(*<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Message::remove</span><span class="hljs-params">(Folder &amp;f)</span> </span>&#123;<br>    <span class="hljs-comment">// 从 folders 列表中删除给定 f</span><br>    folders.<span class="hljs-built_in">erase</span>(&amp;f);<br>    <span class="hljs-comment">// 从 f 的 Message 集合中删除本 Message</span><br>    f.<span class="hljs-built_in">remMsg</span>(*<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Message-的拷贝控制成员"><a href="#Message-的拷贝控制成员" class="headerlink" title="Message 的拷贝控制成员"></a>Message 的拷贝控制成员</h3><ul><li><strong>拷贝 Message 时，得到的副本应该与原 Message 在相同的 Folder 中</strong>，因此必须遍历 Message 中存储的 Folder 指针的 set，对每个指向原 Message 的 Folder 添加一个指向新 Message 的指针</li><li>拷贝构造函数与拷贝赋值运算符都需要这个操作，将它定义为一个工具函数</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Message::add_to_Folders</span><span class="hljs-params">(<span class="hljs-type">const</span> Message &amp; m)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : m.folders) &#123;<br>        f-&gt;<span class="hljs-built_in">addMsg</span>(*<span class="hljs-keyword">this</span>);       <span class="hljs-comment">// 向每个包含 m 的 Folder 添加指向本 Message 的指针</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Message::<span class="hljs-built_in">Message</span>(<span class="hljs-type">const</span> Message &amp; m) :<br>        <span class="hljs-built_in">contents</span>(m.contents), <span class="hljs-built_in">folders</span>(m.folders) &#123;<br>    <span class="hljs-built_in">add_to_Folders</span>(m);      <span class="hljs-comment">// 将本 Message 添加到所有包含 m 的 Folder 中</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Message-的析构函数"><a href="#Message-的析构函数" class="headerlink" title="Message 的析构函数"></a>Message 的析构函数</h3><ul><li>当一个 Message 被销毁时，<strong>必须从保存指向此 Message 指针的 Folder 中删除这个 Message 指针</strong>，这需要遍历当前 Message 的 folders 序列，对每个 Folder 执行删除 Message 指针操作。析构函数与拷贝赋值运算符都需要这个操作，因此定义为工具函数</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 从对应的 Folder 中删除指向本 Message 的指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Message::remove_from_Folders</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : folders) &#123;    <span class="hljs-comment">// 对 folders 中的每个指针</span><br>        f-&gt;<span class="hljs-built_in">remMsg</span>(*<span class="hljs-keyword">this</span>);       <span class="hljs-comment">// 从该 Folder 中删除指向本 Message 的指针</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Message::~<span class="hljs-built_in">Message</span>() &#123;<br>    <span class="hljs-built_in">remove_from_Folders</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Message-的拷贝赋值运算符"><a href="#Message-的拷贝赋值运算符" class="headerlink" title="Message 的拷贝赋值运算符"></a>Message 的拷贝赋值运算符</h3><ul><li><strong>拷贝赋值运算符</strong>必须执行<strong>析构函数</strong>和<strong>拷贝构造函数</strong>的工作</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Message &amp; Message::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Message &amp;rhs) &#123;<br>    <span class="hljs-built_in">remove_from_Folders</span>();  <span class="hljs-comment">// 从包含左侧运算对象的 Folder 中删除指向左侧 Message 的指针</span><br>    contents = rhs.contents;    <span class="hljs-comment">// 拷贝右侧 Message 的内容</span><br>    folders = rhs.folders;      <span class="hljs-comment">// 拷贝右侧 Message 的 folders 集合</span><br>    <span class="hljs-built_in">add_to_Folders</span>(rhs);    <span class="hljs-comment">// 向每个包含 rhs 的 Folder 添加指向本 Message 的指针</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>add_to_Folders 必须在 remove_from_Folders 之后执行<ul><li>原因：如果左侧运算对象与右侧运算对象是相同的 Message (<strong>自赋值情况</strong>)，则它们具有相同的地址，<strong>如果在 add_to_Folders 之后调用 remove_from_Folders ，就会将此 Message 从它所在的所有 Folder 中删除（Folder 中保存 Message 指针的方式是 set）</strong></li></ul></li></ul><h3 id="Message-的-swap-函数"><a href="#Message-的-swap-函数" class="headerlink" title="Message 的 swap 函数"></a>Message 的 swap 函数</h3><ul><li>通过定义一个 Message 自定义版本的 swap，可以避免对 contents 和 folders 成员进行不必要的拷贝</li><li>swap 函数必须管理<strong>指向被交换 Message 的 Folder 指针</strong>。在调用 swap(m1, m2) 后，原来保存 m1 的 Folder 必须保存 m2, 反之亦然</li><li>通过两边扫描 folders 中的元素来正确处理 Folder 指针。<ul><li>第一遍扫描，将 Message 从它们所在的 Folder 中删除</li><li>然后调用 swap 交换数据成员</li><li>第二遍扫描 folders 将交换过的 Message 添加到 Folder 中</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Message::swap</span><span class="hljs-params">(Message &amp;lhs, Message &amp;rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>    <span class="hljs-comment">// 将每个 Message 的指针从它原来所在的 Folder 中删除</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : lhs.folders) &#123;<br>        f-&gt;<span class="hljs-built_in">remMsg</span>(&amp;lhs);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : rhs.folders) &#123;<br>        f-&gt;<span class="hljs-built_in">remMsg</span>(&amp;rhs);<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(lhs.contents, rhs.contents);   <span class="hljs-comment">// 交换 message 内容, 使用 swap(string &amp;, string &amp;)</span><br>    <span class="hljs-built_in">swap</span>(lhs.folders, rhs.folders);     <span class="hljs-comment">// 交换 folders 元素，使用 swap(set&amp;, set&amp;)</span><br><br>    <span class="hljs-comment">// 将每个交换内容后的 Message 指针添加到它的新 Folder 中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : lhs.folders) &#123;<br>        f-&gt;<span class="hljs-built_in">addMsg</span>(&amp;lhs);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : rhs.folders) &#123;<br>        f-&gt;<span class="hljs-built_in">addMsg</span>(&amp;rhs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.5 动态内存管理类</title>
      <link href="/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.5%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB/"/>
      <url>/2025/04/18/13.%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/13.5%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>某些类需要再运行时分配内存，通常可以使用标准库容器来保存数据</li><li>但某些类需要自己进行内存分配，这些类一般必须自定义拷贝控制成员来管理所分配的内存</li></ul><h2 id="StrVec-类的设计"><a href="#StrVec-类的设计" class="headerlink" title="StrVec 类的设计"></a>StrVec 类的设计</h2><ul><li>简化版的只保存 string 的 vector，命名为 StrVec</li><li>vector 将其元素保存在连续内存中</li><li>vector 预先分配足够的内存来保存可能需要的更多元素，<strong>每个添加元素的成员函数必须检查是否有足够的空间存储更多元素</strong><ul><li>如果有空间，成员函数在下一个位置构造元素</li><li><strong>如果没有可用空间，vector 会重新分配内存空间</strong>：获得新的空间，将原有元素移动到新空间中，释放旧空间，并添加新元素</li></ul></li><li>类似的，<strong>在 StrVec 中使用 allocator 获得原始内存</strong>，添加新元素时使用 construct 成员在原始内存中创建对象，删除元素时使用 destroy 成员销毁元素</li><li><strong>StrVec 中有三个指针成员</strong>：<ul><li><strong>elements</strong>：指向分配的内存中的首元素</li><li><strong>first_free</strong>：指向最后一个实际元素之后的位置</li><li><strong>cap</strong>：指向分配的内存末尾之后的位置</li></ul></li><li>StrVec 有<strong>一个静态成员 alloc</strong>，类型是 <strong>allocator\<string></strong>, alloc 成员分配 StrVec 使用的内存</li><li><strong>四个工具函数</strong>：<ul><li><strong>alloc_n_copy</strong> ：分配内存，并拷贝一个给定范围中的元素</li><li><strong>free</strong> ：销毁构造的元素并释放内存</li><li><strong>chk_n_alloc</strong> ：保证 StrVec 至少有容纳一个新元素的空间。如果没有空间添加新元素，chk_n_alloc 会调用 reallocate 来分配更多内存</li><li><strong>reallocate</strong> ：在内存用完时，为 StrVec 分配新的内存</li></ul></li><li><strong>默认构造函数</strong>隐式的初始化 allocator 成员，显式地初始化三个指针成员为 nullptr ，表示没有元素</li><li><strong>size</strong> 成员返回当前真正在使用的元素数目，等于 first_free - elements</li><li><strong>capcity</strong> 成员返回 StrVec 能够保存的元素的数量，等于 cap - elements</li><li>当没有空间容纳新元素，chk_n_alloc 会分配新的内存</li><li><strong>begin</strong> 和 <strong>end</strong> 成员分别返回指向首元素(elements)与指向尾元素之后位置(first_free)的指针</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrVec</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StrVec</span>() :  <span class="hljs-comment">// allcator 成员进行默认初始化</span><br>            <span class="hljs-built_in">elements</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">first_free</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">cap</span>(<span class="hljs-literal">nullptr</span>) &#123; &#125;<br>    <span class="hljs-built_in">StrVec</span>(<span class="hljs-type">const</span> StrVec &amp;);     <span class="hljs-comment">// 拷贝构造函数</span><br>    StrVec &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> StrVec &amp;); <span class="hljs-comment">// 拷贝赋值运算符</span><br>    ~<span class="hljs-built_in">StrVec</span>();      <span class="hljs-comment">// 析构函数</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;)</span></span>;    <span class="hljs-comment">// 拷贝元素</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>  </span>&#123; <span class="hljs-keyword">return</span> first_free - elements; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cap - elements; &#125;<br>    <span class="hljs-function">std::string * <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> elements; &#125;<br>    <span class="hljs-function">std::string * <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> first_free; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> std::allocator&lt;std::string&gt; alloc;       <span class="hljs-comment">// 分配元素</span><br>    <span class="hljs-comment">// 被添加元素的成员所使用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chk_n_alloc</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">capacity</span>()) <span class="hljs-built_in">reallocate</span>(); &#125;<br>    <span class="hljs-comment">// 被拷贝构造函数、赋值运算符、析构函数使用</span><br>    <span class="hljs-function">std::pair&lt;std::string *, std::string *&gt; <span class="hljs-title">alloc_n_copy</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string *, <span class="hljs-type">const</span> std::string *)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 销毁元素并释放内存</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reallocate</span><span class="hljs-params">()</span></span>;      <span class="hljs-comment">// 获取更多内存空间并拷贝已有元素</span><br><span class="hljs-keyword">private</span>:<br>    std::string * elements;      <span class="hljs-comment">// 指向数组首元素</span><br>    std::string * first_free;   <span class="hljs-comment">// 指向最后一个实际元素之后的位置</span><br>    std::string * cap;      <span class="hljs-comment">// 指向分配内存末尾之后的位置</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用-construct"><a href="#使用-construct" class="headerlink" title="使用 construct"></a>使用 construct</h3><ul><li>push_back 调用 chk_n_alloc 确保有足够空间容纳新元素。</li><li><strong>allocator 分配内存，内存是未构造的</strong>。为了使用 allocator 分配的内存，必须调用 construct 构造对象，<strong>construct 第一个参数必须是一个指针，指向调用 allocate 分配的未构造的内存</strong>。<strong>剩余的参数用来确定使用哪个构造函数来构造对象</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str)</span> </span>&#123;<br>    <span class="hljs-built_in">chk_n_alloc</span>();  <span class="hljs-comment">// 确保有足够空间容纳新元素</span><br>    <span class="hljs-comment">// 在 first_free 指向的内存中构造 str 的副本</span><br>    alloc.<span class="hljs-built_in">construct</span>(first_free++, str);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="alloc-n-copy-成员"><a href="#alloc-n-copy-成员" class="headerlink" title="alloc_n_copy 成员"></a>alloc_n_copy 成员</h3><ul><li>在<strong>拷贝或赋值</strong> StrVec 时，它<strong>具有类值的行为</strong>，需要调用 alloc_n_copy 成员，分配独立内存，并从原 StrVec 对象中拷贝元素至新对象</li><li><strong>alloc_n_copy 返回一个指针的 pair 对象，该对象的两个指针成员分别指向新空间的开始位置和拷贝的尾后位置</strong></li><li>alloc_n_copy 用尾后指针-首元素指针，得到需要的空间大小。</li><li><strong>在返回语句中使用 uninitailized_copy 完成拷贝元素工作</strong>，对返回值进行了列表初始化，first 成员指向分配内存的开始位置，<strong>uninitialized_copy 的返回值是指向最后一个构造元素之后位置的指针</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::pair&lt;std::string *, std::string *&gt;</span><br><span class="hljs-function">        <span class="hljs-title">StrVec::alloc_n_copy</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string *b, <span class="hljs-type">const</span> std::string *e)</span> </span>&#123;<br>    <span class="hljs-comment">// 分配足够的内存空间保存给定范围内的元素</span><br>    <span class="hljs-keyword">auto</span> data = alloc.<span class="hljs-built_in">allocate</span>(e-b);<br>    <span class="hljs-comment">// 初始化并返回一个 pair, 该 pair 由 data 和 uninitialized_copy 的返回值构成</span><br>    <span class="hljs-keyword">return</span> &#123;data, std::<span class="hljs-built_in">uninitialized_copy</span>(b, e, data)&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="free-成员"><a href="#free-成员" class="headerlink" title="free 成员"></a>free 成员</h3><ul><li>free 成员的任务：<ul><li><strong>destroy 元素</strong></li><li><strong>释放 StrVec 自己分配的内存空间</strong></li></ul></li><li>for 循环调用 allocator 的 destroy 成员，从构造的尾元素开始，逆序销毁元素</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::free</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 不能传递给 deallocate 一个空指针，如果 elements 为空，函数什么也不做</span><br>    <span class="hljs-keyword">if</span> (elements) &#123;<br>        <span class="hljs-comment">// 逆序销毁元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = first_free; p != elements; )<br>            alloc.<span class="hljs-built_in">destroy</span>(--p);<br>        alloc.<span class="hljs-built_in">deallocate</span>(elements, cap - elements);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>destroy 函数会调用 string 的析构函数，<strong>string 的析构函数会释放 string 自己分配的内存空间</strong></li><li>元素被销毁之后<strong>调用 deallocate 释放本 StrVec 对象分配的内存空间</strong></li><li><strong>传递给 deallocate 的指针必须是之前某次 allocate 返回的指针</strong>，因此<strong>调用 deallocate 之前必须检查 elements 是否为空</strong></li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec::~<span class="hljs-built_in">StrVec</span>() &#123;<br>    <span class="hljs-built_in">free</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝控制成员"><a href="#拷贝控制成员" class="headerlink" title="拷贝控制成员"></a>拷贝控制成员</h3><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec::<span class="hljs-built_in">StrVec</span>(<span class="hljs-type">const</span> StrVec &amp;rhs) &#123;<br>    <span class="hljs-comment">// 调用 alloc_n_copy 分配空间，以容纳与 rhs 中一样多的元素并进行元素的拷贝</span><br>    <span class="hljs-keyword">auto</span> newData = <span class="hljs-built_in">alloc_n_copy</span>(rhs.<span class="hljs-built_in">begin</span>(), rhs.<span class="hljs-built_in">end</span>());<br>    elements = newData.first;<br>    first_free = cap = newData.second;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用 alloc_n_copy 分配空间，并<strong>将返回结果赋值数据成员</strong></li><li>由于 alloc_n_copy 分配的内存空间恰好容纳给定的元素，所以cap 也指向最后一个元素之后的位置</li></ul><h4 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h4><ul><li>赋值运算符在<strong>释放已有元素之前先调用 alloc_n_copy</strong>，<strong>确保了自赋值的正确性</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">StrVec &amp; StrVec::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> StrVec &amp;rhs) &#123;<br>    <span class="hljs-comment">// 调用 alloc_n_copy 分配内存，大小与 rhs 中元素所占空间一样多</span><br>    <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">alloc_n_copy</span>(rhs.<span class="hljs-built_in">begin</span>(), rhs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">free</span>();<br>    elements = data.first;<br>    first_free = cap = data.second;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在重新分配内存的过程中移动元素而不是拷贝元素"><a href="#在重新分配内存的过程中移动元素而不是拷贝元素" class="headerlink" title="在重新分配内存的过程中移动元素而不是拷贝元素"></a>在重新分配内存的过程中移动元素而不是拷贝元素</h3><ul><li><strong>reallocate</strong> 成员需要完成的工作<ul><li>为一个新的、更大的 string 数组分配内存空间</li><li>在分配的内存空间中的前半部分构造对象，保存原有元素</li><li>销毁原内存空间中的元素，并释放这块内存</li></ul></li><li>string 具有类值行为，当拷贝 string 元素之后，新 string 与原 string 是两个独立对象，就会有两个用户</li><li>而 <strong>reallocate 成员拷贝 StrVec 中的 string，从逻辑上看，只需要一个用户，一旦将原 string 拷贝到新空间之后，会立即销毁原 string</strong></li><li><strong>reallocate 中拷贝 string 的动作是多余的</strong>，如果能避免分配和释放 string 的开销，就会提高性能</li></ul><h4 id="移动构造函数与-std-move"><a href="#移动构造函数与-std-move" class="headerlink" title="移动构造函数与 std::move"></a>移动构造函数与 std::move</h4><ul><li>标准库中有两种机制可以避免 string 的拷贝<ul><li><strong>移动构造函数</strong>：将资源从给定对象<strong>移动而不是拷贝到正在创建的对象</strong>，<strong>移后源(moved-from)</strong> string 仍然保持有效的、可析构的状态</li><li><strong>move 标准库函数</strong>：定义在 utility 头文件中<ul><li>reallocate 在新内存中构造 string 时必须<strong>使用 move 来表示希望使用 string 的移动构造函数</strong>。<strong>如果没有使用 move，将使用 string 的拷贝构造函数</strong></li><li><strong>通常不为 move 提供一个 using 声明，使用 move 时，直接调用 <code>std::move</code></strong></li></ul></li></ul></li></ul><h4 id="reallocate-成员"><a href="#reallocate-成员" class="headerlink" title="reallocate 成员"></a>reallocate 成员</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::reallocate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分配两倍于当前大小的内存空间</span><br>    <span class="hljs-keyword">auto</span> newCapacity = <span class="hljs-built_in">size</span>() ? <span class="hljs-number">2</span> * <span class="hljs-built_in">size</span>() : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 分配新内存</span><br>    <span class="hljs-keyword">auto</span> newData = alloc.<span class="hljs-built_in">allocate</span>(newCapacity);<br>    <span class="hljs-comment">// 将数据从旧内存移动到新内存</span><br>    <span class="hljs-keyword">auto</span> dest = newData;    <span class="hljs-comment">// 指向新数组中的下一个空闲位置</span><br>    <span class="hljs-keyword">auto</span> elem = elements;   <span class="hljs-comment">// 指向旧数组中的下一个元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-built_in">size</span>(); ++i )<br>        alloc.<span class="hljs-built_in">construct</span>(dest++, std::<span class="hljs-built_in">move</span>(*elem++));<br>    <span class="hljs-comment">// 一旦完成移动，就释放旧内存空间</span><br>    <span class="hljs-built_in">free</span>();<br>    <span class="hljs-comment">// 更新数据结构</span><br>    elements = newData;<br>    first_free = dest;<br>    cap = newData + newCapacity;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用<strong>后置递增运算符</strong>将 dest 和 elem 推进到各自数组的下一个元素</li><li><strong>construct 的第二个参数是 move 返回的值</strong>。调用 move 的返回结果会令 construct 使用 string 的移动构造函数，这些 <strong>string 管理的内存将不会被拷贝。构造的每个 string 都会从 elem 指向的 string 那里接管内存的所有权</strong></li></ul><h2 id="Note-And-Question"><a href="#Note-And-Question" class="headerlink" title="Note And Question"></a>Note And Question</h2><blockquote><ol><li><p>头文件中声明有 static 成员，在 .cpp 文件也要定义一遍，避免出现链接错误</p></li><li><p>接受 initializer_list 的构造函数如果是下面这种形式，则无法接受右值 <code>(StrVec sv&#123;&quot;a&quot;, &quot;b&quot;&#125;)</code>，会报错，可以改成后面两种形式</p><ul><li>写法 1: <code>StrVec(std::initializer_list&lt;std::string&gt;&amp; il)</code>; // ❌ 不推荐：不能接受右值</li><li>写法 2: <code>StrVec(std::initializer_list&lt;std::string&gt; il)</code>;  // ✅ 推荐：支持左值和右值</li><li>写法 3: <code>const StrVec(std::initializer_list&lt;std::string&gt; &amp;il)</code>;  // ✅ 推荐</li></ul></li><li>拷贝赋值运算符在实现时推荐使用 copy-swap 技术，保证异常安全和自赋值正确</li><li>使用 shared_ptr 管理的数据成员，必须在其定义时进行值初始化或者直接初始化</li><li>for_each 在 lambda 表达式中传递的是元素本身，而不是迭代器（指针）</li><li><strong>在 lambda 中访问类成员（包括静态成员）时</strong>，非静态成员必须捕获 this，静态成员可以写成 StrVec::alloc 或者通过捕获 this 然后 this-&gt;alloc</li></ol></blockquote><h2 id="简化版的-string-类"><a href="#简化版的-string-类" class="headerlink" title="简化版的 string 类"></a>简化版的 string 类</h2><h3 id="String-h-文件"><a href="#String-h-文件" class="headerlink" title="String.h 文件"></a>String.h 文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">/* 简化的 String 类*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(String &amp;, String &amp;)</span></span>;<br>    <span class="hljs-keyword">friend</span> String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String &amp;lhs, <span class="hljs-type">const</span> String &amp; rhs);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">String</span>();<br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cstr);<br>    <span class="hljs-comment">// 拷贝控制成员</span><br>    <span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;rhs);<br>    String &amp; <span class="hljs-keyword">operator</span>=(String);<br>    ~<span class="hljs-built_in">String</span>();<br>    <span class="hljs-comment">// 有关容量与元素数量的成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reserve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span></span>;     <span class="hljs-comment">// 申请指定大小的容量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>;  <span class="hljs-comment">// 调整容器大小为 n 个元素。任何新添加元素都初始化为 c</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> first_free - elements; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cap - elements; &#125;<br><br>    <span class="hljs-comment">// 添加、删除元素的成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp; rhs)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> elements; &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> first_free; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> elements; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> first_free; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> std::allocator&lt;<span class="hljs-type">char</span>&gt; alloc;<br>    <span class="hljs-comment">// 被添加元素的函数访问</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chk_n_alloc</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">capacity</span>()) <span class="hljs-built_in">reallocate</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chk_n_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> </span>&#123;<span class="hljs-keyword">if</span> (n &gt; <span class="hljs-built_in">capacity</span>()) <span class="hljs-built_in">reserve</span>(n); &#125;<br>    <span class="hljs-comment">// 被 拷贝控制成员与析构函数访问</span><br>    <span class="hljs-function">std::pair&lt;<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*&gt; <span class="hljs-title">alloc_n_copy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">alloc_n_move</span><span class="hljs-params">(<span class="hljs-type">size_t</span> newCap)</span></span>;   <span class="hljs-comment">// 申请一块指定大小的新内存，将原有元素移动到新内存</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reallocate</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 获取更多内存空间，并拷贝已有元素</span><br>    <span class="hljs-comment">// 拼接两个字符串，返回值 first 指向首元素，second 指向尾元素之后位置</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> * elements;<br>    <span class="hljs-type">char</span> * first_free;<br>    <span class="hljs-type">char</span> * cap;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(String &amp;, String &amp;)</span></span>;<br>String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String &amp;lhs, <span class="hljs-type">const</span> String &amp; rhs);<br><br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> String &amp;s);<br></code></pre></td></tr></table></figure><h3 id="String-cpp-文件"><a href="#String-cpp-文件" class="headerlink" title="String.cpp 文件"></a>String.cpp 文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;String.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 初始化静态成员</span><br>std::allocator&lt;<span class="hljs-type">char</span>&gt; String::alloc;<br><br><span class="hljs-comment">// 返回一个 pair，first 成员指向拷贝后的首元素，second 成员指向尾元素之后的位置</span><br><span class="hljs-function">std::pair&lt;<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*&gt; <span class="hljs-title">String::alloc_n_copy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *b, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *e)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> newData = alloc.<span class="hljs-built_in">allocate</span>(e-b);<br>    <span class="hljs-keyword">return</span> &#123;newData, std::<span class="hljs-built_in">uninitialized_copy</span>(b, e, newData)&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::free</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (elements)&#123;<br>        <span class="hljs-keyword">while</span> (first_free != elements)<br>            alloc.<span class="hljs-built_in">destroy</span>(--first_free);<br>        alloc.<span class="hljs-built_in">deallocate</span>(elements, cap - elements);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::alloc_n_move</span><span class="hljs-params">(<span class="hljs-type">size_t</span> newCap)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> newData = alloc.<span class="hljs-built_in">allocate</span>(newCap);  <span class="hljs-comment">// 申请新内存</span><br>    <span class="hljs-keyword">auto</span> dest = newData;    <span class="hljs-comment">// 指向新内存的首位置</span><br>    <span class="hljs-keyword">auto</span> src = elements;   <span class="hljs-comment">// 指向旧内存的首元素</span><br>    <span class="hljs-comment">// 将旧内存中的元素移动到新内存中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-built_in">size</span>(); ++i)<br>        alloc.<span class="hljs-built_in">construct</span>(dest++, *src++);<br>    <span class="hljs-built_in">free</span>();     <span class="hljs-comment">// 释放原内存空间</span><br>    <span class="hljs-comment">// 更新数据结构</span><br>    elements = newData;<br>    first_free = dest;<br>    cap = newData + newCap;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::reallocate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> newCap = <span class="hljs-built_in">size</span>() ? <span class="hljs-number">2</span> * <span class="hljs-built_in">size</span>() : <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">alloc_n_move</span>(newCap);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::splice</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *b, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *e)</span> </span>&#123;<br>    <span class="hljs-built_in">reserve</span>(<span class="hljs-built_in">size</span>() + (e-b));<br>    <span class="hljs-keyword">while</span> (b != e)<br>        alloc.<span class="hljs-built_in">construct</span>(first_free++, *b++);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(String &amp;lhs, String &amp;rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>    <span class="hljs-built_in">swap</span>(lhs.elements, rhs.elements);<br>    <span class="hljs-built_in">swap</span>(lhs.first_free, rhs.first_free);<br>    <span class="hljs-built_in">swap</span>(lhs.cap, rhs.cap);<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>()<br>            : <span class="hljs-built_in">elements</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">first_free</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">cap</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">auto</span> p = alloc.<span class="hljs-built_in">allocate</span>(<span class="hljs-number">1</span>);<br>    alloc.<span class="hljs-built_in">construct</span>(p, <span class="hljs-string">&#x27;\0&#x27;</span>);<br>    elements = p;<br>    first_free = cap = p + <span class="hljs-number">1</span>;<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *cstr)<br>            : <span class="hljs-built_in">elements</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">first_free</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">cap</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">auto</span> newData = <span class="hljs-built_in">alloc_n_copy</span>(cstr, cstr+std::<span class="hljs-built_in">strlen</span>(cstr));<br>    elements = newData.first;<br>    first_free = cap = newData.second;<br>&#125;<br><br>String::<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String &amp;rhs) &#123;<br>    <span class="hljs-keyword">auto</span> newData = <span class="hljs-built_in">alloc_n_copy</span>(rhs.<span class="hljs-built_in">begin</span>(),rhs.<span class="hljs-built_in">end</span>());<br>    elements = newData.first;<br>    first_free = cap = newData.second;<br>&#125;<br><br>String &amp; String::<span class="hljs-keyword">operator</span>=(String rhs) &#123;<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>String::~<span class="hljs-built_in">String</span>() &#123;<br>    <span class="hljs-built_in">free</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::reserve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 当 n 大于当前容量时才申请内存，n 小于 当前容量时什么也不做</span><br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-built_in">capacity</span>()) &#123;<br>        <span class="hljs-built_in">alloc_n_move</span>(n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-built_in">capacity</span>()) <span class="hljs-built_in">reserve</span>(n * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-built_in">size</span>(); i != n; ++i)<br>            alloc.<span class="hljs-built_in">construct</span>(first_free++, c);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">while</span> (first_free != elements + n)<br>            alloc.<span class="hljs-built_in">destroy</span>(--first_free);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::resize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">resize</span>(n, <span class="hljs-built_in">char</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::push_back</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-built_in">chk_n_alloc</span>();<br>    alloc.<span class="hljs-built_in">construct</span>(first_free++, c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> String &amp;rhs)</span> </span>&#123;<br>    <span class="hljs-built_in">splice</span>(rhs.<span class="hljs-built_in">begin</span>(), rhs.<span class="hljs-built_in">end</span>());<br>&#125;<br><br>String <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> String &amp;lhs, <span class="hljs-type">const</span> String &amp;rhs) &#123;<br>    <span class="hljs-keyword">auto</span> result = lhs;<br>    result.<span class="hljs-built_in">splice</span>(rhs.<span class="hljs-built_in">begin</span>(), rhs.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">String::pop_back</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>)<br>        alloc.<span class="hljs-built_in">destroy</span>(--first_free);<br>&#125;<br><br>std::ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="hljs-type">const</span> String &amp; s) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> p : s)<br>        os &lt;&lt; p;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试-String-程序"><a href="#测试-String-程序" class="headerlink" title="测试 String 程序"></a>测试 String 程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    <span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;, world!&quot;</span>)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 = &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s2 = &quot;</span> &lt;&lt; s2 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 测试 operator+</span><br>    String s3 = s1 + s2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s3 = s1 + s2 = &quot;</span> &lt;&lt; s3 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// push_back &amp; pop_back</span><br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;!&#x27;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 after push_back: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">pop_back</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s1 after pop_back: &quot;</span> &lt;&lt; s1 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// reserve &amp; capacity</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s3 size: &quot;</span> &lt;&lt; s<span class="hljs-number">3.</span><span class="hljs-built_in">size</span>()<br>              &lt;&lt; <span class="hljs-string">&quot;, capacity: &quot;</span> &lt;&lt; s<span class="hljs-number">3.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    s<span class="hljs-number">3.</span><span class="hljs-built_in">reserve</span>(<span class="hljs-number">50</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s3.capacity() after reserve(50): &quot;</span> &lt;&lt; s<span class="hljs-number">3.</span><span class="hljs-built_in">capacity</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-comment">// resize 增大与缩小</span><br>    s<span class="hljs-number">3.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s3 after resize(5): &quot;</span> &lt;&lt; s3 &lt;&lt; std::endl;<br>    s<span class="hljs-number">3.</span><span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;x&#x27;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;s3 after resize(10,&#x27;x&#x27;): &quot;</span> &lt;&lt; s3 &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试程序输出结果为：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs terminal">s1 = Hello<br>s2 = , world!<br>s3 = s1 + s2 = Hello, world!<br>s1 after push_back: Hello!<br>s1 after pop_back: Hello<br>s3 size: 13, capacity: 13<br>s3.capacity() after reserve(50): 50<br>s3 after resize(5): Hello<br>s3 after resize(10,&#x27;x&#x27;): Helloxxxxx<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 自定义 vector </tag>
            
            <tag> 自定义 String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.3 使用标准库：文本查询程序</title>
      <link href="/2025/04/17/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/12.3%20%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9A%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/"/>
      <url>/2025/04/17/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/12.3%20%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%9A%E6%96%87%E6%9C%AC%E6%9F%A5%E8%AF%A2%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>实现一个简单的文本查询程序</li><li>程序允许用户在一个给定文件中查询单词</li><li>查询结果是单词在文件中出现的次数以及其所在行的列表</li><li>如果一个单词在一行中出现多次，此行只列出一次</li><li>行会按升序输出</li></ul><h2 id="文本查询程序设计"><a href="#文本查询程序设计" class="headerlink" title="文本查询程序设计"></a>文本查询程序设计</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul><li>程序需要逐行读入文件，并将每行分解为单个单词</li><li>当程序生成输出时：<ul><li>必须能提取每个单词所关联的行号</li><li>行号必须按升序出现且无重复</li><li>必须能打印给定行号中的文本</li></ul></li></ul><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><ul><li>使用 vector\<string> 保存文件输入的一个拷贝，文件的每行保存为 vector 的一个元素，当需要打印一行时，使用行号作为下标来提取文本</li><li>使用 istringstream 来提取每行中的单词</li><li>使用 set 保存每个单词在输入文件中出现的行号。保证每行只出现一次且按升序存储</li><li>使用 map 将每个单词与它出现的行号 set 关联起来。方便的提取任意单词的 set</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>抽象一个保存输入文件的类，命名为 TextQuery，包含一个 vector 和一个 map，vector 保存输入文件内容，map 关联每个单词和它出现的行号 set</li><li>TextQuery 有读取输入文件的构造函数和一个执行查询的操作<ul><li>查询操作：查找 map 成员，检查给定单词是否出现。此函数需要确定返回内容，一旦找到一个单词，需要知道它出现了几次、它出现的行号以及每行的文本</li><li>定义另一个类来保存查询结果，命名为 QueryResult，此类会有一个 print 函数，负责打印工作</li></ul></li></ul><h4 id="在类之间共享数据"><a href="#在类之间共享数据" class="headerlink" title="在类之间共享数据"></a>在类之间共享数据</h4><ul><li>QueryResult 类需要访问保存文件内容的 vector 和关联单词与行号 set 的 map，这些数据保存在 TextQuery 类中，<strong>并且两个类的生存周期应该相同</strong></li><li>这两个类在概念上共享了数据，可以使用 shared_ptr</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="编写使用-TextQuery-类的函数"><a href="#编写使用-TextQuery-类的函数" class="headerlink" title="编写使用 TextQuery 类的函数"></a>编写使用 TextQuery 类的函数</h3><ul><li>此函数接受一个指向要处理文件的 ifstream , 并与用户交互，打印给定单词的查询结果</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runQueries</span><span class="hljs-params">(std::ifstream &amp;infile)</span> </span>&#123;<br>    <span class="hljs-function">TextQuery <span class="hljs-title">tq</span><span class="hljs-params">(infile)</span></span>;   <span class="hljs-comment">// 保存文件并建立查询 map</span><br>    <span class="hljs-comment">// 与用户交互: 提示用户输入要查询的单词，完成查询并打印结果</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;enter word to look for, or q to quie: \n&quot;</span>;<br>        std::string s;<br>        <span class="hljs-comment">// 若遇到文件尾或用户输入 &#x27;q&#x27; 时终止</span><br>        <span class="hljs-keyword">if</span> (!(std::cin&gt;&gt;s) || s == <span class="hljs-string">&quot;q&quot;</span>) <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">// 指向查询并打印结果</span><br>        <span class="hljs-built_in">print</span>(std::cout, tq.<span class="hljs-built_in">query</span>(s))  &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="TextQuery-类和-QueryResult-类的定义"><a href="#TextQuery-类和-QueryResult-类的定义" class="headerlink" title="TextQuery 类和 QueryResult 类的定义"></a>TextQuery 类和 QueryResult 类的定义</h3><h4 id="TextQuery-h"><a href="#TextQuery-h" class="headerlink" title="TextQuery.h"></a>TextQuery.h</h4><ul><li>数据成员：<ul><li>一个指向动态分配的 vector 的 shared_ptr</li><li>一个 string 到 shared_ptr\<set> 的 map，每个单词关联到动态分配的 set 上</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KNOWLEDGETEST_TEXTQUERY_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KNOWLEDGETEST_TEXTQUERY_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryResult</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextQuery</span> &#123;<br><br>    <span class="hljs-keyword">using</span> line_no = <span class="hljs-type">unsigned</span> ;<br>    <span class="hljs-keyword">using</span> Line_set = std::set&lt;line_no&gt;;<br>    <span class="hljs-keyword">using</span> Line_map = std::map&lt;std::string, std::shared_ptr&lt;Line_set&gt;&gt;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TextQuery</span>(std::ifstream &amp;);<br>    <span class="hljs-function">QueryResult <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;<br>    <span class="hljs-comment">//wl_map 关联单词与行号 set</span><br>    Line_map wl_map;<br>&#125;;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//KNOWLEDGETEST_TEXTQUERY_H</span></span><br></code></pre></td></tr></table></figure><h4 id="TextQuery-cpp"><a href="#TextQuery-cpp" class="headerlink" title="TextQuery.cpp"></a>TextQuery.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TextQuery.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;QueryResult.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br>TextQuery::<span class="hljs-built_in">TextQuery</span>(std::ifstream &amp;infile) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">vector</span>&lt;std::string&gt;() )&#123;<br>    std::string text;<br>    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(infile, text)) &#123;<br>        <span class="hljs-comment">// 将一行文本保存为 vector 的一个元素</span><br>        data-&gt;<span class="hljs-built_in">push_back</span>(text);<br>        line_no line_number = data-&gt;<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;    <span class="hljs-comment">// 当前行号</span><br><br>        <span class="hljs-comment">// 在 map 中保存每个单词和它相应的行号</span><br>        std::string word;<br>        <span class="hljs-function">std::istringstream <span class="hljs-title">stream</span><span class="hljs-params">(text)</span></span>;<br>        <span class="hljs-keyword">while</span> (stream &gt;&gt; word) &#123;<br>            <span class="hljs-keyword">auto</span> &amp;lines = wl_map[word];<br>            <span class="hljs-keyword">if</span> (!lines)     <span class="hljs-comment">// 如果单词是第一次碰到的，此指针为空</span><br>                lines.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Line_set);  <span class="hljs-comment">// 分配一个新的 set</span><br>            lines-&gt;<span class="hljs-built_in">insert</span>(line_number);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">QueryResult <span class="hljs-title">TextQuery::query</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; word)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> no_lines = std::<span class="hljs-built_in">make_shared</span>&lt;Line_set&gt; ();<br><br>    <span class="hljs-keyword">auto</span> it = wl_map.<span class="hljs-built_in">find</span>(word);<br>    <span class="hljs-keyword">if</span> (it == wl_map.<span class="hljs-built_in">end</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">QueryResult</span>(word, data, no_lines);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">QueryResult</span>(word, data, it-&gt;second);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="QueryResult-h"><a href="#QueryResult-h" class="headerlink" title="QueryResult.h"></a>QueryResult.h</h4><ul><li>需要共享的数据是保存行内容的 vector 和保存行号的 set</li><li>数据成员：<ul><li>string sought：目标单词</li><li>一个指向 vector 的 shared_ptr</li><li>一个指向 set 的 shared_ptr</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KNOWLEDGETEST_QUERYRESULT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KNOWLEDGETEST_QUERYRESULT_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryResult</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp; os, <span class="hljs-type">const</span> QueryResult &amp;)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">QueryResult</span>(<span class="hljs-type">const</span> std::string &amp; s,<br>                std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; c,<br>                std::shared_ptr&lt;std::set&lt;<span class="hljs-type">unsigned</span>&gt;&gt; ls )<br>                : <span class="hljs-built_in">sought</span>(s),  <span class="hljs-built_in">contents</span>(std::<span class="hljs-built_in">move</span>(c)), <span class="hljs-built_in">lines</span>(std::<span class="hljs-built_in">move</span>(ls))&#123; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string sought;<br>    std::shared_ptr&lt;std::vector&lt;std::string &gt;&gt; contents;<br>    std::shared_ptr&lt;std::set&lt;<span class="hljs-type">unsigned</span>&gt;&gt; lines;<br>&#125;;<br><br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp; os, <span class="hljs-type">const</span> QueryResult &amp;)</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//KNOWLEDGETEST_QUERYRESULT_H</span></span><br></code></pre></td></tr></table></figure><h4 id="QueryResult-cpp"><a href="#QueryResult-cpp" class="headerlink" title="QueryResult.cpp"></a>QueryResult.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;QueryResult.h&quot;</span></span><br><br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp; os, <span class="hljs-type">const</span> QueryResult &amp; qr)</span></span>&#123;<br>    <span class="hljs-type">size_t</span> count = qr.lines-&gt;<span class="hljs-built_in">size</span>();<br>    os &lt;&lt; qr.sought &lt;&lt; <span class="hljs-string">&quot; occurs &quot;</span> &lt;&lt; count<br>    &lt;&lt; (count &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">&quot; times &quot;</span> : <span class="hljs-string">&quot; time &quot;</span>)<br>    &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-comment">// 逐个打印</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> lineno : *qr.lines) &#123;<br>        os &lt;&lt; <span class="hljs-string">&quot;\t(line &quot;</span> &lt;&lt; lineno + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;) &quot;</span><br>           &lt;&lt; qr.contents-&gt;<span class="hljs-built_in">at</span>(lineno)<br>           &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 文本查询程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.2 动态数组</title>
      <link href="/2025/04/16/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/12.2%20%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
      <url>/2025/04/16/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/12.2%20%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="动态数组概述"><a href="#动态数组概述" class="headerlink" title="动态数组概述"></a>动态数组概述</h2><ul><li>另一种 new 表达式语法，分配并初始化一个对象数组</li><li>allocator 类，允许将分配和初始化分离</li><li><strong>分配动态数组的类必须定义自己版本的操作，在拷贝、复制、销毁对象时管理所关联的内存</strong></li></ul><h2 id="new-和数组"><a href="#new-和数组" class="headerlink" title="new 和数组"></a>new 和数组</h2><ul><li><p>使用 new 分配对象数组：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> T[要分配的对象的数目]<br></code></pre></td></tr></table></figure></li><li><p>分配成功后<strong>返回指向第一个对象的指针</strong></p></li></ul><h3 id="分配一个数组会得到一个元素类型的指针"><a href="#分配一个数组会得到一个元素类型的指针" class="headerlink" title="分配一个数组会得到一个元素类型的指针"></a>分配一个数组会得到一个元素类型的指针</h3><ul><li>使用 new T[] 分配的内存称为动态数组，<strong>new 返回的是一个元素类型的指针</strong></li><li><strong>动态分配的数组不是数组类型</strong>，不能调用 begin 和 end</li></ul><h3 id="初始化动态分配对象的数组"><a href="#初始化动态分配对象的数组" class="headerlink" title="初始化动态分配对象的数组"></a>初始化动态分配对象的数组</h3><ul><li><p>可以对数组中的元素进行<strong>值初始化</strong></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *pia = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">42</span>]();<br>string *s = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>]();<br></code></pre></td></tr></table></figure></li><li><p>还可以提供一个元素初始化器的花括号列表</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>string *s = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>]&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;  <span class="hljs-comment">// 前三个元素使用初始化器初始化，后面元素使用值初始化</span><br></code></pre></td></tr></table></figure><ul><li>如果初始化器数目大于元素数目，new 表达式失败，抛出一个类型为 bad_array_new_length 的异常，此异常类型定义在头文件 new 中</li></ul></li></ul><h3 id="动态分配一个空数组是合法的"><a href="#动态分配一个空数组是合法的" class="headerlink" title="动态分配一个空数组是合法的"></a>动态分配一个空数组是合法的</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> arr[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 错误，不能定义长度为 0 的数组</span><br><span class="hljs-type">char</span> *cp = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 正确，但 cp 不能解引用</span><br></code></pre></td></tr></table></figure><ul><li>当使用 new 分配一个大小为 0 的数组时，<strong>new 返回一个合法的非空指针</strong>，此指针<strong>可以像尾后迭代器一样使用</strong>，但是<strong>此指针不能解引用</strong></li></ul><h3 id="释放动态数组"><a href="#释放动态数组" class="headerlink" title="释放动态数组"></a>释放动态数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p;       <span class="hljs-comment">// p 指向一个动态分配的对象或为空</span><br><span class="hljs-keyword">delete</span> [] pa;   <span class="hljs-comment">// pa 指向一个动态分配的数组或为空</span><br></code></pre></td></tr></table></figure><ul><li>数组中的元素被<strong>逆序销毁</strong>，即先销毁最后一个元素，再销毁倒数第二个…</li></ul><h3 id="智能指针与动态数组"><a href="#智能指针与动态数组" class="headerlink" title="智能指针与动态数组"></a>智能指针与动态数组</h3><ul><li><p>标准库提供了一个 <strong>unique_ptr 的版本来管理 new 分配的动态数组</strong>，必须在对象类型后加一对 <code>[]</code></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// up 指向 10 个未初始化 int 的数组</span><br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<br>up.<span class="hljs-built_in">release</span>();       <span class="hljs-comment">// 自动使用 delete [] 销毁其指针</span><br></code></pre></td></tr></table></figure></li><li><p>当一个 unique_ptr 指向一个数组时，<strong>不支持成员访问运算符（点或箭头运算符）</strong></p></li><li>当一个 unique_ptr 指向一个数组是，<strong>可以使用下标运算符来访问数组中的元素</strong></li></ul><h4 id="指向数组的-unique-ptr-操作"><a href="#指向数组的-unique-ptr-操作" class="headerlink" title="指向数组的 unique_ptr 操作"></a>指向数组的 unique_ptr 操作</h4><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>unique_ptr<T[]> u</td><td>u 可以指向一个动态分配的数组，数组元素类型为 T</td></tr><tr><td>unique_ptr<T[]> u(p)</td><td>u 可以指向<strong>内置指针 p</strong> 指向的动态分配的数组 <br> p 必须可以转换为 T*</td></tr><tr><td><strong>u[i]</strong></td><td>返回 u 拥有的数组中位置 i 处的对象 <br> <strong>u 必须指向一个数组</strong></td></tr></tbody></table></div><ul><li>其他 unique_ptr 操作不变</li><li>shared_ptr 不直接支持管理动态数组，如果希望 shared_ptr 管理动态数组，必须提供自定义的删除器</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 为了使用 shared_ptr 管理动态数组，必须提供删除器</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-type">int</span> *p) &#123; <span class="hljs-keyword">delete</span> [] p;&#125;)</span></span>;<br>sp.<span class="hljs-built_in">reset</span>();     <span class="hljs-comment">// 使用 lambda 释放数组</span><br></code></pre></td></tr></table></figure><h2 id="allocator-类"><a href="#allocator-类" class="headerlink" title="allocator 类"></a>allocator 类</h2><ul><li><strong>new 将内存分配与对象构造组合在一起</strong>，<strong>delete 将对象析构与内存释放组合在一起</strong>，有一定的局限性</li><li>当分配一大块内存，计划在这块内存上按需构造对象，此时就需要将内存分配与对象构造分开，当真正需要对象时，才进行构造（付出一定的开销）</li><li><strong>allocator 类将内存分配与对象构造分离开</strong></li><li><strong>allocator 类分配的内存是原始的，未构造的</strong></li><li>allocator 是模板类型</li></ul><h3 id="allocator-类及其算法"><a href="#allocator-类及其算法" class="headerlink" title="allocator 类及其算法"></a>allocator 类及其算法</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>allocator\<T> a</strong></td><td>定义了一个名为 a 的 allocator 对象，可以为类型为 T 的对象分配内存</td></tr><tr><td><strong>a.allocate(n)</strong></td><td>分配一段原始的未分配的内存，保存 n 个类型为 T 的对象</td></tr><tr><td><strong>a.deallocate(p, n)</strong></td><td><strong>释放从 T* 类型指针 p 中地址开始的内存</strong>，这块内存保存了 n 个类型为 T 的对象 <br> <strong>p 必须是一个由 allocate 返回的指针</strong>，<strong>且 n 必须是 p 创建时指定的大小</strong> <br> <strong>在调用 deallocate 之前，用户必须对这块内存中创建的对象调用 destroy</strong></td></tr><tr><td><strong>a.construct(p, args)</strong></td><td>p 是一个类型为 T* 的指针，指向一块原始内存 <br> args 被传递给类型为 T 的构造函数，用来在 p 指向的内存中构造一个对象</td></tr><tr><td><strong>a.destory(p)</strong></td><td>p 为 T* 类型的指针，此算法对 p 指向的对象执行析构函数</td></tr></tbody></table></div><h3 id="allocator-分配未构造的内存"><a href="#allocator-分配未构造的内存" class="headerlink" title="allocator 分配未构造的内存"></a>allocator 分配未构造的内存</h3><ul><li>allocator 分配的内存是 unconstructed, 按需在此内存中构造对象</li><li><p>使用成员函数 <strong>construct</strong> 构造对象，此成员函数<strong>接受一个指针参数和零个或多个额外参数</strong></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">allocator&lt;string&gt; alloc;    <span class="hljs-comment">// 可以分配 string 的 allocator 对象</span><br><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> p = alloc.<span class="hljs-built_in">allocate</span>(n); <span class="hljs-comment">// 分配 n 个未初始化的 string</span><br><span class="hljs-keyword">auto</span> q = p; <span class="hljs-comment">// q 指向最后构造的元素之后的位置</span><br>alloc.<span class="hljs-built_in">construct</span>(q++);       <span class="hljs-comment">// *q 为空字符串</span><br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;c&#x27;</span>);  <span class="hljs-comment">// *q 为 cccccccccc</span><br>alloc.<span class="hljs-built_in">construct</span>(q++, <span class="hljs-string">&quot;hi&quot;</span>);     <span class="hljs-comment">// *q 为 hi</span><br></code></pre></td></tr></table></figure></li><li><p><strong>为了使用 allocate 返回的内存，必须使用 construct 构造对象</strong>。使用未构造的内存，其行为是未定义的</p></li><li><strong>使用完对象后，必须对每个元素对象调用 destroy 成员</strong></li><li><p>destroy 接受一个指针参数，对指针指向的对象执行析构函数</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(q != p) &#123;<br>    alloc.<span class="hljs-built_in">destroy</span>(--q); <span class="hljs-comment">// 释放真正构造的 string 对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>只能对真正构造了的元素调用 destroy 函数</p></li><li><p>元素被销毁后，调用 deallocate 释放内存</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">alloc.<span class="hljs-built_in">deallocate</span>(p, n);<br></code></pre></td></tr></table></figure></li></ul><h3 id="拷贝和填充未初始化内存的算法"><a href="#拷贝和填充未初始化内存的算法" class="headerlink" title="拷贝和填充未初始化内存的算法"></a>拷贝和填充未初始化内存的算法</h3><ul><li><strong>这些函数在给定目的位置创建元素，而不是由系统分配内存给它们</strong></li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>uninitialized_copy(b, e, b2)</strong></td><td><strong>从迭代器 b, e 指定的输入范围</strong>中拷贝元素到<strong>迭代器 b2 指定的未构造的原始内存中</strong> <br> b2 指向的内存必须足够容纳输入序列中元素的拷贝 <br> <strong>返回（递增后）目的位置迭代器</strong></td></tr><tr><td><strong>uninitialized_copy_n(b, n, b2)</strong></td><td>从迭代器 b 指向的元素开始，拷贝 n 个元素到迭代器 b2 开始的未构造的原始内存中</td></tr><tr><td><strong>uninitialized_fill(b, e, t)</strong></td><td>在<strong>迭代器 b,e 指定的原始内存范围</strong>内创建对象，对象的值均为 t 的拷贝</td></tr><tr><td><strong>uninitialized_fill_n(b, n, t)</strong></td><td>在迭代器 b 指定的内存地址开始创建 n 个对象。<br> b 指向的原始内存必须足够容纳指定数量的对象</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 动态数组 </tag>
            
            <tag> new 和数组 </tag>
            
            <tag> allocator 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.1 动态内存与智能指针</title>
      <link href="/2025/04/10/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/12.1%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2025/04/10/12.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/12.1%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="动态内存概述"><a href="#动态内存概述" class="headerlink" title="动态内存概述"></a>动态内存概述</h2><ul><li><strong>静态内存</strong>：用来保存<strong>局部 static 对象</strong>，<strong>类 static 成员</strong>，<strong>定义在任何函数之外的变量</strong></li><li><strong>栈内存</strong>：保存<strong>定义在函数内的非 static 对象</strong></li><li><strong>静态内存或栈内存中的对象</strong>由<strong>编译器自动创建和销毁</strong></li><li>对于<strong>栈对象</strong>，<strong>只有在其定义的程序块运行时才存在</strong></li><li><strong>static 对象</strong>在<strong>使用前分配</strong>，在<strong>程序结束时销毁</strong></li><li>除静态内存和栈内存之外，每个程序还有一个内存池，称为<strong>自由空间(free memory) 或 堆(heap)</strong>，来<strong>存储动态分配(dynamically allocate)的对象</strong>,即在程序运行时分配的对象</li><li><strong>动态对象的生存周期由程序来控制</strong></li></ul><h2 id="动态内存与智能指针概述"><a href="#动态内存与智能指针概述" class="headerlink" title="动态内存与智能指针概述"></a>动态内存与智能指针概述</h2><ul><li>c++ 中动态内存由一对运算符管理：<ul><li><strong>new</strong>：在动态内存中为对象分配内存空间并<strong>返回一个指向该对象的指针</strong></li><li><strong>delete</strong>：<strong>接受一个动态对象的指针</strong>，销毁该对象，并释放与之关联的内存</li></ul></li><li><strong>忘记释放内存</strong>，会<strong>产生内存泄漏</strong></li><li>在<strong>尚有指针引用内存的情况下释放内存</strong>，会<strong>产生引用非法内存的指针</strong></li><li>标准库提供两种<strong>智能指针(smart pointer)来管理内存</strong>，与普通指针的区别是<strong>智能指针自动释放所指向的对象</strong></li><li>而这两种智能指针的区别是<strong>管理底层指针的方式</strong>：<ul><li><strong>shared_ptr：允许多个指针指向同一个对象</strong></li><li><strong>unique_ptr：独占所指向的对象</strong></li></ul></li><li>标准库还定义了一个名为 <strong>weak_ptr</strong> 的伴随类，是一种<strong>弱引用</strong>，<strong>指向 shared_ptr 所管理的对象</strong>。</li><li>三种类型都定义在 <strong>memory 头文件</strong>中</li></ul><h2 id="shared-ptr-类"><a href="#shared-ptr-类" class="headerlink" title="shared_ptr 类"></a>shared_ptr 类</h2><ul><li>智能指针也是模板，默认初始化的的智能指针保存一个空指针</li><li>解引用一个智能指针返回它指向的对象</li><li>在一个<strong>条件判断中使用智能指针，就是检测它是否为空</strong></li></ul><h3 id="shared-ptr-和-unique-ptr-都支持的操作"><a href="#shared-ptr-和-unique-ptr-都支持的操作" class="headerlink" title="shared_ptr 和 unique_ptr 都支持的操作"></a>shared_ptr 和 unique_ptr 都支持的操作</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>shared_ptr<T> sp <br> unique_ptr<T> up</td><td>空智能指针，可以指向类型为 T 的对象</td></tr><tr><td>p</td><td><strong>将 p 用作一个条件判断，若 p 指向一个对象，则为 true</strong></td></tr><tr><td>*p</td><td>解引用 p，返回它指向的对象</td></tr><tr><td>p -&gt; mem</td><td>等价于 (*p).mem</td></tr><tr><td>p.get()</td><td>返回 p 中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也消失了</td></tr><tr><td><strong>swap(p, q) <br> p.swap(q)</strong></td><td><strong>交换 p, q 中的指针</strong></td></tr></tbody></table></div><h3 id="shared-ptr-独有的操作"><a href="#shared-ptr-独有的操作" class="headerlink" title="shared_ptr 独有的操作"></a>shared_ptr 独有的操作</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>make_shared\<T> (args)</strong></td><td>返回一个 shared_ptr，指向动态分配的类型为 T 的对象。使用 args 初始化此对象</td></tr><tr><td><strong>shared_ptr\<T> p(q)</strong></td><td>p 是 shared_ptr 的拷贝；<br> <strong>此操作会递增 q 中的计数器</strong> <br> q 中的指针必须能转换成 T*</td></tr><tr><td><strong>p = q</strong></td><td>p 和 q 都是 shared_ptr，所保存的指针必须能相互转换；<br> <strong>此操作会递减 p 的引用计数</strong>，<strong>递增 q 的引用计数</strong> <br> 若 p 的引用计数变为 0，则将其管理的<strong>原内存释放</strong></td></tr><tr><td>p.unique()</td><td>若 p.use_count() 为 1，返回 true，否则返回 false</td></tr><tr><td>p.use_count()</td><td>返回与 p 共享对象的智能指针数量，主要用于调试</td></tr></tbody></table></div><h3 id="make-shared-函数"><a href="#make-shared-函数" class="headerlink" title="make_shared 函数"></a>make_shared 函数</h3><ul><li>此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 指向一个值为 42 的 int 的 shared_ptr</span><br>shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">42</span>);<br><span class="hljs-comment">// p4 指向一个值为 &quot;9999999999&quot; 的string</span><br>shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt; (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>);<br><span class="hljs-comment">// p5 指向一个值初始化的 int ，即值为 0</span><br>shared_ptr&lt;string&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt; ();<br></code></pre></td></tr></table></figure><h3 id="shared-ptr-的拷贝和赋值"><a href="#shared-ptr-的拷贝和赋值" class="headerlink" title="shared_ptr 的拷贝和赋值"></a>shared_ptr 的拷贝和赋值</h3><ul><li>进行拷贝或赋值时，<strong>每个 shared_ptr 都会记录有多少个其他 shared_ptr 指向同一个对象</strong><ul><li>用<strong>一个 shared_ptr 初始化 另一个 shared_ptr</strong>、将它<strong>作为一个参数传递给一个函数</strong>、<strong>作为函数的返回值</strong>，都会<strong>增加 shared_ptr 的引用计数值</strong></li><li><strong>给一个 shared_ptr 赋予一个新值</strong>、<strong>shared_ptr 被销毁</strong>（例如离开其作用域），都会<strong>递减引用计数值</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">42</span>);     <span class="hljs-comment">// r 指向 int，只有一个引用者</span><br>r = q;      <span class="hljs-comment">// 给 r 赋值，令它指向另一个地址</span><br>            <span class="hljs-comment">// 递增 q 指向的对象的引用计数</span><br>            <span class="hljs-comment">// 递减 r 原来指向的对象的引用计数</span><br>            <span class="hljs-comment">// r 原来指向的对象的引用计数为 0，释放该对象</span><br></code></pre></td></tr></table></figure><h3 id="shared-ptr-自动销毁所管理的对象"><a href="#shared-ptr-自动销毁所管理的对象" class="headerlink" title="shared_ptr 自动销毁所管理的对象"></a>shared_ptr 自动销毁所管理的对象</h3><ul><li>通过 <strong>析构函数(destructor)</strong> 完成销毁工作</li><li>shared_ptr 的析构函数会递减它所指向对象的引用计数。</li><li>如果引用计数为 0，则 shared_ptr 的析构函数会销毁该对象，并释放它所占用的内存</li></ul><h3 id="shared-ptr-会自动释放相关联的内存"><a href="#shared-ptr-会自动释放相关联的内存" class="headerlink" title="shared_ptr 会自动释放相关联的内存"></a>shared_ptr 会自动释放相关联的内存</h3><ul><li>当动态对象不再使用时，shared_ptr 类会自动释放动态对象</li><li>对于一块儿内存，shared_ptr <strong>保证只要有任何 shared_ptr 对象引用它，则它就不会被释放掉</strong></li><li><strong>如果将 shared_ptr 存放在一个容器中</strong>，而后不再需要全部元素，只需要使用容器中的一部分元素，要记得用 erase 删除不再需要的那些 shared_ptr 元素</li></ul><h2 id="程序使用动态内存出于以下三种原因之一"><a href="#程序使用动态内存出于以下三种原因之一" class="headerlink" title="程序使用动态内存出于以下三种原因之一"></a>程序使用动态内存出于以下三种原因之一</h2><ul><li><strong>程序不知道自己需要使用多少个对象</strong></li><li><strong>程序不知道所需对象的准确类型</strong></li><li><strong>程序需要再多个对象间共享底层数据</strong></li></ul><h3 id="定义-strBlob-类"><a href="#定义-strBlob-类" class="headerlink" title="定义 strBlob 类"></a>定义 strBlob 类</h3><ul><li>定义一个管理 string 的类 strBlob, 为每个 strBlob 设置一个 shared_ptr 管理动态分配的 vector</li><li>这个类应该提供的操作：<ul><li>访问元素：如果用户访问不存在元素，这些操作会抛出一个异常</li></ul></li><li>一个默认构造函数和一个构造函数，接受单一的 initializer_list\<string> 类型参数</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">strBlob</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span>  size_type = std::vector&lt;std::string&gt;::size_type;<br>    <span class="hljs-built_in">strBlob</span>();<br>    <span class="hljs-built_in">strBlob</span>(std::initializer_list&lt;std::string&gt; il);<br>    <span class="hljs-function">size_type <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">size</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">empty</span>(); &#125;<br><br>    <span class="hljs-comment">// 添加和删除元素</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; s)</span> </span>&#123; data-&gt;<span class="hljs-built_in">push_back</span>(s);&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 元素访问</span><br>    <span class="hljs-function">std::string &amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">std::string &amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; data;<br>    <span class="hljs-comment">// 如果 data[i] 不合法，抛出一个异常</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(size_type i, <span class="hljs-type">const</span> std::string &amp; msg)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">strBlob::<span class="hljs-built_in">strBlob</span>() : <span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;std::string&gt;&gt; () ) &#123; &#125;<br>strBlob::<span class="hljs-built_in">strBlob</span>(std::initializer_list&lt;std::string&gt; il)<br>                : <span class="hljs-built_in">data</span>( std::make_shared&lt;std::vector&lt;std::string&gt;&gt; (il) ) &#123; &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>接受一个 initializer_list 的构造函数将其参数传递给 vector 的对应构造函数</strong>。此构造函数通过拷贝列表中的值来初始化 vector 的元素</li></ul><h4 id="元素访问成员函数"><a href="#元素访问成员函数" class="headerlink" title="元素访问成员函数"></a>元素访问成员函数</h4><ul><li><p>访问元素操作前都要先检查元素是否存在，因此定义一个 check 工具函数</p><ul><li>front 和 back 应该对 const 进行重载</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strBlob::check</span><span class="hljs-params">(strBlob::size_type i, <span class="hljs-type">const</span> std::string &amp;msg)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= data-&gt;<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlob::front</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;front on empty strBlob&quot;</span>);<br>    <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">front</span>();<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlob::front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;front on empty strBlob&quot;</span>);<br>    <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">front</span>();<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlob::back</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;back on empty strBlob&quot;</span>);<br>    <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">back</span>();<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlob::back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;back on empty strBlob&quot;</span>);<br>    <span class="hljs-keyword">return</span> data-&gt;<span class="hljs-built_in">back</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">strBlob::pop_back</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">check</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;pop_back on empty strBlob&quot;</span>);<br>    data-&gt;<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h2><ul><li>new 分配内存</li><li>delete 释放 new 分配的内存</li></ul><h3 id="使用-new-动态分配和初始化对象"><a href="#使用-new-动态分配和初始化对象" class="headerlink" title="使用 new 动态分配和初始化对象"></a>使用 new 动态分配和初始化对象</h3><ul><li>new 无法为其分配的对象命名，而是返回一个指向该对象的指针</li><li><strong>默认情况下，动态分配的对象是默认初始化的</strong>，这意味着<strong>内置类型或组合类型的对象的值是未定义的</strong></li><li><p>可以使用直接初始化方式</p><ul><li><p>传统<strong>直接初始化方式：使用圆括号</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure></li><li><p>新标准下也可以使用<strong>列表初始化</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">veccot&lt;<span class="hljs-type">int</span>&gt; *pi = <span class="hljs-keyword">new</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>也可以对动态分配对象进行<strong>值初始化</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string *ps1 = <span class="hljs-keyword">new</span> string;<br>string *ps2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>();<br><span class="hljs-type">int</span> * pi3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();<br></code></pre></td></tr></table></figure></li></ul></li><li><p>对于内置类型，值初始化和默认初始化有很大区别</p><ul><li><strong>值初始化内置类型有这良好的定义值</strong></li><li><strong>默认初始化内置类型对象的值是未定义的</strong></li></ul></li><li><p>使用 <code>auto</code> 关键字</p><ul><li><p><strong>只有当括号中仅有单一初始化器时才能使用 auto</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">auto</span>(obj);    <span class="hljs-comment">// p 指向一个与 obj 类型相同的对象</span><br>                            <span class="hljs-comment">// 该对象使用 obj 进行初始化</span><br><span class="hljs-keyword">auto</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">auto</span>&#123;a, b, c&#125;;    <span class="hljs-comment">// 错误，括号中只能有单一初始化器</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="动态分配的-const-对象"><a href="#动态分配的-const-对象" class="headerlink" title="动态分配的 const 对象"></a>动态分配的 const 对象</h3><ul><li>使用 new 动态分配 const 对象是<strong>合法</strong>的</li><li>与其他 const 对象一样，动态分配的 const 对象也<strong>必须初始化</strong></li><li>new 返回的指针是一个<strong>指向 const 的指针</strong></li></ul><h3 id="内存耗尽"><a href="#内存耗尽" class="headerlink" title="内存耗尽"></a>内存耗尽</h3><ul><li>如果 new 不能分配所要求的内存空间，就会<strong>抛出一个 bad_alloc 的异常</strong></li><li><strong>定位 new(placement new)</strong> 表达式允许向 new 传递额外的参数，阻止抛出异常</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>();    <span class="hljs-comment">// 如果分配失败，会抛出 std::bad_alloc 异常</span><br><span class="hljs-type">int</span> *p1 = <span class="hljs-built_in">new</span> (nothrow) <span class="hljs-built_in">int</span>();  <span class="hljs-comment">// 如果分配失败，new 返回一个空指针</span><br></code></pre></td></tr></table></figure><ul><li>bad_alloc 和 nothrow 都定义在<strong>头文件 new</strong> 中</li></ul><h3 id="释放动态内存"><a href="#释放动态内存" class="headerlink" title="释放动态内存"></a>释放动态内存</h3><ul><li>delete 表达式接受一个指针，释放指针指向的对象</li><li>delete 表达式执行两个动作：<ul><li>销毁给定指针指向的对象</li><li>释放对应的内存</li></ul></li></ul><h3 id="指针值和-delete"><a href="#指针值和-delete" class="headerlink" title="指针值和 delete"></a>指针值和 delete</h3><ul><li>传递给 delete 的<strong>指针必须指向动态分配的内存</strong>，或者是一个<strong>空指针</strong></li><li><strong>释放一个并非 new 分配的内存，或者将相同的指针值释放多次，行为都是未定义的</strong></li><li>虽然 const 对象的值不能被改变，但可以被销毁</li></ul><h3 id="动态对象的生存周期直到被释放为止"><a href="#动态对象的生存周期直到被释放为止" class="headerlink" title="动态对象的生存周期直到被释放为止"></a>动态对象的生存周期直到被释放为止</h3><ul><li><font size=4><strong>内置指针</strong></font>(而不是智能指针) 管理的动态对象，直到<strong>被显式释放之前都存在</strong></li><li>当一个<strong>内置类型指针</strong>离开其作用域时，它所指向的对象什么也不会发生。<strong>如果这个指针指向的是动态内存，那么内存也不会被自动释放</strong></li></ul><h3 id="使用-new-和-delete-管理内存存在三个常见问题"><a href="#使用-new-和-delete-管理内存存在三个常见问题" class="headerlink" title="使用 new 和 delete 管理内存存在三个常见问题"></a>使用 new 和 delete 管理内存存在三个常见问题</h3><ul><li><strong>忘记 delete 内存</strong>：产生<strong>内存泄漏</strong>问题</li><li><strong>使用已经释放掉的对象</strong></li><li><strong>同一块内存释放两次</strong>：主要出现在当有<strong>两个指针指向同一个动态分配的对象</strong>时</li></ul><h3 id="delete-之后重置指针值"><a href="#delete-之后重置指针值" class="headerlink" title="delete 之后重置指针值"></a>delete 之后重置指针值</h3><ul><li>delete 之后，指针变成<strong>空悬指针(dangling pointer)</strong>, 也叫野指针</li><li>如果需要保留指针，可以在 delete 之后将 <strong>nullptr</strong> 赋予指针</li></ul><h2 id="shared-ptr-和-new-结合使用"><a href="#shared-ptr-和-new-结合使用" class="headerlink" title="shared_ptr 和 new 结合使用"></a>shared_ptr 和 new 结合使用</h2><ul><li>还可以使用 new 返回的指针来初始化 shared_ptr</li><li><strong>接受指针参数</strong>的智能指针构造函数是 <strong>explicit</strong> 的，<strong>限制隐式转换</strong>，必须使用直接初始化方式</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-type">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);   <span class="hljs-comment">// 错误，必须使用直接初始化方式</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;    <span class="hljs-comment">// 正确，使用了直接初始化方式</span><br></code></pre></td></tr></table></figure><ul><li>一个<strong>返回 shared_ptr 的函数</strong>不能在其返回语句中隐式转换为一个普通指针</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p);      <span class="hljs-comment">// 错误，隐式的转换为 shared_ptr&lt;int&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>必须将 shared_ptr 绑定到想要返回的指针上</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认情况下，一个<strong>用来初始化智能指针的普通指针，必须指向动态内存</strong>，因为<strong>智能指针默认使用 delete 释放它所关联的对象</strong></li><li>可以将智能指针绑定到一个指向其他类型的资源的指针上，但是必须提供自己的操作来代替 delete</li></ul><h3 id="定义和改变-shared-ptr-的其他方法"><a href="#定义和改变-shared-ptr-的其他方法" class="headerlink" title="定义和改变 shared_ptr 的其他方法"></a>定义和改变 shared_ptr 的其他方法</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>shared_ptr\<T> p(q)</strong></td><td><strong>p 管理内置指针 q 所指的对象</strong> <br> q 必须指向 new 分配的内存，且能转换成 T* 类型</td></tr><tr><td><strong>shared_ptr\<T> p(u)</strong></td><td>p 从 <strong>unique_ptr u</strong> 那里接管对象的所有权<br> <strong>将 u 置为空</strong></td></tr><tr><td><strong>shared_ptr\<T> p(q, d)</strong></td><td>p 接管内置指针 q 所指对象的所有权, q 必须能转换成 T<em> 类型 <br> <em>*p 将使用可调用对象 d 来代替 delete</em></em></td></tr><tr><td><strong>shared_ptr\<T> p(p2, d)</strong></td><td>p 是 shared_ptr p2 的一个拷贝，唯一区别是 p 使用可调用对象 d 来代替 delete</td></tr><tr><td><strong>p.reset() <br> p.reset(q) <br> p.reset(q, d)</strong></td><td><strong>若 p 是唯一指向其对象的shared_ptr ，reset 会释放此对象</strong> <br> <strong>若传递了可选参数内置指针 q , 会令 p 指向 q, 否则将 p 置为空</strong> <br> 若还传递了参数 d, 将调用 d 代替 delete</td></tr></tbody></table></div><h3 id="不要混合使用智能指针和普通指针"><a href="#不要混合使用智能指针和普通指针" class="headerlink" title="不要混合使用智能指针和普通指针"></a>不要混合使用智能指针和普通指针</h3><ul><li>shared_ptr 可以协调对象的析构，但这<strong>仅限于自身的拷贝(也是 shared_ptr)之间</strong>，因此<strong>推荐使用 make_shared()</strong>, 在分配对象时就将 shared_ptr 与对象绑定</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 ptr</span><br>&#125;   <span class="hljs-comment">// ptr 离开作用域，被销毁</span><br></code></pre></td></tr></table></figure><ul><li>上面函数中的参数是<strong>值传递方式</strong>的，实参会被<strong>拷贝</strong>到 ptr 中，shared_ptr 会<strong>递增其引用计数</strong></li><li>当 ptr 离开作用域被销毁，引用计数会减 1，但不会变为 0. 因此 ptr 指向的内存不会被释放</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">x</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(<span class="hljs-number">42</span>))</span></span>;       <span class="hljs-comment">// x 是一个普通指针</span><br><span class="hljs-built_in">process</span>(x);             <span class="hljs-comment">// 错误，不能将 int* 转换为 shared_ptr&lt;int&gt;</span><br><span class="hljs-built_in">process</span>(<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">int</span>&gt; (x));       <span class="hljs-comment">// 合法，但内存会被释放</span><br><span class="hljs-type">int</span> j = *x;     <span class="hljs-comment">// 未定义行为，x 现在是一个空悬指针</span><br></code></pre></td></tr></table></figure><ul><li>不能向 process 传递内置指针(shared_ptr 接受指针的构造函数是 explicit 的)，但可以传递一个临时 shared_ptr</li><li>传递临时 shared_ptr，当临时对象作用域结束别销毁时，引用计数递减为 0，此对象的内存空间也被释放</li><li><strong>当将一个 shared_ptr 绑定到一个普通指针后，不要再使用内置指针来访问 shared_ptr 指向的内存</strong>，因为无法知道对象何时被销毁</li></ul><h3 id="不要使用-get-初始化另一个智能指针或者为智能指针赋值"><a href="#不要使用-get-初始化另一个智能指针或者为智能指针赋值" class="headerlink" title="不要使用 get 初始化另一个智能指针或者为智能指针赋值"></a>不要使用 get 初始化另一个智能指针或者为智能指针赋值</h3><ul><li>设计 get 函数的目的是为了向需要向不能使用智能指针的代码传递一个内置指针。</li><li><strong>使用 get 返回的指针的代码不能 delete 此指针</strong></li><li><strong>永远不要使用 get 初始化另一个智能指针或者为另一个智能指针赋值</strong></li></ul><h3 id="其他-shared-ptr-操作"><a href="#其他-shared-ptr-操作" class="headerlink" title="其他 shared_ptr 操作"></a>其他 shared_ptr 操作</h3><ul><li>可以用 reset 来将一个新的指针赋予一个 shared_ptr</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>);  <span class="hljs-comment">// 错误，不能将普通指针赋给一个 shared_ptr</span><br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1024</span>)); <span class="hljs-comment">// 正确，p 指向一个新对象</span><br></code></pre></td></tr></table></figure><ul><li>与赋值类型，<strong>reset 会更新 shared_ptr 的引用计数</strong></li><li>reset 成员经常与 unique 一起使用</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">unique</span>()) <br>    p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p));        <span class="hljs-comment">// 不是唯一用户，分配新的拷贝</span><br>*p += newVal;<br></code></pre></td></tr></table></figure><ul><li>在改变底层对象之前，先检查自身是否是当前对象的唯一用户，如果不是，在改变之前要做一份新的拷贝</li></ul><h2 id="智能指针与异常"><a href="#智能指针与异常" class="headerlink" title="智能指针与异常"></a>智能指针与异常</h2><ul><li>程序需要确保在异常发生后资源能被正确释放</li><li>如果程序块因为异常过早结束，<strong>智能指针能确保在内存不再需要时将其释放</strong></li><li>发生异常时，直接管理的内存是不会自动释放的<ul><li>使用<strong>内置指针管理内存</strong>，且在 <strong>new 之后，对应的 delete 之前发生异常，内存不会被释放</strong></li></ul></li></ul><h3 id="智能指针和哑类"><a href="#智能指针和哑类" class="headerlink" title="智能指针和哑类"></a>智能指针和哑类</h3><ul><li>与管理动态内存类似，可以使用相似的技术来管理<strong>不具有良好定义的析构函数的类</strong>，当这些类对象的作用域结束，程序会自动释放资源，避免发生资源泄露</li></ul><h3 id="使用自定义的释放操作"><a href="#使用自定义的释放操作" class="headerlink" title="使用自定义的释放操作"></a>使用自定义的释放操作</h3><ul><li><strong>删除器(deleter)</strong>: 自定义一个函数来代替 delete</li><li>当创建一个 shared_ptr 时，可以<strong>传递一个 (可选的) 指向删除函数的参数</strong></li></ul><h3 id="使用智能指针遵循的基本规范"><a href="#使用智能指针遵循的基本规范" class="headerlink" title="使用智能指针遵循的基本规范"></a>使用智能指针遵循的基本规范</h3><ul><li><strong>不使用相同的内置指针初始化（ 或 reset）多个智能指针</strong></li><li><strong>不 delete get() 返回的指针</strong></li><li>不使用 get() 初始化或 reset 另一个智能指针</li><li>如果使用 get() 返回的指针，记住当最后一个对应的智能指针销毁后，先前 get() 返回的指针就无效了</li><li><strong>如果使用智能指针管理的资源不是 new 分配的资源，记得传递给它一个删除器</strong></li></ul><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul><li>某一时刻只能有一个 unique_ptr 指向一个给定对象，当 unique_ptr 被销毁，它所指向的对象也被销毁</li><li><strong>定义一个 unique_ptr，需要将其绑定到一个 new 返回的指针上</strong></li><li>初始化 unique_ptr 也必须使用<strong>直接初始化</strong></li><li><strong>unique_ptr 不支持普通的拷贝或赋值操作</strong>，因为一个 unique_ptr 拥有它所指向的对象</li></ul><h3 id="unique-ptr-支持的操作"><a href="#unique-ptr-支持的操作" class="headerlink" title="unique_ptr 支持的操作"></a>unique_ptr 支持的操作</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>unique_ptr\<T> u1</strong> <br> <strong>unique_ptr\<T, D> u2</strong></td><td>空 unique_ptr，可以指向类型为 T 的对象 <br> u1 使用 <strong>delete</strong> 来释放指针; u2 使用一个<strong>类型为 D 的可调用对象</strong>来释放指针</td></tr><tr><td><strong>unique_ptr\<T, D> u(d)</strong></td><td>空 unique_ptr，指向类型为 T 的对象 <br> <strong>用类型为 D 的可调用对象 d 来代替 delete</strong></td></tr><tr><td><strong>u = nullptr</strong></td><td>释放 u 指向的对象，将 u 置为空</td></tr><tr><td><strong>u.release()</strong></td><td>u 放弃对指针的控制权，返回指针，并将 u 置为空</td></tr><tr><td><strong>u.reset()</strong> <br> <strong>u.reset(q)</strong> <br> <strong>u.reset(nullptr)</strong></td><td>释放 u 指向的对象 <br> 如果提供了内置指针 q, 令 u 指向这个对象；否则将 u 置空</td></tr></tbody></table></div><ul><li><p>虽然不能拷贝和赋值 unique_ptr，但是可以<strong>使用 release 或 reset</strong> 将指针的所有权<strong>从一个 (非 const) unique_ptr 转移给另一个 unique_ptr</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将所有权从 p1 转移给 p2</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p2</span><span class="hljs-params">(p<span class="hljs-number">1.</span>release())</span></span>;  <span class="hljs-comment">// release 将 p1 置为空</span><br><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;Trex&quot;</span>))</span></span>;<br><span class="hljs-comment">// 将所有权从 p3 转给 p2</span><br>p<span class="hljs-number">2.</span><span class="hljs-built_in">reset</span>(p<span class="hljs-number">3.</span><span class="hljs-built_in">release</span>());   <span class="hljs-comment">// reset 释放了 p2 原来指向的内存</span><br></code></pre></td></tr></table></figure></li><li><p>release 返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值</p></li><li><p>如果不用另一个智能指针来保存 release 返回的指针程序就要负责资源的释放</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">p<span class="hljs-number">2.</span><span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 错误，p2 不会释放内存，而且丢失了指针</span><br><span class="hljs-keyword">auto</span> p = p<span class="hljs-number">2.</span><span class="hljs-built_in">release</span>();  <span class="hljs-comment">// 正确，在后面程序中要记得 delete(p)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="传递-unique-ptr-参数和返回-unique-ptr"><a href="#传递-unique-ptr-参数和返回-unique-ptr" class="headerlink" title="传递 unique_ptr 参数和返回 unique_ptr"></a>传递 unique_ptr 参数和返回 unique_ptr</h3><ul><li><p><strong>不能拷贝或赋值一个 unique_ptr 的规则有一中例外情况</strong>：<strong>可以拷贝或赋值一个即将被销毁的 unique_ptr</strong>。</p><ul><li><p>例如从函数返回一个 unique_ptr</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p));    <span class="hljs-comment">// 从 int * 创建一个 unique_ptr</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回一个局部对象的拷贝</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>  <span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>(p))</span></span>;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="向-unique-ptr-传递删除器"><a href="#向-unique-ptr-传递删除器" class="headerlink" title="向 unique_ptr 传递删除器"></a>向 unique_ptr 传递删除器</h3><ul><li>unique_ptr 也可以重载一个删除器来代替默认的 delete</li><li>与重载关联容器的比较操作类似，必须在 <code>&lt;&gt;</code> 中提供删除器类型，在创建或 reset 这种类型对象时，必须提供一个指定类型的可调用对象(删除器)</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// p 指向一个类型为 objT 的对象，使用类型为 delT 的对象释放 objT 对象</span><br><span class="hljs-comment">// 它会调用一个名为 fcn 的 delT 类型对象</span><br><span class="hljs-function">unique_ptr&lt;objT, delT&gt; <span class="hljs-title">p</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> objT, fcn)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><ul><li><strong>weak_ptr 不控制所指向对象生存周期</strong>，<strong>指向一个由 shared_ptr 管理的对象</strong></li><li>将一个 weak_ptr 绑定到一个 shared_ptr <strong>不会改变 shared_ptr 的引用计数</strong></li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>weak_ptr\<T> w</strong></td><td>空 weak_ptr，可以指向类型为 T 的对象</td></tr><tr><td><strong>weak_ptr\<T> w(sp)</strong></td><td><strong>w 与 shared_ptr sp 指向相同的对象</strong>。<br> T 必须能转换为 sp 指向的类型</td></tr><tr><td><strong>w = p</strong></td><td><strong>p 可以是</strong>一个 <strong>shared_ptr</strong> 或一个 <strong>weak_ptr</strong>。赋值后 <strong>w 与 p 共享对象</strong></td></tr><tr><td><strong>w.reset()</strong></td><td>将 w <strong>置空</strong></td></tr><tr><td><strong>w.use_count()</strong></td><td><strong>与 w 共享对象的 shared_ptr 的数量</strong></td></tr><tr><td><strong>w.expired()</strong></td><td>若 <strong>w.use_count() 为 0</strong>，<strong>返回 true</strong>，否则返回 false</td></tr><tr><td><strong>w.lock()</strong></td><td>如果 <strong>w.expired() 为 true，返回一个空 shared_ptr</strong> 。<strong>否则返回一个指向 w 的对象的 shared_ptr</strong></td></tr></tbody></table></div><ul><li>创建一个 weak_ptr 时，要<strong>用一个 shared_ptr 来初始化它</strong></li><li><strong>由于对象可能不存在</strong>，不能使用 weak_ptr 直接访问对象，<strong>必须调用 lock</strong>，此函数检查 weak_ptr 指向的对象是否存在</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(shared_ptr&lt;<span class="hljs-type">int</span>&gt; np = w.<span class="hljs-built_in">lock</span>()) &#123;   <span class="hljs-comment">// 如果 np 不为空则条件成立</span><br>  <span class="hljs-comment">// 在 if 中，np 与 w 共享对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核查指针类"><a href="#核查指针类" class="headerlink" title="核查指针类"></a>核查指针类</h3><ul><li>为 strBlob 类定义一个伴随指针类 <strong>strBlobPtr</strong>，这个类的作用类似于<strong>智能指针迭代器</strong></li><li>strBlobPtr 提供更安全的接口，具有更好的封装性，更安全的资源管理(<strong>利用 weak_ptr 避免循环引用</strong>)</li><li>strBlobPtr 有两个数据成员: wptr, curr<ul><li>wptr 或为空，或指向一个 strBlob 中的 vector</li><li>curr 保存当前对象表示的元素下标</li></ul></li><li>辅助函数 check 检查解引用 strBlobPtr 是否安全</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> KNOWLEDGETEST_STRBLOBPTR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KNOWLEDGETEST_STRBLOBPTR_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">strBlob</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">strBlobPtr</span> &#123;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> strBlobPtr &amp;, <span class="hljs-type">const</span> strBlobPtr &amp;);<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> strBlobPtr &amp;, <span class="hljs-type">const</span> strBlobPtr &amp;);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">strBlobPtr</span>() : <span class="hljs-built_in">curr</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">strBlobPtr</span>(<span class="hljs-type">const</span> strBlob &amp;a, <span class="hljs-type">size_t</span> sz = <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// deref 调用 check，检查使用 vector 是否安全以及 curr 是否在合法范围内</span><br>    <span class="hljs-function">std::string &amp; <span class="hljs-title">deref</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 前缀递增，返回递增后对象的引用</span><br>    <span class="hljs-function">strBlobPtr &amp; <span class="hljs-title">incr</span><span class="hljs-params">()</span></span>;<br><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 若检查成功，check 返回一个指向 vector 的 shared_ptr</span><br>    std::shared_ptr&lt;std::vector&lt;std::string &gt;&gt; <span class="hljs-built_in">check</span>(std::<span class="hljs-type">size_t</span> , <span class="hljs-type">const</span> std::string &amp;) <span class="hljs-type">const</span>;<br><br>    <span class="hljs-comment">// 保存一个 weak_ptr，意味着底层 vector 可能被销毁</span><br>    std::weak_ptr&lt;std::vector&lt;std::string&gt;&gt; wptr;<br>    std::<span class="hljs-type">size_t</span> curr;       <span class="hljs-comment">// 在数组中的当前位置</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//KNOWLEDGETEST_STRBLOBPTR_H</span></span><br></code></pre></td></tr></table></figure><h3 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h3><ul><li>deref ：解引用</li><li>incr: 递增 strBlobPtr</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strBlobPtr.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;strBlob.h&quot;</span></span><br><br>strBlobPtr::<span class="hljs-built_in">strBlobPtr</span>(<span class="hljs-type">const</span> strBlob &amp;a, <span class="hljs-type">size_t</span> sz) : <span class="hljs-built_in">wptr</span>(a.data), <span class="hljs-built_in">curr</span>(sz) &#123; &#125;<br><br>std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;<br>strBlobPtr::<span class="hljs-built_in">check</span>(std::<span class="hljs-type">size_t</span> i, <span class="hljs-type">const</span> std::string &amp; msg) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">auto</span> ret = wptr.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(!ret)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;unbound strBlobPtr&quot;</span>);<br>    <span class="hljs-keyword">if</span>(i &gt;= ret-&gt;<span class="hljs-built_in">size</span>())<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(msg);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function">std::string &amp; <span class="hljs-title">strBlobPtr::deref</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;dereference past end&quot;</span>);<br>    <span class="hljs-keyword">return</span> (*p)[curr];      <span class="hljs-comment">// *p 是 shared_ptr 所指向的 vector</span><br>&#125;<br><br><span class="hljs-function">strBlobPtr &amp; <span class="hljs-title">strBlobPtr::incr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 如果 curr 已经指向容器的尾后位置，就不能递增它</span><br>    <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;increment past end of strBlobPtr&quot;</span>);<br>    ++curr; <span class="hljs-comment">// 推进当前位置</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> strBlobPtr &amp; lhs, <span class="hljs-type">const</span> strBlobPtr &amp; rhs) &#123;<br>    <span class="hljs-keyword">if</span>(!lhs.wptr.<span class="hljs-built_in">expired</span>() &amp;&amp; !rhs.wptr.<span class="hljs-built_in">expired</span>()) &#123;<br>        <span class="hljs-built_in">return</span> (lhs.wptr.<span class="hljs-built_in">lock</span>() == rhs.wptr.<span class="hljs-built_in">lock</span>()) &amp;&amp; (lhs.curr == rhs.curr);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!= (<span class="hljs-type">const</span> strBlobPtr &amp; lhs, <span class="hljs-type">const</span> strBlobPtr &amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> !(lhs == rhs);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li>两个类的声明与实现都在<strong>不同的文件中</strong>，在声明 strBlobPtr 为 strBlob 的友元类时，注意<strong>使用前向声明打破循环依赖</strong>, 参考<a href="https://kin12138.github.io/2025/03/24/7.%20%E7%B1%BB/7.3%20%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/" title="类的其他特性">类之间的友元关系</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 动态内存 </tag>
            
            <tag> 智能指针 </tag>
            
            <tag> shared_ptr </tag>
            
            <tag> unique_ptr </tag>
            
            <tag> weak_ptr </tag>
            
            <tag> new </tag>
            
            <tag> delete </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.3 关联容器操作</title>
      <link href="/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.3%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.3%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>关联容器额外的类型别名</li></ul><div class="table-container"><table><thead><tr><th>Class name</th><th>Description</th></tr></thead><tbody><tr><td>key_type</td><td>此容器类型的关键字类型</td></tr><tr><td>mapped_type</td><td>每个关键字关联的类型：<strong>只适用于 map</strong></td></tr><tr><td>value_type</td><td>对于 <strong>set</strong> ，<strong>与 key_type 相同</strong> <br> 对于 <strong>map</strong>，为 <strong>pair<const key_type, mapped_type></strong></td></tr></tbody></table></div><ul><li>map 中的每个元素是一个 pair 对象，包含一个关键字和一个关联的值</li></ul><h2 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h2><ul><li>解引用一个关联容器迭代器，得到一个类型为容器的 value_type 的值的引用</li><li>一个 map 的元素类型是 pair，<strong>关键字成员类型是 const，不能被改变</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取一个迭代器</span><br><span class="hljs-keyword">auto</span> map_it = word_count.<span class="hljs-built_in">begin</span>();<br>cout &lt;&lt; map_it-&gt; first;     <span class="hljs-comment">// 打印此元素的关键字</span><br>cout &lt;&lt; map_it -&gt; second;   <span class="hljs-comment">// 打印此元素的值</span><br>map_it -&gt; first = <span class="hljs-string">&quot;new key&quot;</span>;    <span class="hljs-comment">// 错误，关键字是 const 的</span><br>++map_it -&gt; second;         <span class="hljs-comment">// 正确，可以通过迭代器改变元素的值</span><br></code></pre></td></tr></table></figure><h3 id="set-的迭代器是-const-的"><a href="#set-的迭代器是-const-的" class="headerlink" title="set 的迭代器是 const 的"></a>set 的迭代器是 const 的</h3><ul><li>set 容器同时定义了 iterator 和 const_iterator 类型，但两种类型都<strong>只允许只读访问 set 中的元素</strong></li><li>set 中的关键字也是 const 的，可以用一个迭代器来读取元素的值，但不能修改</li></ul><h3 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h3><ul><li>通常不对关联容器使用泛型算法</li><li>实际编程中，真要对关联容器使用算法，要么将它当做一个源序列，要么当做一个目的位置。</li></ul><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="关联容器的-insert-操作"><a href="#关联容器的-insert-操作" class="headerlink" title="关联容器的 insert 操作"></a>关联容器的 insert 操作</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.insert(v) <br> c.emplace(args)</td><td>v 是 value_type 类型的对象，args 用来构造一个元素 <br> 对于 map 和 set，只有当元素不在容器中时才插入或构造。<strong>函数返回一个 pair</strong>，包含<strong>一个迭代器指向具有指定关键字的元素</strong>，和<strong>一个插入是否成功的 bool 值</strong> <br> 对于 multimap 和 multiset，总是插入或构造，并</td></tr><tr><td>c.insert(b, e) <br> c.insert(il)</td><td>b, e 是迭代器范围，表示一个 c::value_type 类型值的范围，il 是这种值的花括号列表 <br> 函数返回 void <br> 对于 map 和 set 只插入不在 c 中的元素；对于 multimap 和 multiset，将所有元素插入 c 中</td></tr><tr><td>c.insert(p, v) <br> c.emplace(p, args)</td><td>类似于 c.insert(v), 但将迭代器 p 作为一个提示，指出从哪里开始搜索新元素应该插入的位置。 <br> 返回一个迭代器，指向具有给定关键字的元素</td></tr></tbody></table></div><ul><li>向 map 中添加元素，必须记住 map 中的元素是 pair 类型</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 向 map 添加元素的四种方法</span><br>word_count.<span class="hljs-built_in">insert</span>(&#123;word, <span class="hljs-number">1</span>&#125;);<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(word, <span class="hljs-number">1</span>));<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">size_t</span>&gt; (word, <span class="hljs-number">1</span>));<br>word_count.<span class="hljs-built_in">insert</span>(map&lt;string, <span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">value_type</span>(word, <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><h3 id="检测-insert-返回值"><a href="#检测-insert-返回值" class="headerlink" title="检测 insert 返回值"></a>检测 insert 返回值</h3><ul><li>insert（或 emplace）的返回值依赖于容器类型和参数</li><li><strong>不包含重复元素的容器</strong> map 和 set，<strong>insert 返回一个 pair 对象</strong>，first 成员是一个指向包含给定关键字的元素的迭代器，second 成员是一个 bool 值，若容器已有该元素，返回 false，若没有，返回 true</li></ul><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.erase(k)</td><td>从 c 中删除每个关键字为 k 的元素。<br> <strong>返回一个 size_type 的值，指出删除元素的数量</strong></td></tr><tr><td>c.erase(p)</td><td>从 c 中删除 p 指定的元素。<br> <strong>p 必须指向一个真实元素，不能等于 c.end()</strong> <br> 返回 void，若 p 指向 c 中尾元素，则返回 c.end()</td></tr><tr><td>c.erase(b, e)</td><td>b, e 是一对迭代器，表示范围。<strong>返回 e</strong></td></tr></tbody></table></div><h2 id="map-的下标操作"><a href="#map-的下标操作" class="headerlink" title="map 的下标操作"></a>map 的下标操作</h2><ul><li>map 和 unordered_map 提供了下标和 at 操作</li><li>set 没有下标操作，因为 set 的关键字没有与之对应的值</li><li>multimap 和 unordered_multimap 也没有下标操作，因为它们的关键字有多个值与之对应</li><li>map 的下标操作可以搜索容器中没有的元素，<strong>当元素在容器中不存在时，会创建一个新元素</strong></li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c[k]</td><td>返回关键字为 k 的元素；若 k 不在容器中，添加一个关键字为 k 的元素，并对其进行值初始化</td></tr><tr><td>c.at(k)</td><td>访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出一个 out_of_range 异常</td></tr></tbody></table></div><h3 id="map-下标操作的返回值"><a href="#map-下标操作的返回值" class="headerlink" title="map 下标操作的返回值"></a>map 下标操作的返回值</h3><ul><li>一般情况下，下标操作和解引用迭代器的返回值是一样的</li><li><strong>map 下标操作的返回值是 mapped_type 对象</strong>，而<strong>解引用一个 map 的迭代器会返回一个 value_type 对象</strong></li></ul><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><h3 id="在一个容器中查找元素的操作"><a href="#在一个容器中查找元素的操作" class="headerlink" title="在一个容器中查找元素的操作"></a>在一个容器中查找元素的操作</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>c.find(k)</strong></td><td>返回一个<strong>迭代器，指向第一个关键字为 k 的元素</strong>，若 k 不在容器中，则返回尾后迭代器</td></tr><tr><td><strong>c.count(k)</strong></td><td>返回关键字等于 k 的<strong>元素数量</strong>。对于不允许重复关键字的容器，返回值永远是 0 或 1</td></tr><tr><td><strong>c.lower_bound(k)</strong></td><td>返回一个迭代器，指向<strong>第一个关键字不小于 k 的元素</strong></td></tr><tr><td><strong>c.upper_bound(k)</strong></td><td>返回一个迭代器，指向<strong>第一个关键字大于 k 的元素</strong></td></tr><tr><td><strong>c.equal_range(k)</strong></td><td><strong>返回一个迭代器 pair，表示关键字等于 k 的元素范围</strong>。<br> <strong>若 k 不存在，pair 的两个成员均等于 c.end()</strong></td></tr></tbody></table></div><ul><li><strong>lower_bound 和 upper_bound 操作不适用于无序容器</strong></li><li><strong>下标和 at</strong> 操作<strong>只适用于非 const 的</strong> map 和unordered_map</li><li>只想知道元素是否在 map 中，而不想改变 map，应该使用 find</li><li>在 <strong>multimap</strong> 和 <strong>multiset</strong> 中，<strong>重复元素是相邻存储的</strong></li><li><strong>lower_bound</strong> 返回的迭代器<strong>可能指向具有给定关键字的元素，但也可能不指向</strong>。</li></ul><h3 id="equal-range-函数"><a href="#equal-range-函数" class="headerlink" title="equal_range 函数"></a>equal_range 函数</h3><ul><li>此函数接受一个关键字，返回一个迭代器 pair 。</li><li>若关键字存在，则<strong>第一个迭代器指向第一个与关键字相匹配的元素</strong>，<strong>第二个迭代器指向最后一个匹配元素之后的位置</strong>；若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置</li></ul><h2 id="一个单词转换的-map"><a href="#一个单词转换的-map" class="headerlink" title="一个单词转换的 map"></a>一个单词转换的 map</h2><p>题目：给定一个 string，将它转换为另一个 string。程序的输入是两个文件。第一个文件保存的是一些规则，用来转换第二个文件的文本。每条规则由两部分组成：一个可能出现在输入文件中的单词，和一个用来替换它的短语。表达的含义是：每当第一个单词出现在输入中时，我们就将它替换为相应的短语。第二个文件包含要转换的文本。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">transform</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str, <span class="hljs-type">const</span> std::map&lt;std::string, std::string&gt; &amp;map)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> map_it = map.<span class="hljs-built_in">find</span>(str);<br>    <span class="hljs-keyword">if</span> (map_it != map.<span class="hljs-built_in">end</span>())<br>        <span class="hljs-keyword">return</span> map_it-&gt;second;     <span class="hljs-comment">// 返回转换后的 string</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> str;     <span class="hljs-comment">// 返回原 string</span><br>&#125;<br><br><span class="hljs-function">std::map&lt;std::string, std::string&gt; <span class="hljs-title">buildMap</span><span class="hljs-params">(std::ifstream &amp; map_file)</span> </span>&#123;<br>    std::map&lt;std::string, std::string&gt; trans_rule;<br>    std::string word, sentence;<br>    <span class="hljs-keyword">while</span> (map_file &gt;&gt; word &amp;&amp; std::<span class="hljs-built_in">getline</span>(map_file, sentence)) &#123;<br>        <span class="hljs-keyword">if</span> (sentence.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)        <span class="hljs-comment">// 检查是否有转换规则</span><br>            trans_rule[word] = sentence.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 跳过空格</span><br><span class="hljs-comment">//            trans_rule.insert(&#123;word, sentence.substr(1)&#125;);</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;no rule for &quot;</span> + word);<br>    &#125;<br>    <span class="hljs-keyword">return</span> trans_rule;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">word_transform</span><span class="hljs-params">(std::ifstream &amp; map_file, std::ifstream &amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> trans_map = <span class="hljs-built_in">buildMap</span>(map_file);<br>    std::string text;       <span class="hljs-comment">// 保存输入的每行文本</span><br>    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(input, text)) &#123;<br>        <span class="hljs-function">std::istringstream <span class="hljs-title">stream</span><span class="hljs-params">(text)</span></span>;<br>        std::string word;<br>        <span class="hljs-type">bool</span> firstword = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// 控制是否打印空格</span><br>        <span class="hljs-keyword">while</span> (stream &gt;&gt; word) &#123;<br>            <span class="hljs-keyword">if</span> (firstword)<br>                firstword = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-comment">// transform 返回它的第一个参数或者抓换后的形式</span><br>            std::cout &lt;&lt; <span class="hljs-built_in">transform</span>(word, trans_map);<br>        &#125;<br>        std::cout &lt;&lt; std::endl;     <span class="hljs-comment">// 完成一行转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 关联容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.4 无序容器</title>
      <link href="/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.4%20%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
      <url>/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.4%20%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>新标准定义了 4 个无序容器</li><li>无序容器使用一个<strong>哈希函数(hash function)</strong> 和<strong>关键字类型的 <code>==</code> 运算符</strong>来组织元素</li></ul><h2 id="使用无序容器"><a href="#使用无序容器" class="headerlink" title="使用无序容器"></a>使用无序容器</h2><ul><li>通常可以用一个无序容器替换对应的有序容器，反之亦然</li></ul><h2 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h2><ul><li>无序容器<strong>在存储上组织为一组桶</strong>，每个桶保存零个或多个元素</li><li>使用一个<strong>哈希函数将元素映射到桶</strong></li><li>容器将具有<strong>特定哈希值</strong>的元素存储到一个桶中。<strong>如果允许关键字重复，则所有具有相同关键字的元素都在一个桶中</strong></li><li>访问一个元素，首先计算哈希值，指出应该搜索哪个桶</li><li>无序容器的<strong>性能依赖于哈希函数的质量</strong>和<strong>桶的数量与大小</strong></li></ul><h3 id="无序容器管理操作"><a href="#无序容器管理操作" class="headerlink" title="无序容器管理操作"></a>无序容器管理操作</h3><h4 id="桶接口"><a href="#桶接口" class="headerlink" title="桶接口"></a>桶接口</h4><div class="table-container"><table><thead><tr><th>Bucket Interface</th><th>Description</th></tr></thead><tbody><tr><td><strong>c.bucket_count()</strong></td><td>正在使用的桶的数量</td></tr><tr><td><strong>c.max_buckket_count()</strong></td><td>容器能容纳的最多的桶的数量</td></tr><tr><td><strong>c.bucket_size(n)</strong></td><td>第 n 个桶中有多少元素</td></tr><tr><td><strong>c.bucket(k)</strong></td><td>关键字为 k 的元素在哪个桶中</td></tr></tbody></table></div><h4 id="桶迭代"><a href="#桶迭代" class="headerlink" title="桶迭代"></a>桶迭代</h4><div class="table-container"><table><thead><tr><th>Bucket Iterator</th><th>Description</th></tr></thead><tbody><tr><td>local_iterator</td><td>可以用来访问桶中元素的迭代器类型</td></tr><tr><td>const_local_iterator</td><td>桶迭代器的 const 版本</td></tr><tr><td><strong>c.begin(n), c.end(n)</strong></td><td>桶 n 的首元素迭代器和尾后迭代器</td></tr><tr><td><strong>c.cbegin(n), c.cend(n)</strong></td><td>与前两个函数类似，返回 const_local_iterator</td></tr></tbody></table></div><h4 id="哈希策略"><a href="#哈希策略" class="headerlink" title="哈希策略"></a>哈希策略</h4><div class="table-container"><table><thead><tr><th>Hash Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>c.load_factor()</strong></td><td><strong>每个桶的平均元素数量，返回 float 值</strong></td></tr><tr><td><strong>c.max_load_factor()</strong></td><td>c 试图维护的平均桶大小，返回 float 值 <br> c 在需要时添加新的桶，以使得 load_factor &lt;= max_load_factor</td></tr><tr><td><strong>c.rehash(n)</strong></td><td>重组存储，使得 <strong>bucket_count &gt;= n</strong> 且 <strong>bucket_count &gt; size / max_load_factor</strong></td></tr><tr><td><strong>c.reserve(n)</strong></td><td>重组存储，使得 c 可以保存 n 个元素而不必 rehash</td></tr></tbody></table></div><h2 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h2><ul><li>默认情况下，无序容器使用关键字类型的 <code>==</code> 运算符来比较元素，还使用一个 hash<key_type> 类型的对象来生成每个元素的哈希值</li><li>不能直接定义自定义类类型的无序容器，必须提供自己的 hash 模板版本</li><li><p>不使用默认 hash，而使用一种类似于有序容器重载关键字类型的默认比较操作</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hasher</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;sd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;string&gt; () (sd.<span class="hljs-built_in">isbn</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eqOp</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp; lhs, <span class="hljs-type">const</span> Sale_data &amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>hasher 函数使用标准库 hash 类型对象来计算 ISBN 成员的 hash 值</p></li><li>eqOp 函数通过比较 ISBN 来比较两个 Sale_data 对象</li><li>使用这些函数来定义一个 unordered_multiset</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> SD_multiset = std::unordered_multiset&lt;Sale_data, <span class="hljs-keyword">decltype</span>(hasher) *, <span class="hljs-keyword">decltype</span>(eqOp) *&gt;;<br><br><span class="hljs-comment">// 参数是桶大小，哈希函数指针，相等性判断运算符指针</span><br><span class="hljs-function">SD_multiset <span class="hljs-title">bookstore</span><span class="hljs-params">(<span class="hljs-number">42</span>, hasher, eqOp)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>如果已经定义了 <code>==</code> 运算符，则只需要传入自定义的哈希函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 关联容器 </tag>
            
            <tag> 无序容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.2 关联容器概述</title>
      <link href="/2025/04/07/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.2%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/04/07/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.2%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>关联容器不支持顺序容器的位置相关操作，如 push_back，push_front</li><li>关联容器不支持构造函数或插入 操作这些接受一个元素值和一个数量值的操作</li><li>关联容器的迭代器都是双向的</li></ul><h2 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">map&lt;string, <span class="hljs-type">size_t</span>&gt; word_count; <span class="hljs-comment">// 空容器</span><br><span class="hljs-comment">// 列表初始化</span><br>set&lt;string&gt; exclude = &#123;<span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-string">&quot;but&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;or&quot;</span>&#125;;<br>map&lt;string, string&gt; authors = &#123; &#123;<span class="hljs-string">&quot;Joyce&quot;</span>, <span class="hljs-string">&quot;James&quot;</span>&#125;,<br>                                &#123;<span class="hljs-string">&quot;Austen&quot;</span>, <span class="hljs-string">&quot;Jane&quot;</span>&#125;,<br>                                &#123;<span class="hljs-string">&quot;Dickens&quot;</span>, <span class="hljs-string">&quot;Charles&quot;</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><ul><li>还可以使用另外一个同类型容器的拷贝来初始化关联容器</li></ul><h2 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h2><ul><li>有序容器 map, multimap, set, multiset 必须定义关键字比较类型，默认使用 <code>&lt;</code> 运算符</li><li>传递给排序算法的<strong>可调用对象</strong>必须满足与关联容器中关键字一样的类型要求</li></ul><h3 id="有序容器的关键字类型"><a href="#有序容器的关键字类型" class="headerlink" title="有序容器的关键字类型"></a>有序容器的关键字类型</h3><ul><li>可以<strong>自定义比较操作</strong>来代替关键字的 <code>&lt;</code> 运算符</li><li>所提供的操作必须在关键字类型上定义一个<strong>严格弱序(strict weak ordering)</strong>, 可以将严格弱序看做<strong>小于等于</strong></li><li>如果一个类型定义了 <code>&lt;</code> 运算符，则它可以用作关键字类型</li></ul><h3 id="使用关键字类型的比较函数"><a href="#使用关键字类型的比较函数" class="headerlink" title="使用关键字类型的比较函数"></a>使用关键字类型的比较函数</h3><ul><li>自定义的操作类型必须在 <code>&lt;&gt;</code> 中紧跟着元素类型给出</li><li><code>&lt;&gt;</code>中的类型仅仅是类型，当创建容器对象时，才会以构造函数形式真正提供比较操作 <strong>(其类型必须与 <code>&lt;&gt;</code> 中提供的类型相吻合)</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareISBN</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp; lhs, <span class="hljs-type">const</span> Sale_data &amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() &lt; rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// bookstore 中多条记录可以有相同的 ISBN</span><br><span class="hljs-comment">// bookstore 中的元素以 ISBN 的顺序进行排序</span><br><span class="hljs-function">std::multiset&lt;Sale_data, <span class="hljs-title">decltype</span><span class="hljs-params">(compareISBN)</span> * &gt;</span><br><span class="hljs-function">        <span class="hljs-title">bookstore</span><span class="hljs-params">(compareISBN)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><strong><code>decltype</code> 返回函数类型</strong>，而不是函数指针类型，<strong>显式的加上 <code>*</code> 表明需要指针</strong>，而不是函数本身</li><li>compareISBN 作为参数初始化 bookstore，表示在向 bookstore 添加元素时，调用 compareISBN 来排序元素</li><li>当直接使用函数名时，<strong>在需要的情况下会自动转换为指针</strong>，等价于使用 <code>&amp;compareISBN</code></li></ul><h2 id="pair-类型"><a href="#pair-类型" class="headerlink" title="pair 类型"></a>pair 类型</h2><ul><li>定义在头文件 <strong>utility</strong> 中</li><li>pair 有两个 <strong>public</strong> 数据成员： <strong>first，second</strong>。是一个模板类型，创建 pair 对象时要提供两个类型名</li><li>默认构造函数对 pair 进行值初始化</li><li>也可以对每个成员提供初始化器</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>pair <T1, T2> p</td><td>p 是一个 pair 对象，两个类型为 T1，T2 的成员进行了值初始化</td></tr><tr><td>pair <T1, T2> p(v1, v2)</td><td>pair 的 first 和 second 成员分别用 v1, v2 进行初始化</td></tr><tr><td>pair <T1, T2> p = {v1, v2}</td><td>等价于 p(v1, v2)</td></tr><tr><td><strong>make_pair(v1, v2)</strong></td><td>返回一个用 v1,v2 初始化的 pair 对象。pair 的类型从 v1, v2 的类型推断出来</td></tr><tr><td>p.first</td><td>返回 pair 的 first 成员</td></tr><tr><td>p.second</td><td>返回 pair 的 second 成员</td></tr><tr><td>p1 <strong>relop</strong> p2</td><td>关系运算符，<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>。当 <code>p1.first &lt; p2.first &amp;&amp; p1.second &lt; p2.second</code> 时，<strong>p1 &lt; p2 为 true</strong></td></tr><tr><td>p1 == p2 <br> p1 != p2</td><td>当 first 和 second 成员分别相等时，两个 pair 相等</td></tr></tbody></table></div><h3 id="创建-pair-对象的函数"><a href="#创建-pair-对象的函数" class="headerlink" title="创建 pair 对象的函数"></a>创建 pair 对象的函数</h3><ul><li>新标准下，可以对返回值进行列表初始化</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">process</span><span class="hljs-params">( vector&lt;string&gt; &amp;v)</span> </span>&#123;<br>    <span class="hljs-comment">// process v</span><br>    <span class="hljs-keyword">if</span>(!v.<span class="hljs-built_in">empty</span>()) <br>        <span class="hljs-keyword">return</span> &#123; v.<span class="hljs-built_in">back</span>(), v.<span class="hljs-built_in">size</span>() &#125;;  <span class="hljs-comment">// 列表初始化</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt; ();    <span class="hljs-comment">// 隐式构造返回值</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 关联容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.1 使用关联容器</title>
      <link href="/2025/04/05/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.1%20%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
      <url>/2025/04/05/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.1%20%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>标准库提供 8 个关联容器，它们的不同体现在：<ul><li>是 <strong>map</strong> 还是 <strong>set</strong></li><li><strong>关键字是否可以重复</strong>：可以重复的容器名含有 <strong>multi</strong>;</li><li><strong>容器元素是否有序保存</strong>：无序容器名以 <strong>unordered</strong> 开头</li></ul></li><li><strong>map</strong> 和 <strong>multimap</strong> 定义在头文件 <strong>map</strong> 中</li><li><strong>set</strong> 和 <strong>multiset</strong> 定义在头文件 <strong>set</strong> 中</li><li><p><strong>无序容器</strong>定义在头文件 <strong>unordered_map</strong> 和 <strong>unordered_set</strong> 中</p></li><li><p>按<strong>关键字有序</strong>保存元素：</p><p>  | Class | Description |<br>  | —- | —- |<br>  | <strong>map</strong> | 关联数组，保存<strong>关键字-值</strong>对 |<br>  | <strong>set</strong> | 关键字即值，即<strong>只保存关键字</strong>的容器 |<br>  | <strong>multimap</strong> | 关键字可重复出现的 map |<br>  | <strong>multiset</strong> | 关键字可重复出现的 set |</p></li><li><p><strong>关键字无序</strong>集合</p><p>  | Class | Description |<br>  | —- | —- |<br>  | <strong>unordered_map</strong> | 用 hash 函数组织的 map |<br>  | <strong>unordered_set</strong> | 用 hash 函数组织的 set |<br>  | <strong>unordered_multimap</strong> | hash 组织的 map：关键字可重复出现 |<br>  | <strong>unordered_multiset</strong> | hash 组织的 set：关键字可重复出现 |</p></li></ul><h2 id="使用-map"><a href="#使用-map" class="headerlink" title="使用 map"></a>使用 map</h2><ul><li>关联容器是模板，定义 map 必须指明<strong>关键字和值的类型</strong></li><li>map 被称为<strong>关联数组</strong>，使用 map，是<strong>用关键字作为下标</strong>：<code>word_count[word]</code>, word 为关键字；当 word 不在 map 中时，<strong>下标运算符会创建一个新元素</strong>，新元素关键字值是 word</li><li><strong>从 map 中提取</strong>一个元素，会得到一个 <strong>pair 类型对象</strong>。pair 是模板类型，有两个 public 成员： <strong>first 和 second</strong>。map 使用的 pair 用 <strong>first 保存 关键字</strong>，用 <strong>second 保存对应的值</strong></li></ul><h2 id="使用-set"><a href="#使用-set" class="headerlink" title="使用 set"></a>使用 set</h2><ul><li>可以对一个关联容器的元素进行<strong>列表初始化</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 关联容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.6 特定容器算法</title>
      <link href="/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.6%20%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.6%20%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>list</strong> 和 <strong>forward_list</strong> 定义了几个成员函数形式的算法</li><li>特别是定义了<strong>独有的 sort, merge, remove, reverse, unique</strong></li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>lst.merge(lst2)</strong> <br> <strong>lst.merge(lst2, comp)</strong></td><td>将 lst2 中的元素合并入 lst 中。要求两个链表<strong>必须有序</strong> <br> 元素从 lst2 中被删除，合并之后 lst2 变为空 <br> 第一个版本使用 <code>&lt;</code> 运算符，第二个版本使用给定的比较操作 comp</td></tr><tr><td><strong>lst.remove(val) <br> lst.remove_if(pred)</strong></td><td>调用 erase 删除<strong>与给定值 (val) 相等</strong>或<strong>令谓词 (pred) 为真</strong>的每个元素</td></tr><tr><td><strong>lst.reverse()</strong></td><td>翻转 lst 中元素的顺序</td></tr><tr><td><strong>lst.sort() <br> lst.sort(pred)</strong></td><td>使用 <code>&lt;</code> 或给定比较操作排序元素</td></tr><tr><td><strong>lst.unique() <br> lst.unique(pred)</strong></td><td>调用 erase 删除同一个值的拷贝。<br> 第一个版本使用 <strong><code>==</code></strong>, 第二个版本使用给定的<strong>二元谓词</strong></td></tr></tbody></table></div><ul><li>所有操作都返回 void</li></ul><h2 id="splice-成员"><a href="#splice-成员" class="headerlink" title="splice 成员"></a>splice 成员</h2><ul><li>此算法是<strong>链表结构所特有的</strong></li><li>调用形式有： <strong><code>lst.splice(args)</code></strong> 或 <strong><code>flst.splice_after(args)</code></strong></li><li><p>args 的形式：</p><p>  | Arguments | Description |<br>  | —- | —- |<br>  | <strong>(p, lst2)</strong> | p 是指向 lst 中元素的迭代器，或是一个指向 flst 首前位置的迭代器 <br> 函数将 lst2 中的元素 <strong>lst 中 p 之前</strong>的位置或 <strong>flst 中 p 之后</strong>的位置。将元素从 lst2 中删除 <br> lst2 必须与lst 或 flst <strong>类型相同且不能是同一个链表</strong> |<br>  | <strong>(p, lst2, p2)</strong> | p2 是指向 lst2 中位置的有效迭代器 <br> 将 <strong>p2 指向的元素移动到 lst</strong> 中，或是将 <strong>p2 之后的元素移动到 flst 中</strong> <br> <strong>lst2 可以是与 lst 或 flst 相同的链表</strong> |<br>  | <strong>(p, lst2, b, e)</strong> | b, e 必须表示 lst2 的合法范围 <br> 将给定范围的元素从 lst2 移动到 lst 或 flst。<br> <strong>lst2 与 lst(或 flst) 可以是相同的链表</strong>，但 <strong>p 不能指向b, ef范围内的元素</strong> |</p></li></ul><h2 id="链表特有的操作会改变容器"><a href="#链表特有的操作会改变容器" class="headerlink" title="链表特有的操作会改变容器"></a>链表特有的操作会改变容器</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
            <tag> 特定容器算法 </tag>
            
            <tag> list 特定算法 </tag>
            
            <tag> forward_list 特定算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.4 再探迭代器</title>
      <link href="/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.4%20%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.4%20%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在头文件 iterator 中还定义了额外的迭代器</p><ul><li>插入迭代器(insert iterator)：可用来向容器插入元素</li><li>流迭代器(stream iterator): 可用来遍历所关联的流</li><li>反向迭代器(reverse iterator)</li><li>移动迭代器(move iterator)</li></ul><h2 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h2><ul><li><strong>back_inserter</strong>: 创建一个使用 <strong>push_back</strong> 的迭代器</li><li><strong>front_inserter</strong>: 创建一个使用 <strong>push_front</strong> 的迭代器， <strong>只有在容器支持 push_front 的情况下</strong>才可以使用 front_inserter</li><li><strong>inserter</strong>: 创建一个使用 <strong>insert</strong> 的迭代器。此函数接受第二个参数，<strong>第二个参数必须是指向给定容器的迭代器</strong>。被插元素将<strong>插入到给定迭代器指向的元素之前</strong></li><li>操作：<ul><li><code>it = t</code> 在 it 指定的当前位置插入值 t。</li><li><em>it, ++it, it++ 虽然都存在，但是不会对 it 做任何操作。<em>*每个操作都返回 it</em></em></li></ul></li><li><p>调用 inserter(c, iter), 得到一个迭代器 it, 使用这个新迭代器将新元素插入到 iter 指定的元素之前</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">*it = val;<br></code></pre></td></tr></table></figure><ul><li>等价于：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">it = c.<span class="hljs-built_in">insert</span>(it, val);   <span class="hljs-comment">// it 指向新插入元素</span><br>++it;   <span class="hljs-comment">// 递增 it 使它指向原来的元素</span><br></code></pre></td></tr></table></figure></li><li><p>调用 front_inserter，新元素总是插入到容器的第一个元素之前</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; lst&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>list&lt;<span class="hljs-type">int</span>&gt; lst2, lst3;<br><br><span class="hljs-comment">// 拷贝完成后，lst2 包含元素 4,3,2,1</span><br><span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">begin</span>(), lst.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">front_inserter</span>(lst2));<br><br><span class="hljs-comment">// 拷贝完成后，lst3 包含元素 1,2,3,4</span><br><span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">begin</span>(), lst.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(lst3, lst<span class="hljs-number">3.</span><span class="hljs-built_in">begin</span>()))<br></code></pre></td></tr></table></figure><h2 id="iostream-迭代器"><a href="#iostream-迭代器" class="headerlink" title="iostream 迭代器"></a>iostream 迭代器</h2><ul><li>istream_iterator: 读取输入流</li><li>ostream_iterator: 向输出流写数据</li></ul><h3 id="istream-iterator-操作"><a href="#istream-iterator-操作" class="headerlink" title="istream_iterator 操作"></a>istream_iterator 操作</h3><ul><li>将 <strong>istream_iterator</strong> <strong>绑定到一个流</strong></li><li>默认初始化 istream_iterator，相当于 <strong>尾后迭代器</strong></li><li><p>istream_iterator 更有用的地方在于：<strong>可以使用迭代器范围，从输入流获取元素构造容器</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">int_it</span><span class="hljs-params">(cin)</span>, eof</span>; <span class="hljs-comment">// 从 cin 读取</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(int_it, eof)</span></span>;      <span class="hljs-comment">// 用迭代器范围构造 vec</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用算法操作流迭代器"><a href="#使用算法操作流迭代器" class="headerlink" title="使用算法操作流迭代器"></a>使用算法操作流迭代器</h4><ul><li>示例</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream_itertor&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">int_it</span><span class="hljs-params">(cin)</span>, eof</span>;<br>std::cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(int_it, eof, <span class="hljs-number">0</span>) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h4 id="istream-iterator-允许使用懒惰求值"><a href="#istream-iterator-允许使用懒惰求值" class="headerlink" title="istream_iterator 允许使用懒惰求值"></a>istream_iterator 允许使用懒惰求值</h4><ul><li>当 istream_iterator 绑定到一个流，标准库并<strong>不保证迭代器立即从流读取数据</strong>，使用迭代器时才真正读取</li><li>标准库保证在<strong>第一次使用解引用迭代器之前</strong>，从流中<strong>读取数据的操作已经完成</strong></li></ul><h3 id="ostream-iterator-操作"><a href="#ostream-iterator-操作" class="headerlink" title="ostream_iterator 操作"></a>ostream_iterator 操作</h3><ul><li>在创建 ostream_iterator 时，可以提供（可选的）第二参数，是字符串，在<strong>输出每个元素后都会打印此字符串</strong>。此字符串必须是一个 <strong>C 风格字符串</strong>，</li><li><p><strong>必须将 ostream_iterator 绑定到一个指定的流</strong>，<strong>不允许</strong>一个<strong>空的</strong>或<strong>表示尾后位置</strong>的 ostream_iterator</p><ul><li>ostream_iterator<T> out(cout);</li><li><strong><code>out = val;</code></strong>  // 用 &lt;&lt; 运算符将 val 写入到 out 绑定的 ostream 中, val 类型必须与 out 可写类型兼容</li><li><code>*out, out++, ++out</code> 都存在，但不对 out 做任何操作。每个运算符都返回 out</li><li><p>对于一个输出容器元素的循环，可以写为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out</span><span class="hljs-params">(cout, <span class="hljs-string">&quot; &quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; item: vec)<br>  out = item;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>可以通过 copy 来打印元素，比循环更简单</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">copy</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), out);<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h3><ul><li>可以为任何定义了 <code>&gt;&gt;</code> 的类型创建 istream_iterator</li><li>为任何定义了 <code>&lt;&lt;</code> 的类型创建 ostream_iterator</li></ul><h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><ul><li><strong>从尾元素向首元素反向移动</strong></li><li><code>++it</code> 操作会<strong>移动到前一个</strong>元素</li><li><code>--it</code> 操作会<strong>移动到后一个</strong>元素</li><li><strong>除 forward_list 之外</strong>，其他容器都支持反向迭代器</li></ul><h3 id="反向迭代器与普通迭代器的关系"><a href="#反向迭代器与普通迭代器的关系" class="headerlink" title="反向迭代器与普通迭代器的关系"></a>反向迭代器与普通迭代器的关系</h3><ul><li>对于一个 string 元素 “WORD””，使用<strong>普通迭代器输出</strong>为：<strong>“WORD”</strong> ；使用<strong>反向迭代器</strong>输出为 <strong>“DROW”</strong></li><li>反向迭代器的<strong>目的是表示元素范围</strong>，这些范围与普通迭代器指向的范围并不对称</li><li>调用 base() 将反向迭代器转换为普通迭代器</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.5 泛型算法结构</title>
      <link href="/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.5%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84/"/>
      <url>/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.5%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<ul><li>任何算法最基本特性就是它要求其迭代器做哪些操作</li><li>每个算法对它的每个迭代器参数指明需要提供哪类迭代器</li></ul><h2 id="五类迭代器"><a href="#五类迭代器" class="headerlink" title="五类迭代器"></a>五类迭代器</h2><ul><li>算法所要求的迭代器分为五类：<ul><li><strong>输入迭代器</strong>：<strong>只读不写</strong>、单遍扫描、<strong>只能递增</strong></li><li><strong>输出迭代器</strong>：<strong>只写不读</strong>、单遍扫描、<strong>只能递增</strong></li><li><strong>前向迭代器</strong>：<strong>可读写</strong>、多遍扫描、<strong>只能递增</strong></li><li><strong>双向迭代器</strong>：<strong>可读写</strong>、多遍扫描、<strong>可递增可递减</strong></li><li><strong>随机访问迭代器</strong>：<strong>可读写</strong>、多遍扫描、<strong>支持全部迭代器操作</strong></li></ul></li></ul><h3 id="输入迭代器-input-iterator"><a href="#输入迭代器-input-iterator" class="headerlink" title="输入迭代器(input iterator)"></a>输入迭代器(input iterator)</h3><ul><li>可以读取序列中的元素</li><li>支持操作：<ul><li><code>==</code> <code>!=</code> 比较两个迭代器的相等与不相等</li><li><code>++</code> 递增运算</li><li><code>*</code> 解引用运算符：<strong>只会出现在赋值运算符右侧</strong></li><li><code>-&gt;</code> 箭头运算符：等价于 <code>(*it).member</code>，解引用迭代器，并调用对象成员</li></ul></li><li><strong>只用于顺序访问</strong></li><li>单遍扫描</li><li>递增输入迭代器可能导致其他指向流的迭代器失效</li></ul><h3 id="输出迭代器-output-iterator"><a href="#输出迭代器-output-iterator" class="headerlink" title="输出迭代器(output iterator)"></a>输出迭代器(output iterator)</h3><ul><li>只写而不读元素</li><li>支持操作<ul><li><code>++</code></li><li><code>*</code> 解引用运算符，<strong>只出现在赋值运算符的左侧</strong>（向一个解引用的输出迭代器赋值，就是将值写入它所指向的元素）</li></ul></li><li>只能向一个输出迭代器赋值一次；</li><li>单遍扫描</li><li>通常用作目的位置迭代器</li></ul><h3 id="前向迭代器-forward-iterator"><a href="#前向迭代器-forward-iterator" class="headerlink" title="前向迭代器(forward iterator)"></a>前向迭代器(forward iterator)</h3><ul><li>可读写元素</li><li>只能在序列中延一个方向移动</li><li>支持所有输入迭代器和输出迭代器的操作</li><li>可多次读写同一元素</li><li>可以保存迭代器状态，可对序列进行多遍扫描，forward_list 上的迭代器都是前向迭代器</li></ul><h3 id="双向迭代器-bidirectional-iterator"><a href="#双向迭代器-bidirectional-iterator" class="headerlink" title="双向迭代器(bidirectional iterator)"></a>双向迭代器(bidirectional iterator)</h3><ul><li>可以正向/反向读写元素</li><li>支持所有前向迭代器的操作，还支持 <code>--</code> 递减运算符，除 forward_list 之外，其他容器都提供双向迭代器</li></ul><h3 id="随机访问迭代器-random-access-iterator"><a href="#随机访问迭代器-random-access-iterator" class="headerlink" title="随机访问迭代器(random-access iterator)"></a>随机访问迭代器(random-access iterator)</h3><ul><li>在常量时间内访问序列中的任何元素</li><li>支持所有双向迭代器的所有功能，还支持：<ul><li><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></li><li><strong>迭代器和一个数值</strong>的加减操作：<code>+</code> <code>+=</code> <code>-</code> <code>-=</code> : 计算结果是迭代器在序列中前进(或后退)给定整数个元素后的位置</li><li>两个迭代器的减法运算符：<code>-</code>，得到两个迭代器的距离</li><li>下表运算符(<code>iter[n]</code>)，与 <code>*(iter[n])</code> 等价</li></ul></li></ul><h2 id="算法形参形式"><a href="#算法形参形式" class="headerlink" title="算法形参形式"></a>算法形参形式</h2><h3 id="接受单个目标迭代器的算法"><a href="#接受单个目标迭代器的算法" class="headerlink" title="接受单个目标迭代器的算法"></a>接受单个目标迭代器的算法</h3><ul><li>向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据</li></ul><h3 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h3><ul><li>这类算法通常将两个输入序列中的元素结合进行操作</li></ul><h2 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h2><h3 id="重载形式传递谓词"><a href="#重载形式传递谓词" class="headerlink" title="重载形式传递谓词"></a>重载形式传递谓词</h3><ul><li>函数名称相同，参数数量不同</li></ul><h3 id="if-版本的算法"><a href="#if-版本的算法" class="headerlink" title="_if 版本的算法"></a>_if 版本的算法</h3><ul><li>函数名称不同，参数数量相同</li></ul><h3 id="区分拷贝元素的版本和不拷贝元素的版本"><a href="#区分拷贝元素的版本和不拷贝元素的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝元素的版本"></a>区分拷贝元素的版本和不拷贝元素的版本</h3><ul><li>大多在算法名后加 <strong><code>_copy</code></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 泛型算法结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.1 泛型算法概述</title>
      <link href="/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.1%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.1%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>大多数算法在 algorithm 头文件中</li><li>numeric 头文件中有一组数值泛型算法</li><li>一般，算法<strong>不直接操作容器</strong>，而是遍历由<strong>两个迭代器指定范围</strong>内的元素来进行操作</li></ul><h2 id="迭代器算法不依赖于容器"><a href="#迭代器算法不依赖于容器" class="headerlink" title="迭代器算法不依赖于容器"></a>迭代器算法不依赖于容器</h2><ul><li>使用<strong>迭代器解引用运算符</strong>实现元素访问</li><li><strong>返回</strong>指向匹配元素的<strong>迭代器</strong></li></ul><h2 id="算法依赖于元素类型的操作"><a href="#算法依赖于元素类型的操作" class="headerlink" title="算法依赖于元素类型的操作"></a>算法依赖于元素类型的操作</h2><ul><li>大多数算法都使用一个或多个元素类型上的操作</li></ul><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><ul><li>算法永远不会改变底层容器的大小</li><li>算法可能改变容器内元素的值，但永远不会直接添加或删除元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.3 标准库算法的定制操作</title>
      <link href="/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.3%20%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.3%20%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>许多算法使用元素类型的 <code>&lt;</code>, <code>==</code>完成比较</li><li>标准库还定义了额外版本，允许提供自定义的操作代替默认运算符</li></ul><h2 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h2><h3 id="谓词-predicate"><a href="#谓词-predicate" class="headerlink" title="谓词(predicate)"></a>谓词(predicate)</h3><ul><li>谓词是<strong>可调用的表达式</strong></li><li>标准库算法使用的谓词分为两类：<ul><li><strong>一元谓词</strong>(unary predicate)：只<strong>接受单一参数</strong></li><li><strong>二元谓词</strong>(binary predicate)：有<strong>两个参数</strong></li></ul></li><li>输入序列中的<strong>元素类型必须能转换为谓词的参数类型</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 比较函数，用来按长度排序单词</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-comment">// 按长度由短到长排序 words</span><br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), isShorter);<br></code></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>stable_sort(b, e, compare)</strong></td><td><strong>排序之后仍保持元素的相对顺序</strong> <br> b, e 是要排序的范围 <br> <strong>compare 是可选的比较函数对象</strong> <br> 返回 void</td></tr></tbody></table></div><hr><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>find_if(b, e, lambda)</strong></td><td>功能与 find 相似，查找第一个具有特定大小的元素<br> b, e 是表示输入序列的迭代器，<strong>第三个参数是谓词</strong> <br> 返回指向第一个<strong>使谓词返回值非 0</strong> 的元素的迭代器，如果<strong>不存在</strong>，<strong>返回尾迭代器</strong></td></tr></tbody></table></div><h3 id="了解-lambda-表达式"><a href="#了解-lambda-表达式" class="headerlink" title="了解 lambda 表达式"></a>了解 lambda 表达式</h3><ul><li>可以向算法传递任何类别的<strong>可调用对象(callable object)</strong></li><li>可调用对象有：<ul><li>函数</li><li>函数指针</li><li>lambda 表达式</li><li>重载了函数调用运算符的类</li></ul></li><li><p>lambda 具有返回类型、参数列表、函数体，一个 lambda 表达式具有如下形式：</p><ul><li><strong><code>[capture list] (parameter list) -&gt; return type &#123; function body &#125;</code></strong></li><li><strong>capture list</strong>: <strong>捕获列表，lambda</strong> <strong>所在函数中定义的局部变量的列表</strong>（通常为空）</li><li>parameter list， return type, function body 与普通函数含义一样</li><li>与普通函数不同的是，<strong>lambda 必须使用尾置返回，来指定返回类型</strong></li><li>可以忽略参数列表和返回类型，但<strong>必须永远包含捕获列表和函数体</strong></li><li><p>lambda 调用方式与普通函数调用方式相同，都使用调用运算符</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义一个可调用对象 f, 不接受参数，返回 42</span><br><span class="hljs-keyword">auto</span> f = [] &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-comment">// 调用 f 打印 42</span><br>cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>lambda 中忽略括号和参数列表，<strong>等价于指定一个空参数列表</strong></p></li><li>忽略返回类型，lambda <strong>根据函数体中代码推断返回类型</strong><ul><li>如果<strong>函数体</strong>只是<strong>一条 return 语句</strong>，则<strong>返回类型从返回的表达式推断</strong></li><li>如果 lambda 函数体包含任何单一 <strong>return 语句之外的内容</strong>，且<strong>未指定返回类型</strong>，则<strong>返回 void</strong></li></ul></li></ul></li></ul><h3 id="向-lambda-传递参数"><a href="#向-lambda-传递参数" class="headerlink" title="向 lambda 传递参数"></a>向 lambda 传递参数</h3><ul><li><strong>lambda 形参不能有默认值</strong>，因此 lambda 调用的实参数目永远与形参数目相等</li><li><p>与 isShorter 函数功能相同的 lambda 表达式</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">[] (<span class="hljs-type">const</span> string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)<br>    &#123; <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); &#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 lambda 表达式</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stable_sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(),<br>            [] (<span class="hljs-type">const</span> string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)<br>            &#123; <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h3><ul><li>lambda 只能使用所在函数中明确指定的</li><li><strong>捕获列表</strong>中是逗号隔开的名字列表，这些名字是所在函数中的<strong>局部变量</strong></li><li>一个 lambda <strong>只有在其捕获列表中捕获一个它所在函数中的局部变量</strong>，<strong>才能在函数体中使用该变量</strong></li></ul><h3 id="find-if-算法"><a href="#find-if-算法" class="headerlink" title="find_if 算法"></a>find_if 算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td>find_if(b, e, lambda)</td><td>b, e 表示输入范围 <br> lambda 是一元谓词 <br> <strong>返回指向第一个使一元谓词为 true 到迭代器</strong>，若未找到，返回迭代器 e</td></tr></tbody></table></div><h3 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each 算法"></a>for_each 算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td>for_each(b, e, lambda)</td><td>b, e 表示要遍历的范围 <br> lambda 是一个<strong>一元谓词，接受范围内元素的引用作为参数</strong> <br> 返回值：返回传入的可调用对象的副本</td></tr></tbody></table></div><ul><li><strong>捕获列表只用于局部非 static 变量</strong>，lambda 函数体<strong>内可以直接使用局部 static 变量</strong>和<strong>它所在函数之外声明的名字</strong></li></ul><h3 id="biggies-练习"><a href="#biggies-练习" class="headerlink" title="biggies 练习"></a>biggies 练习</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">elimDups</span><span class="hljs-params">(std::vector&lt;std::string&gt; &amp; words)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">auto</span> iter = std::<span class="hljs-built_in">unique</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>());<br>    words.<span class="hljs-built_in">erase</span>(iter, words.<span class="hljs-built_in">end</span>());<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">make_plural</span><span class="hljs-params">(<span class="hljs-type">size_t</span> count, <span class="hljs-type">const</span> std::string &amp; str, <span class="hljs-type">const</span> std::string &amp; ending)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> count &gt; <span class="hljs-number">1</span> ? str + ending : str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">biggies</span><span class="hljs-params">(std::vector&lt;std::string&gt; &amp; words, std::vector&lt;std::string&gt;::size_type sz)</span> </span>&#123;<br>    <span class="hljs-comment">// 将 words 按字典序排序，删除重复元素</span><br>    <span class="hljs-built_in">elimDups</span>(words);<br>    <span class="hljs-comment">// 按长度排序，长度相同的维持字典序</span><br>    std::<span class="hljs-built_in">stable_sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                     [] (<span class="hljs-type">const</span> std::string &amp; s1, <span class="hljs-type">const</span> std::string &amp; s2)<br>                     &#123; <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();&#125;);<br>    <span class="hljs-comment">// 获取一个迭代器，指向第一个满足 size() &gt;= sz 的元素</span><br>    <span class="hljs-keyword">auto</span> wc = std::<span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                           [sz] (<span class="hljs-type">const</span> std::string &amp; s)<br>                           &#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &gt;= sz;&#125;);<br>    <span class="hljs-comment">// 计算满足 size() &gt;= sz 的元素数量</span><br>    <span class="hljs-keyword">auto</span> count = words.<span class="hljs-built_in">end</span>() - wc;<br>    std::cout &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">make_plural</span>(count, <span class="hljs-string">&quot;word&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>) &lt;&lt; <span class="hljs-string">&quot; of length &quot;</span> &lt;&lt; sz<br>                &lt;&lt; <span class="hljs-string">&quot; or longer.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 打印长度大于等于给定值的单词，每个单词后接一个空格</span><br>    std::for_each(wc, words.<span class="hljs-built_in">end</span>(),<br>                  [sz] (<span class="hljs-type">const</span> std::string &amp; s)<br>                  &#123;std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;);<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testBiggies</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::string&gt; words&#123;<span class="hljs-string">&quot;fd&quot;</span>, <span class="hljs-string">&quot;fds&quot;</span>, <span class="hljs-string">&quot;qw&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;fdasf&quot;</span>, <span class="hljs-string">&quot;dfsdafd&quot;</span>, <span class="hljs-string">&quot;afd&quot;</span>, <span class="hljs-string">&quot;fadsf&quot;</span>, <span class="hljs-string">&quot;dfasdsaf&quot;</span>, <span class="hljs-string">&quot;fdakhuiohiohu&quot;</span>&#125;;<br>    <span class="hljs-built_in">biggies</span>(words, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="partition-算法"><a href="#partition-算法" class="headerlink" title="partition 算法"></a>partition 算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>partition(b, e, UnaryPredicate)</strong></td><td>根据一元谓词函数重排指定范围元素，使<strong>谓词函数为 true</strong> 的元素放于<strong>前半部分</strong>，为 <strong>false</strong> 的元素放在<strong>后半部分</strong> <br> UnaryPredicate 是<strong>一元谓词</strong> <br> <strong>返回一个迭代器</strong>，指向<strong>第一个使谓词为 false</strong> 的元素</td></tr></tbody></table></div><h2 id="lambda-捕获和返回"><a href="#lambda-捕获和返回" class="headerlink" title="lambda 捕获和返回"></a>lambda 捕获和返回</h2><ul><li>当定义一个 lambda 时，编译器生成了一个与 lambda 对应的新的（未命名）类类型</li><li>可以这样理解，当向一个函数传递 lambda 时，同时定义了一个新类型和该类型的对象：传递的参数就是编译器生成的类类型的未命名对象</li><li>默认情况下，<strong>从 lambda 生成的类</strong>都<strong>包含</strong>对应于<strong>该 lambda 所捕获变量的数据成员</strong>。lambda 的数据成员也在 lambda 对象创建时初始化</li></ul><h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><ul><li>变量的捕获方式可以是<strong>值</strong>或<strong>引用</strong></li><li><p>采用<strong>值捕获的前提是变量可以拷贝</strong>，被捕获变量的值是在 lambda 创建时拷贝，而不是在调用时拷贝</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>; <span class="hljs-comment">// 局部变量</span><br>  <span class="hljs-keyword">auto</span> f = [v1] &#123; <span class="hljs-keyword">return</span> v1; &#125;;<br>  v1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// j 为 42，f 保存了创建它时对 v1 的拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">auto</span> f = [&amp;v1] &#123; <span class="hljs-keyword">return</span> v1; &#125;;<br>  v1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>();   <span class="hljs-comment">// j 为 0，f 保存 v1 的引用，而不是拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>捕获引用</strong>，在 lambda 函数体内使用此变量时，<strong>实际使用的是引用绑定的对象</strong></li><li><strong>必须确保被引用对象在 lambda 执行的时候是存在的</strong></li><li><strong>可以从一个函数返回 lambda</strong>。如果函数返回一个 lambda，则与函数不能返回局部变量的引用类似，<strong>此 lambda 不能包含引用捕获</strong></li></ul><h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><ul><li>可以让编译器根据 lambda 体中的代码来判断要使用哪些变量</li><li>在捕获列表中写入 <strong>&amp;</strong> 或 <strong>=</strong><ul><li><strong>&amp;</strong> 告诉编译器采用<strong>捕获引用</strong>方式</li><li><strong>=</strong> 表示采用<strong>值捕获</strong>方式</li></ul></li><li>显示捕获可以与隐式捕获同时使用<ul><li>当<strong>混合使用</strong>时，<strong>捕获列表中第一个元素必须是一个 &amp; 或 =</strong></li><li><strong>显示捕获</strong>的变量<strong>必须使用与隐式捕获不同的方式</strong><ul><li>隐式捕获是引用方式，显示捕获就必须是值捕获方式</li><li>隐式捕获是值捕获方式，显示捕获就必须是引用捕获方式</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">biggies</span><span class="hljs-params">(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz,</span></span><br><span class="hljs-params"><span class="hljs-function">              ostream &amp; os = cout, <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27; &#x27;</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// os 隐式捕获，引用捕获方式，c 显示捕获，值捕获方式</span><br>  for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>          [&amp;, c](<span class="hljs-type">const</span> string &amp;s) <br>          &#123; os &lt;&lt; s &lt;&lt; c; &#125;);<br><br>  <span class="hljs-comment">// os 显示捕获，引用捕获方式，c 隐式捕获，值捕获方式</span><br>  for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>          [=, os] (<span class="hljs-type">const</span> string &amp;s)<br>          &#123; os &lt;&lt; s &lt;&lt; c; &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可变-lambda"><a href="#可变-lambda" class="headerlink" title="可变 lambda"></a>可变 lambda</h3><ul><li>默认情况下，一个值被拷贝的变量，lambda 不会改变其值</li><li>如果希望能改变一个被捕获变量的值，就必须<strong>在参数列表首加上 mutable</strong></li><li>可变 lambda 能省略参数列表</li></ul><h3 id="指定-lambda-返回类型"><a href="#指定-lambda-返回类型" class="headerlink" title="指定 lambda 返回类型"></a>指定 lambda 返回类型</h3><ul><li>如果一个 lambda 体包含处 return 之外的任何语句，则编译器假定此 lambda 返回 void</li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>transform(b1, e1, b2, UnaryPredicate)</strong></td><td>对于给定范围内的元素应用给定的操作，并将结果存储到目的范围内。<br> b, e 是输入范围起始与结束迭代器。b2 是输出范围起始迭代器 <br> UnaryPredicate 可调用对象可以是一元谓词，也可以是二元谓词 <br> <strong>返回一个迭代器，指向输出范围最后一个转换结果之后的位置</strong></td></tr></tbody></table></div><ul><li>transform 中<strong>目的位置迭代器</strong> b2 <strong>可以</strong>与<strong>输入范围的开始位置迭代器</strong> b1 <strong>相同</strong></li><li>当需要为 lambda 定义返回类型时，必须使用尾置返回类型</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">transform</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), vec.<span class="hljs-built_in">begin</span>(),<br>          [] (<span class="hljs-type">const</span> <span class="hljs-type">int</span> i) -&gt; <span class="hljs-type">int</span><br>          &#123; <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -i; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;&#125;)<br></code></pre></td></tr></table></figure><h3 id="count-if-算法"><a href="#count-if-算法" class="headerlink" title="count_if 算法"></a>count_if 算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>count_if(b, e, UnaryPredicate)</strong></td><td>b, e 表示输入范围 <br> 谓词 UnaryPredicate 会对输入范围的每个元素执行 <br> <strong>返回一个计数值，表示谓词有多少次为真</strong></td></tr></tbody></table></div><hr><h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><ul><li>如果 lambda 的捕获列表为空，通常可以使用函数来代替</li><li>但是对于捕获局部变量的 lambda，就要确认算法接受一元谓词还是二元谓词<ul><li>如果只接受一元谓词，但是我们传入的参数除了输入范围元素，还有局部变量，就不行</li></ul></li></ul><h3 id="标准库-bind-函数"><a href="#标准库-bind-函数" class="headerlink" title="标准库 bind 函数"></a>标准库 bind 函数</h3><ul><li><strong>bind</strong> 函数，定义在头文件 <strong>functional</strong> 中</li><li>可以将 bind 看做通用函数适配器：<strong>接受一个可调用对象</strong>，<strong>生成一个新的可调用对象来适应原对象的参数列表</strong></li><li>一般形式<ul><li><code>auto newCallable = bind(callable, args_list);</code></li><li><strong>newCallable 本身是一个可调用对象</strong></li><li><strong>args_list</strong> 是一个逗号分隔的参数列表，<strong>对应给定 callable 的参数</strong></li><li>当调用 newCallable 时， <strong>newCallable 会调用 callable</strong>，<strong>并传递给它 args_list 中的参数</strong></li></ul></li><li>args_list 中参数形式：<ul><li>形如 <strong><code>_n</code></strong>,n 是整数</li><li>这些参数是<strong>占位符</strong>，表示 <strong>newCallable</strong> 的参数，占据了传递给 newCallable 的参数的位置</li><li><strong>n 表示生成的可调用对象中参数的位置</strong>：<code>_1</code> 为 newCallable 的第一个参数，<code>_2</code> 为 newCallable 的第二个参数</li></ul></li><li><p>利用 bind 可以将基于 lambda 的 find_if 调用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                  [sz] (<span class="hljs-type">const</span> string &amp; s)<br>                  &#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &gt;= sz;&#125;);<br></code></pre></td></tr></table></figure></li><li><p>替换为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                  <span class="hljs-built_in">bind</span>(check_size, _1, sz));<br></code></pre></td></tr></table></figure><ul><li>bind 生成一个可调用对象，将 check_size 的第二个参数绑定到 sz 的值</li></ul></li></ul><h3 id="使用-placeholders-名字"><a href="#使用-placeholders-名字" class="headerlink" title="使用 placeholders 名字"></a>使用 placeholders 名字</h3><ul><li><p><strong>名字 <code>_n</code></strong> 都定义在 <strong>placeholders</strong> 命名空间中，而 placeholders 本身定义在 <strong>std</strong> 命名空间中，<strong>使用这些名字时，两个命名空间都要写上</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> std::placeholders::_1;<br></code></pre></td></tr></table></figure></li></ul><h3 id="bind-的参数"><a href="#bind-的参数" class="headerlink" title="bind 的参数"></a>bind 的参数</h3><ul><li>可以用 bind 绑定给定可调用对象中的参数或重新安排其顺序</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// g 是一个有两个参数的可调用对象</span><br><span class="hljs-keyword">auto</span> g = <span class="hljs-built_in">bind</span>(f, a, b, _2, c, _1);<br></code></pre></td></tr></table></figure><ul><li>传递给 g 的<strong>参数按位置绑定到占位符</strong>。<ul><li><strong>第一个参数绑定到 <code>_1</code></strong>, <strong>第二个参数绑定到 <code>_2</code></strong>。</li><li>当调用 g 时，<strong>第一个参数</strong>被传递到 f <strong>作为 f 的最后一个参数</strong>；<strong>第二个参数</strong>被传递给 f <strong>作为 f 的第三个参数</strong></li></ul></li></ul><h3 id="用-bind-重排参数顺序"><a href="#用-bind-重排参数顺序" class="headerlink" title="用 bind 重排参数顺序"></a>用 bind 重排参数顺序</h3><h3 id="绑定引用参数"><a href="#绑定引用参数" class="headerlink" title="绑定引用参数"></a>绑定引用参数</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
            <tag> 谓词 </tag>
            
            <tag> lambda </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.2 认识泛型算法</title>
      <link href="/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.2%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.2%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>重点了解算法是否<strong>读取元素、改变元素、重排元素</strong></li></ul><hr><h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><h3 id="算法和元素类型"><a href="#算法和元素类型" class="headerlink" title="算法和元素类型"></a>算法和元素类型</h3><ul><li>只读取输入范围内元素，而不改变元素</li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>find(b, e, val)</strong></td><td>在容器中搜索给定值 <br> b,e 是表示范围的迭代器，val 是给定的一个值 <br> <strong>返回</strong>指向第一个等于给定值的元素的<strong>迭代器</strong></td></tr><tr><td><strong>accumulate(b, e, val)</strong></td><td><strong>第三个参数</strong> val <strong>决定</strong>了函数中使用哪个<strong>加法运算符</strong>以及<strong>函数返回值类型</strong></td></tr></tbody></table></div><ul><li><p>accumulate 示例</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对 vector 中元素求和，和的初值是 0</span><br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">cbegin</span>(), vec.<span class="hljs-built_in">cend</span>(), <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将 vector 中 string 元素拼接起来, sum 初值为空串</span><br>string sum = <span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">cbegin</span>(), vec.<span class="hljs-built_in">cend</span>(), <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>accumulate 第三个参数若是空字符串，<strong>不能是 <code>&quot;&quot;</code>(字符串字面值)</strong>。第三个参数类型决定使用哪个+运算，但字符串字面值类型是 <strong>const char*, 这个类型并没有 + 运算</strong></li></ul></li></ul><h3 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>equal(b1, e1, b2)</strong></td><td>b1,e1 表示第一个序列中的元素范围 <br> b2 指向第二个序列的首元素</td></tr></tbody></table></div><ul><li><strong>equal</strong>：用于确定两个序列是否保存相同的值</li><li>由于 equal 是利用迭代器完成操作，因此可以通过 <strong>equal 比较两个不同类型容器中的元素</strong>，而且元<strong>素类型也可以不一样</strong>，只要这两个元素类型可以使用 <code>==</code> 来比较既可</li><li>equal <strong>假定第二个序列至少与第一个序列一样长</strong></li><li>只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</li></ul><hr><h2 id="写容器元素算法"><a href="#写容器元素算法" class="headerlink" title="写容器元素算法"></a>写容器元素算法</h2><ul><li>使用这类算法必须注意：<strong>确保序列原大小至少不小于</strong>要求算法写入的元素数目</li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>fill(b, e, val)</strong></td><td>将 val 的值赋予输入序列的每一个元素</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将每个元素重置为 0</span><br><span class="hljs-built_in">fill</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>); <br><span class="hljs-comment">// 将容器的一个子序列设置为 10</span><br><span class="hljs-built_in">fill</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">begin</span>() + vec.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h3 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>fill_n(b, n, val)</strong></td><td>将 val 赋予 迭代器 b 指向位置开始的 n 个元素</td></tr></tbody></table></div><ul><li><p>向<strong>空容器</strong>写入值要注意：</p><ul><li><p>合法操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空容器</span><br><span class="hljs-built_in">fill_n</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>非法操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空容器</span><br><span class="hljs-built_in">fill_n</span>(vec.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>向容器<strong>写入指定数量</strong>的值时要注意，<strong>容器是否有足够的空间</strong>来容纳这些数量的值</p></li></ul><h3 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h3><ul><li><strong>插入迭代器(insert iterator)</strong>: 向容器中添加元素的迭代器。保证算法有足够的空间来容纳输出数据</li><li>back_inserter <strong>接受一个指向容器的引用</strong>，<strong>返回</strong>一个与该容器绑定的<strong>插入迭代器</strong></li><li><p>常使用 back_inserter 创建一个迭代器，作为算法的目的位置</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空容器</span><br><span class="hljs-built_in">fill_n</span>(<span class="hljs-built_in">back_inserter</span>(vec), <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 向空容器 vec 添加 10 个 值为 0 的元素</span><br></code></pre></td></tr></table></figure><ul><li>由于传入的是 back_inserter 返回的迭代器，所以每次赋值都会在 vector 上调用 push_back</li></ul></li></ul><h3 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>copy(b1, e1, b2)</strong></td><td>b1, e1 表示输入范围 <br> b2 表示目的序列的起始位置 <br> 此算法将输入范围的元素拷贝到目的序列中<br> 返回目的位置迭代器（递增后）的值</td></tr></tbody></table></div><ul><li><p>传递给 copy 的<strong>目的序列至少要包含与输入范围同样多的元素</strong></p><ul><li><p>用 copy 实现内置数组的拷贝</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a1[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> a2[<span class="hljs-built_in">sizeof</span>(a1) / <span class="hljs-built_in">sizeof</span>(*a1)];       <span class="hljs-comment">// 保证 a2 与 a1 大小一样</span><br><span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>(a1), <span class="hljs-built_in">end</span>(a1), a2);<br></code></pre></td></tr></table></figure></li><li><p>ret 指向 a2 尾元素之后的位置</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>replace(b, e, oldVal, newVal)</strong></td><td>b,e 迭代器表示输入范围 <br> oldVal 是要搜索的值，newVal 是新值 <br> 算法将输入序列中所有等于 oldVal 的元素替换为 newVal</td></tr></tbody></table></div><ul><li>如果希望保持原序列不变，可以调用 <strong>replace_copy</strong>, 此算法接受第三个迭代器参数，指向调整后序列的保存位置</li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>replace_copy(b, e, b2, oldVal, newVal)</strong></td><td>其他参数含义不变 <br> b2 表示调整后序列的保存位置</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">replace</span>(ilst.<span class="hljs-built_in">begin</span>(), ilst.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);   <span class="hljs-comment">// 将 ilst 中值为 0 的元素值替换为42</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ilst 不变</span><br><span class="hljs-comment">// vec 包含 ilst 的一份拷贝，但是其中 值为 0 的元素已经替换为 42</span><br><span class="hljs-built_in">replace_copy</span>(ilst.<span class="hljs-built_in">begin</span>(), ilst.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(vec), <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h2><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>sort(b, e)</strong></td><td>b, e 表示要排序的元素的范围</td></tr><tr><td><strong>unique(b, e)</strong></td><td>b, e 表示要排序的元素的范围 <br> <strong>返回指向不重复区域之后一个位置的迭代器</strong></td></tr></tbody></table></div><ul><li><strong>unique 并不真正删除元素，只覆盖相邻的重复元素</strong>，使得不重复元素出现在序列开始的部分</li></ul><h3 id="使用容器操作删除元素"><a href="#使用容器操作删除元素" class="headerlink" title="使用容器操作删除元素"></a>使用容器操作删除元素</h3><ul><li><strong>标准库算法</strong>对迭代器而不是对容器操作，因此<strong>不能（直接）添加或删除元素</strong></li><li>要真正删除无用元素，必须使用容器操作</li></ul><h2 id="算法不改变容器大小的原因"><a href="#算法不改变容器大小的原因" class="headerlink" title="算法不改变容器大小的原因"></a>算法不改变容器大小的原因</h2><ul><li>将算法和容器成员函数区分开</li><li>算法接受的参数是迭代器，不是容器本身</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.6 容器适配器</title>
      <link href="/2025/03/30/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.6%20%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>/2025/03/30/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.6%20%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器操作和类型"><a href="#适配器操作和类型" class="headerlink" title="适配器操作和类型"></a>适配器操作和类型</h2><ul><li>适配器是标准库的一个通用概念，容器、迭代器、函数都有适配器。</li><li><strong>适配器</strong>是一种<strong>机制</strong>，使某种事物行为看起来像另外一种事物</li><li>比如 <strong>stack 适配器接受</strong>一个<strong>顺序容器(除 array 和 forward_list 之外)</strong>, 并<strong>使其操作看起来像 stack</strong></li></ul><div class="table-container"><table><thead><tr><th>Adaptor Operation And Type</th><th>Description</th></tr></thead><tbody><tr><td>size_type</td><td>一种类型，足以保存当前类型的最大对象的大小</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>container_type</td><td>实现适配器的底层容器类型</td></tr><tr><td>A a;</td><td>创建一个名为 a 的空适配器</td></tr><tr><td><strong>A a(c)</strong>;</td><td><strong>创建一个名为 a 的适配器，带有容器 c 的一个拷贝</strong></td></tr><tr><td>关系运算符</td><td>适配器都支持 ==, !=, &lt;, &lt;=, &gt;, &gt;= <br> 这些运算符返回底层容器的比较结果</td></tr><tr><td>a.empty()</td><td>若 a 至少包含一个元素，返回false；否则返回 true</td></tr><tr><td>a.size()</td><td>返回 a 中的元素数目</td></tr><tr><td>swap(a, b) <br> a.swap(b)</td><td>交换 a, b 的内容 <br> a 和 b 必须具有相同的类型，包括底层容器类型也必须相同</td></tr></tbody></table></div><h2 id="定义适配器"><a href="#定义适配器" class="headerlink" title="定义适配器"></a>定义适配器</h2><ul><li><p>每个适配器都有两个构造函数：</p><ul><li>默认构造函数创建一个空对象，</li><li>接受容器的构造函数拷贝该容器来初始化适配器</li></ul></li><li><p>默认情况下，<strong>stack 和 queue 基于 deque 实现</strong>；<strong>priority queue 基于 vector  实现</strong></p></li><li><p>在创建适配器时，将一个命名的<strong>顺序容器作为第二个类型参数</strong>，来重载默认容器类型</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在 vector 上实现的空栈</span><br>stack&lt;string, vector&lt;string&gt;&gt; str_stk;<br><span class="hljs-comment">// str_stk2 在 vector 上实现，初始化时保存 svec 的拷贝</span><br>stack&lt;string, vector&lt;string&gt;&gt; <span class="hljs-built_in">str_stk2</span>(svce);<br></code></pre></td></tr></table></figure></li><li><p><strong>不能用 array</strong> 来构造适配器：所有适配器<strong>都要求能添加和删除元素</strong></p></li><li><strong>不能用 forward_list</strong> 构造适配器：所有适配器<strong>都要求能添加、删除、访问尾元素</strong></li><li><strong>stack</strong> 要求 push_back，pop_back，back<ul><li>可以使用<strong>除 array，forward_list 之外的任何容器类型</strong>来构造</li></ul></li><li><strong>queue</strong> 要求 back，push_back，front，push_front<ul><li>可以使用 <strong>list，deque 构造</strong></li><li>但<strong>不能基于 vector</strong> 构造</li></ul></li><li><strong>priority</strong> 要求 front, push_back，push_front，还要求<strong>随机访问</strong><ul><li>可以<strong>基于 vector，deque 构造</strong>，但<strong>不能用 list</strong></li></ul></li></ul><h2 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h2><ul><li>默认基于 deque 实现，也可以使用 list 或 vector 实现</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>s.pop()</td><td>删除栈顶元素，但不返回该元素值</td></tr><tr><td>s.push(item) <br> s.emplace(args)</td><td>创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来，或者由 args 构造</td></tr><tr><td>s.top()</td><td>返回栈顶元素，但不讲元素弹出栈</td></tr></tbody></table></div><ul><li>只能使用适配器的操作，<strong>不能使用底层容器操作</strong></li></ul><h2 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h2><ul><li>queue 和 priority_queue 定义在 queue 头文件中</li><li>queue 默认基于 deque 实现，priority_queue 默认基于 vector 实现</li><li>queue 也可以使用 list 或 vector 实现；priority_queue 也可以使用 deque 实现</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>q.pop()</td><td>返回 queue 的首元素或者 priority_queue 的最高优先级元素，但不删除元素</td></tr><tr><td><strong>q.front()</strong> <br> <strong>q.back()</strong></td><td>返回首元素或尾元素，但不删除元素。<strong>只适用于 queue</strong></td></tr><tr><td><strong>q.top()</strong></td><td>返回最高优先级元素，但不删除元素。<strong>只适用于 priority_queue</strong></td></tr><tr><td>q.push(item) <br> q.emplace(args)</td><td>在 queue 的末尾或者 priority_queue 的恰当位置创建一个元素，其值为 item，或由 args 构造</td></tr></tbody></table></div><ul><li>queue 使用先进先出(<strong>first in, first out FIFO</strong>)的存储和访问策略：<ul><li><strong>进入</strong>队列的对象放<strong>在队尾</strong>，<strong>离开</strong>队列的对象<strong>从队首删除</strong></li></ul></li><li>priority_queue 允许为队列元素创建优先级<ul><li>新元素会排在优先级比它低的已有元素之前</li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>题目：使用stack处理括号化的表达式。当你看到一个左括号，将其记录下来。 当你在一个左括号之后看到一个右括号，从s七ack中pop对象，直至遇到左括号，将左括号也一起弹出栈。然后将一个值（括号内的运算结果）push到栈中，表示一个括号化的（子）表达式已经处理完毕，被其运算结果所替代。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断字符是否为操作符</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span> || c == <span class="hljs-string">&#x27;/&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 返回操作符优先级</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getPrecedence</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 接受两个整数和一个操作符，返回计算结果</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculator</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">char</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> a + b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> a - b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> a * b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Division by zero&quot;</span>);<br>            <span class="hljs-keyword">return</span> a / b;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid operator&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">handleExpression</span><span class="hljs-params">(std::string &amp; expr)</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">char</span>&gt; ops_stk;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; v_stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; expr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">char</span> c = expr[i];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isspace</span>(c))<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 如果是数字，解析完整字符并压入栈</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>            <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; expr.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(expr[i])) &#123;<br>                value = value * <span class="hljs-number">10</span> + (expr[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                ++i;<br>            &#125;<br>            v_stk.<span class="hljs-built_in">push</span>(value);<br>            --i;      <span class="hljs-comment">// 回退 1 位, 在 for 循环中 i 还要 ++</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果遇到 ’(&#x27; ,直接压入操作符栈</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            ops_stk.<span class="hljs-built_in">push</span>(c);<br><br>        <span class="hljs-comment">// 如果遇到 ‘)&#x27; 则弹出操作符直到遇到左括号</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            <span class="hljs-keyword">while</span> (!ops_stk.<span class="hljs-built_in">empty</span>() &amp;&amp; ops_stk.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> a = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> b = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">char</span> op = ops_stk.<span class="hljs-built_in">top</span>(); ops_stk.<span class="hljs-built_in">pop</span>();<br>                v_stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calculator</span>(a, b, op));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!ops_stk.<span class="hljs-built_in">empty</span>() &amp;&amp; ops_stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                ops_stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Mismatched Parenthesis&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果遇到操作符</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isOperator</span>(c)) &#123;<br>            <span class="hljs-keyword">while</span> (!ops_stk.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">getPrecedence</span>(ops_stk.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">getPrecedence</span>(c)) &#123;<br>                <span class="hljs-type">int</span> a = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> b = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">char</span> op = ops_stk.<span class="hljs-built_in">top</span>(); ops_stk.<span class="hljs-built_in">pop</span>();<br>                v_stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calculator</span>(a, b, op));<br>            &#125;<br>            ops_stk.<span class="hljs-built_in">push</span>(c);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余操作符</span><br>    <span class="hljs-keyword">while</span> (!ops_stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> a = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">char</span> op = ops_stk.<span class="hljs-built_in">top</span>(); ops_stk.<span class="hljs-built_in">pop</span>();<br>        v_stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calculator</span>(a, b, op));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (v_stk.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) &#123;<br>        std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Error in expression evaluation&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> v_stk.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;请输入一个数学表达式：&quot;</span>;<br>    std::<span class="hljs-built_in">getline</span>(std::cin, str);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">handleExpression</span>(str);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;计算结果是：&quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;错误：&quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 容器适配器 </tag>
            
            <tag> stack </tag>
            
            <tag> queue </tag>
            
            <tag> priority queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.4 vector 对象如何增长</title>
      <link href="/2025/03/29/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.4%20vector%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E9%95%BF/"/>
      <url>/2025/03/29/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.4%20vector%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="减少容器空间重新分配的策略"><a href="#减少容器空间重新分配的策略" class="headerlink" title="减少容器空间重新分配的策略"></a>减少容器空间重新分配的策略</h2><ul><li><strong>vector 和 string</strong> 在内存中是<strong>连续保存</strong>的，如果原先分配的内存已经用完，则会重新分配内存空间，将已有元素从旧空间移动到新空间，然后添加新元素</li><li>当不得不获取新的内存空间时，<strong>vector</strong> 和 <strong>string</strong> 通常<strong>分配比新的空间需求更大的内存空间</strong>，作为备用</li></ul><h2 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h2><div class="table-container"><table><thead><tr><th>Operating</th><th>Description</th></tr></thead><tbody><tr><td>c.shrink_to_fit()</td><td>将 capacity() 减少为与 size() 相同大小</td></tr><tr><td>c.capacity()</td><td>不重新分配内存空间，c 可以保存多少元素</td></tr><tr><td>c.reserve(n)</td><td>分配至少能容纳 n 个元素的内存空间</td></tr></tbody></table></div><ul><li><strong>shrink_to_fit()</strong> 只适用于 <strong>vector, string，deque</strong></li><li><strong>capacity</strong>：容器在<strong>不扩张内存空间</strong>的情况下<strong>可以容纳的元素数</strong></li><li><strong>reserve</strong>：告诉容器<strong>分配至少保存</strong>多少元素的<strong>内存空间</strong></li><li><strong>capacity</strong>，<strong>reserve</strong> 都只适用于 <strong>vector</strong>， <strong>string</strong></li></ul><h2 id="reserve、-resize-辨析"><a href="#reserve、-resize-辨析" class="headerlink" title="reserve、 resize 辨析"></a>reserve、 resize 辨析</h2><ul><li>reserve 不改变容器中元素的数量，仅影响 vector 预先分配多大的内存空间</li><li>只有当<strong>需要的内存空间超过当前容量</strong>时，调用 <strong>reserve</strong> 才会<strong>改变 vector 的容量</strong>；若<strong>不超过</strong>， reserve 什么也不做。</li><li><strong>resize</strong> <strong>只改变</strong>容器中<strong>元素数量</strong>，<strong>不改变容量大小</strong></li></ul><h2 id="capacity、size-辨析"><a href="#capacity、size-辨析" class="headerlink" title="capacity、size 辨析"></a>capacity、size 辨析</h2><ul><li>capacity 是容器在不重新分配内存的情况下最多能保存元素的数量</li><li>size 是指容器已经保存的元素数量</li><li>size 永远不可能大于 capacity</li><li>每个 vector 实现都可以选择自己的内存分配策略，但是必须遵循一个原则：<strong>只有迫不得已时才可以重新分配新的内存空间</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> vector 增长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.5 额外的 string 操作</title>
      <link href="/2025/03/29/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.5%20%E9%A2%9D%E5%A4%96%E7%9A%84%20string%20%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/29/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.5%20%E9%A2%9D%E5%A4%96%E7%9A%84%20string%20%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="构造-string-的其他方法"><a href="#构造-string-的其他方法" class="headerlink" title="构造 string 的其他方法"></a>构造 string 的其他方法</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>string s(cp, n)</td><td>s 是 <strong>cp 指向的数组</strong>中前 n 个字符的拷贝。<br> 此<strong>数组至少包含 n 个字符</strong></td></tr><tr><td>string s(s2, pos2)</td><td>s 是 s2 从下标 pos2 开始的字符的拷贝。<br> 如果 pos2 &gt; s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2, pos2, len2)</td><td>s 是 s2 从下标 pos2 开始的 len2 个元素的拷贝。<br> 若 pos2 &gt; s2.size()，构造函数行为未定义 <br> 不管 len2 的值是多少，构造函数<strong>至多拷贝 s2.size() - pos2 个元素</strong></td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testStringConstructor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * cp = <span class="hljs-string">&quot;Hello World!!&quot;</span>;      <span class="hljs-comment">// 以空字符结束的数组</span><br>    <span class="hljs-type">char</span> noNull[] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>&#125;;     <span class="hljs-comment">// 不是以空字符结束</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s1</span><span class="hljs-params">(cp)</span></span>;                 <span class="hljs-comment">// 拷贝 cp 中的字符直到遇到空字符；s1 == &quot;Hello World!!&quot;</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s2</span><span class="hljs-params">(noNull, <span class="hljs-number">2</span>)</span></span>;        <span class="hljs-comment">// 从 noNull 拷贝两个字符;s2 == &quot;Hi&quot;</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s3</span><span class="hljs-params">(noNull)</span></span>;             <span class="hljs-comment">// 未定义行为。noNull 不是以空字符结尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s4</span><span class="hljs-params">(cp + <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span></span>;        <span class="hljs-comment">// 从 cp[6] 开始拷贝 5 个字符。</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s5</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 在 s1[6] 开始拷贝 5 个字符</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s6</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>)</span></span>;          <span class="hljs-comment">// 从 s1[6] 开始拷贝，直到 s1 末尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s7</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>, <span class="hljs-number">20</span>)</span></span>;  <span class="hljs-comment">// 从 s1[6] 开始拷贝，直到 s1 末尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s8</span><span class="hljs-params">(s1, <span class="hljs-number">18</span>)</span></span>;         <span class="hljs-comment">// 抛出 out_of_range 异常</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当从一个 <code>const char *</code> <strong>创建 string</strong> 时，指针指向的<strong>数组必须以空字符结尾</strong>，<strong>拷贝操作遇到空字符停止</strong></li><li>但如果还<strong>传递给构造函数一个计数值</strong>，则数组不必以空字符结尾。</li><li>若未传递计数值也未以空字符结尾，或传递的计数值大于数组大小，构造函数行为未定义</li></ul><h3 id="substr-操作"><a href="#substr-操作" class="headerlink" title="substr 操作"></a>substr 操作</h3><ul><li>substr 返回一个 string</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>s.substr(pos, n)</td><td>返回 string，包含 s 中<strong>从 pos 开始的 n 个字符的拷贝</strong>。<br> pos 默认值是 0，n 的默认值是 s.size() - pos, 即拷贝从 pos 开始的所有字符</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testSubstr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello world&quot;</span>)</span></span>;<br>    std::string s1 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// s1 = Hello</span><br>    std::string s2 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>);              <span class="hljs-comment">// s2 = world</span><br>    std::string s3 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>);       <span class="hljs-comment">// s3 = world</span><br>    std::string s4 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">12</span>);             <span class="hljs-comment">// 抛出 out_of_range 异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="改变-string-的其他方法"><a href="#改变-string-的其他方法" class="headerlink" title="改变 string 的其他方法"></a>改变 string 的其他方法</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>args 形式</th><th>Description</th></tr></thead><tbody><tr><td>s.insert(pos, args)</td><td>str <br> str, pos2, len <br> cp, len <br> n, c</td><td>在 <strong>下标 pos 前插入</strong> args 指定的字符。<br> <strong>返回指向 s 的引用</strong></td></tr><tr><td>s.insert(iter, args)</td><td>n, c <br> b2, e2 <br> 初始化列表</td><td>在<strong>迭代器 iter 前</strong>插入 args 指定字符。 <br> <strong>返回指向第一个插入字符的迭代器</strong></td></tr><tr><td>s.erase(pos, len)</td><td></td><td><strong>删除从位置 pos 开始的 len 个字符</strong>。<br> 如果 len 被省略，则删除从 pos 开始直到 s 末尾的所有字符。<br> <strong>返回指向 s 的引用</strong></td></tr><tr><td>s.assign(args)</td><td>str <br> str, pos, len <br> cp, len <br> cp <br> n,c <br> b,e <br> 初始化列表</td><td>将 <strong>s 中的字符替换为 args 指定的字符</strong>。<br> 返回一个指向 s 的引用</td></tr><tr><td>s.append(args)</td><td>str <br> str,pos,len <br> cp,len <br> cp <br> n,c <br> b, e <br> 初始化列表</td><td>将 <strong>args 追加到 s</strong>。返回指向 s 的引用</td></tr><tr><td>s.replace(pos, len, args)</td><td>str <br> str, pos2, len2 <br> cp, len <br> cp <br> n, c</td><td>删除 s 中<strong>从下标 pos 开始的 len 个字符</strong>，替换为 args 指定的字符。<br> <strong>返回指向 s 的引用</strong>。</td></tr><tr><td>s.replace(b, e, args)</td><td>str <br> cp, len <br> cp <br> n, c <br> b2, e2 <br> 初始化列表</td><td>删除 s 中<strong>迭代器 b, e 指定范围的字符</strong>，替换为 args 指定的字符。<br> <strong>返回指向 s 的引用</strong></td></tr></tbody></table></div><ul><li>上表中的 args 可以是下列形式之一；</li><li>append 和 assign 可以使用所有形式</li></ul><div class="table-container"><table><thead><tr><th>Form</th><th>Description</th></tr></thead><tbody><tr><td>str</td><td>字符串 str</td></tr><tr><td>str, pos, len</td><td>str 中从 pos 开始最多 len 个字符</td></tr><tr><td>cp, len</td><td>cp 指向的字符数组的前(最多) len 个字符</td></tr><tr><td>cp</td><td>cp 指向的以空字符结尾的字符数组</td></tr><tr><td>n, c</td><td>n 个 字符 c</td></tr><tr><td>b, e</td><td>迭代器 b, e 指定范围内的字符</td></tr><tr><td>初始化列表</td><td>{} 包围的，以 “,” 分隔的字符列表</td></tr></tbody></table></div><ul><li>str 不能和 s 相同</li><li>迭代器 b,e 不能指向 s</li><li><strong>replace</strong> 和 <strong>insert</strong> 所允许的 args 形式<strong>依赖于 range 和 pos 如何指定</strong></li></ul><div class="table-container"><table><thead><tr><th>replace</th><th>replace</th><th>insert</th><th>insert</th><th>args 可以是</th></tr></thead><tbody><tr><td>(pos, len, args)</td><td>(b, e, args)</td><td>(pos, args)</td><td>(iter, args)</td><td></td></tr><tr><td>是</td><td>是</td><td>是</td><td>否</td><td>str</td></tr><tr><td>是</td><td>否</td><td>是</td><td>否</td><td>str, pos, len</td></tr><tr><td>是</td><td>是</td><td>是</td><td>否</td><td>cp, len</td></tr><tr><td>是</td><td>是</td><td>否</td><td>否</td><td>cp</td></tr><tr><td>是</td><td>是</td><td>是</td><td>是</td><td>n, c</td></tr><tr><td>否</td><td>是</td><td>否</td><td>是</td><td>b2, e2</td></tr><tr><td>否</td><td>是</td><td>否</td><td>是</td><td>初始化列表</td></tr></tbody></table></div><h3 id="接受下标版本的-insert-和-erase"><a href="#接受下标版本的-insert-和-erase" class="headerlink" title="接受下标版本的 insert 和 erase"></a>接受下标版本的 insert 和 erase</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;!&#x27;</span>);     <span class="hljs-comment">// 在 s 的末尾添加 5 个 ！</span><br>s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);       <span class="hljs-comment">// 从 s 中删除最后五个字符</span><br></code></pre></td></tr></table></figure><h3 id="接受-c-风格字符数组的-insert-和-assign"><a href="#接受-c-风格字符数组的-insert-和-assign" class="headerlink" title="接受 c 风格字符数组的 insert 和 assign"></a>接受 c 风格字符数组的 insert 和 assign</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * cp = <span class="hljs-string">&quot;Stately, plump Buck&quot;</span>;<br>s.<span class="hljs-built_in">assign</span>(cp, <span class="hljs-number">7</span>);        <span class="hljs-comment">// s == &quot;Stately&quot;</span><br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">size</span>(), cp<span class="hljs-number">+7</span>);   <span class="hljs-comment">// s == &quot;Stately, plump Buck&quot;</span><br></code></pre></td></tr></table></figure><ul><li>调用 assign，用 cp 指向的地址开始的 7 个字符替换 s 中的内容</li><li>调用 insert，在 s 的结尾(<em>s[size()] 这个不存在的位置</em>) 插入 cp 指向的数组下从 7 开始直到结尾空字符之前字符的拷贝</li></ul><h3 id="指定其他-string-或子字符串的字符插入当前-string-或赋予当前-string"><a href="#指定其他-string-或子字符串的字符插入当前-string-或赋予当前-string" class="headerlink" title="指定其他 string 或子字符串的字符插入当前 string 或赋予当前 string"></a>指定其他 string 或子字符串的字符插入当前 string 或赋予当前 string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;some string&quot;</span>, s2 = <span class="hljs-string">&quot;some other string&quot;</span>;<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, s2);        <span class="hljs-comment">// 在 s 的 下标 0 之前插入 s2 的拷贝</span><br><span class="hljs-comment">// 在 s[0] 之前插入 s2 中从下标 0 开始的 s2.size() 个字符</span><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, s2, <span class="hljs-number">0</span>, s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>());<br></code></pre></td></tr></table></figure><h3 id="append-和-replace-函数"><a href="#append-和-replace-函数" class="headerlink" title="append 和 replace 函数"></a>append 和 replace 函数</h3><ul><li>append 是在 string 末尾进行插入操作</li><li>replace 是 调用 erase 和 insert 的一种简写</li><li>调用 <strong>replace</strong> 时，<strong>插入文本可以与删除文本长度不同</strong></li></ul><h3 id="改变-string-的多种重载函数"><a href="#改变-string-的多种重载函数" class="headerlink" title="改变 string 的多种重载函数"></a>改变 string 的多种重载函数</h3><ul><li><p><strong>assign 和 append 函数 无需指定要替换 string 中哪个部分</strong>：</p><ul><li>assign 总是替换 string 中的所有内容</li><li>append 总是将新字符添加到 string 末尾</li></ul></li><li><p><strong>replace</strong> 提供<strong>两种指定删除元素范围的方式</strong>：</p><ul><li>通过一个位置和一个长度指定范围</li><li>通过一个迭代器范围来指定</li></ul></li><li><p><strong>insert</strong> 提供<strong>两种方式指定插入点</strong>：</p><ul><li>一个下标</li><li>一个迭代器</li><li><strong>新元素都会插入到给定下标或迭代器之前的位置</strong></li></ul></li><li><p>多种方式指定要添加到 string 中的字符：</p><ul><li>新字符可以来自另一个 string</li><li>可以来自字符指针（指向的字符数组）</li><li>可以来自花括号包围的字符列表</li><li>或是一个字符和一个计数值</li><li>当新字符<strong>来自另一个 string 或 字符数组</strong>时，可以<strong>传递一个额外参数来控制是拷贝部分还是全部</strong></li></ul></li></ul><h2 id="string-的搜索操作"><a href="#string-的搜索操作" class="headerlink" title="string 的搜索操作"></a>string 的搜索操作</h2><ul><li>string 提供 6 个不同的搜索函数，每个搜索函数有 4 个重载版本</li><li>每个搜索操作都返回一个 string::size_type 值，表示匹配发生位置下标</li><li>搜索失败，返回一个 string::npos 的 static 成员。npos 是 const string::size_type 类型，初始化值为 -1。</li></ul><div class="table-container"><table><thead><tr><th>Search Operation</th><th>Description</th></tr></thead><tbody><tr><td>s.find(args)</td><td>查找 s 中 <strong>args 第一次出现</strong>的位置</td></tr><tr><td>s.rfind(args)</td><td>查找 s 中 <strong>args 最后一次出现</strong>的位置</td></tr><tr><td>s.find_first_of(args)</td><td>在 s 中查找 <strong>args 中任何一个字符第一次出现</strong>的位置</td></tr><tr><td>s.find_last_of(arsg)</td><td>在 s 中查找 <strong>args 中任何一个字符最后一次出现</strong>的位置</td></tr><tr><td>s.find_first_not_of(args)</td><td>在 s 中查找<strong>第一个不在 args 中</strong>的字符</td></tr><tr><td>s.find_last_not_of(args)</td><td>在 s 中查找<strong>最后一个不在 args 中</strong>的字符</td></tr></tbody></table></div><ul><li>args 必须是以下形式</li></ul><div class="table-container"><table><thead><tr><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>c, pos</td><td>从 s 中位置 pos 开始查找字符 c 。<br> pos 默认为 0</td></tr><tr><td>s2, pos</td><td>从 s 中位置 pos 开始查找字符串 s2 。<br> pos 默认为 0</td></tr><tr><td>cp, pos</td><td>从 s 中位置 pos  开始查找 cp 指向的以空字符结尾的 C 风格字符串。<br> pos 默认为 0</td></tr><tr><td>cp, pos, n</td><td>从 s 中位置 pos 开始查找 cp 指向的数组的前 n 个字符。<br> pos 和 n 无默认值</td></tr></tbody></table></div><h3 id="指定在哪里搜索"><a href="#指定在哪里搜索" class="headerlink" title="指定在哪里搜索"></a>指定在哪里搜索</h3><ul><li><p>循环搜索子字符串出现的所有位置</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_substring_pos</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;dfadafdasfd343245232t434543254545435132343476y 55243eq6tr6&quot;</span>)</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">number</span><span class="hljs-params">(<span class="hljs-string">&quot;34&quot;</span>)</span></span>;<br>    std::string::size_type pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((pos = name.<span class="hljs-built_in">find_first_of</span>(number, pos)) != std::string::npos) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;find number at index: &quot;</span> &lt;&lt; pos <br>                      &lt;&lt; <span class="hljs-string">&quot;, element is &quot;</span> &lt;&lt; name[pos] &lt;&lt; std::endl;<br>            ++pos;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ul><li>如果一个字母延伸到中线之上，如d或f，则称其有上出头部分（ascender）。如果一个字母延伸到中线之下，如p或g，则称其有下出头部分（descender）。编写程序，读入一个单词文件，输出最长的既不包含上出头部分，也不包含下出头部分的单词。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkMax</span><span class="hljs-params">(std::string &amp; currWord, std::string &amp; maxWord)</span></span>&#123;<br>    maxWord = currWord.<span class="hljs-built_in">size</span>() &gt; maxWord.<span class="hljs-built_in">size</span>() ? currWord : maxWord;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkWord</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; word)</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">target</span><span class="hljs-params">(<span class="hljs-string">&quot;acemnorsuvwxz&quot;</span>)</span></span>;<br>    std::string::size_type pos = word.<span class="hljs-built_in">find_first_not_of</span>(target);<br>    <span class="hljs-keyword">return</span> pos == std::string::npos;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_longest_noAscender_noDescender</span><span class="hljs-params">(std::ifstream &amp; ifs)</span> </span>&#123;<br>    std::string maxWord, currWord;<br>    <span class="hljs-keyword">while</span> (ifs &gt;&gt; currWord) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkWord</span>(currWord))<br>            <span class="hljs-built_in">checkMax</span>(currWord, maxWord);<br>    &#125;<br>    std::cout &lt;&lt; maxWord &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-type">void</span> _9_49() &#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;../Resource/letter.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span>(!ifs) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">find_longest_noAscender_noDescender</span>(ifs);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="compare-函数"><a href="#compare-函数" class="headerlink" title="compare 函数"></a>compare 函数</h2><ul><li>除关系运算符外，标准库 string 提供 compare 函数</li><li>s.compare 根据 s 是大于、小于、等于参数给定的字符串，返回 正数、负数、零</li><li>compare 有 6 个版本</li></ul><div class="table-container"><table><thead><tr><th>Compare Arguments</th><th>Description</th></tr></thead><tbody><tr><td>s2</td><td>比较 s 和 s2</td></tr><tr><td>pos1, n1, s2</td><td>将 s 中从 pos1 开始的 n1 个字符与 s2 比较</td></tr><tr><td>pos1, n1, s2, pos2, n2</td><td>将 <strong>s 中从 pos1 开始的 n1 个字符</strong>，与 <strong>s2 中 pos2 开始的 n2个字符</strong>进行比较</td></tr><tr><td>cp</td><td>比较 s 与 cp 指向的以空字符结尾的字符数组</td></tr><tr><td>pos1, n1, cp</td><td>将 s 中从 pos1 开始的 n1 个字符，与 cp 指向的以空字符结尾的字符数组进行比较</td></tr><tr><td>pos1, n1, cp, n2</td><td>将 s 中从 pos1 开始的 n1 个字符，与 cp 指向的字符数组中前 n2 个字符进行比较</td></tr></tbody></table></div><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><div class="table-container"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td>to_string(val)</td><td>一组重载函数，返回 val 的 string 表示。<br> val 可以是任何算数类型。<br> 对每个浮点类型和 int 或更大的整型，都有相应版本的 to_string()</td></tr><tr><td>stoi(s, p, b) <br> stol(s, p, b) <br> stoul(s, p, b) <br> stoll(s, p, b) <br> stoull(s, p, b)</td><td><strong>返回</strong> s 的起始字符串（表示<strong>整数</strong>内容）的<strong>数值</strong>，返回类型分别是 int, long, unsigned long, long long, unsigned long long。<br> <strong>b 表示转换所用基数</strong>，<strong>默认值为 10</strong> <br> <strong>p 是 size_t 指针</strong>，用来<strong>保存 s 中第一个非数值字符的下标</strong>，p 默认是 0，即函数不保存下标</td></tr><tr><td>stof(s, p) <br> stod(s, p) <br> stold(s, p)</td><td><strong>返回</strong> s 的起始字符串（表示<strong>浮点数</strong>内容）的<strong>数值</strong>，返回类型分别是 float, double, long double。<br> <strong>p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标</strong>，默认 是 0，即函数不保存下标</td></tr></tbody></table></div><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testChangeNumber</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>    std::string s = std::<span class="hljs-built_in">to_string</span>(i);<br>    <span class="hljs-type">double</span> d = std::<span class="hljs-built_in">stod</span>(s);<br><br>    std::string s2 = <span class="hljs-string">&quot;pi = 3.14&quot;</span>;<br>    <span class="hljs-comment">// 转换 s2 中以数字开始的第一个子串</span><br>    d = std::<span class="hljs-built_in">stod</span>(s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;+-.0123456789&quot;</span>)));     <span class="hljs-comment">// d = 3.14</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>string 中<strong>第一个非空白符</strong>必须是<strong>符号(+ 或 -)</strong> 或 <strong>数字</strong></li><li>string 可以以 <strong>0x</strong> 或 <strong>0X</strong> 开头来<strong>表示十六进制数</strong></li><li>字符串<strong>转为浮点数</strong>的函数，string 参数也<strong>可以以 (</strong>.<strong>) 开头</strong>, 并<strong>可以包含 e 或 E 来表示指数部分</strong></li><li>字符串转为<strong>整型值</strong>的函数，根据<strong>基数不同</strong>，<strong>string 参数可以包含字母字符</strong></li><li>若 string 不能转为一个数值，函数抛出 invalid_argument 异常。</li><li>如果转换后的数值无法用任何类型来表示，则抛出 out_of_range 异常</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>题目： 设计一个类，它有三个unsigned成员，分别表示年、月和日。为其编写构造函数，接受一个表示日期的string参数。你的构造函数应该能处理不同的数据格式，如January 1,1900、1/1/1990、Jan 1 1900 等。</p><ul><li><p>Date 类实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数接受表示日期的 string 参数</span><br>    <span class="hljs-comment">// 可以处理如 January 1, 1990、1/1/1990、Jan 1 1990 等不同数据格式</span><br>    <span class="hljs-built_in">Date</span>(std::string &amp; date);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">monthCovert</span><span class="hljs-params">(std::string &amp; s)</span></span>;<br>    <span class="hljs-type">unsigned</span> _year;<br>    <span class="hljs-type">unsigned</span> _month;<br>    <span class="hljs-type">unsigned</span> _day;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>构造函数实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Date::<span class="hljs-built_in">Date</span>(std::string &amp;date) &#123;<br>    <span class="hljs-type">unsigned</span> format = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) != std::string::npos)<br>        format = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) != std::string::npos)&#123;<br>        format = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) == std::string::npos &amp;&amp; date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) == std::string::npos) &#123;<br>        format = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (format) &#123;<br>        <span class="hljs-comment">// 1/1/1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        &#123;<br>            _month = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>)));<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// January 1, 1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        &#123;<br>            <span class="hljs-keyword">auto</span> month = date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>            _month = <span class="hljs-built_in">monthCovert</span>(month);<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>( date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;123456789&quot;</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>)), <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// Jan 1 1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        &#123;<br>            <span class="hljs-keyword">auto</span> month = date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>            _month = <span class="hljs-built_in">monthCovert</span>(month);<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>monthCovert 私有成员实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">Date::monthCovert</span><span class="hljs-params">(std::string &amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jan&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Feb&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Mar&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Apr&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;May&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jun&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jul&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Aug&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Sep&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Oct&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Nov&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Dec&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>print 成员实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::print</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;year: &quot;</span> &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>            &lt;&lt; <span class="hljs-string">&quot;month: &quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>            &lt;&lt; <span class="hljs-string">&quot;day: &quot;</span> &lt;&lt; _day &lt;&lt; std::endl;<br>    std::cout &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot; 年 &quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot; 月 &quot;</span> &lt;&lt; _day &lt;&lt; <span class="hljs-string">&quot; 日&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试函数</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str;<br>    std::<span class="hljs-built_in">getline</span>(std::cin, str);<br>    <span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(str)</span></span>;<br>    date.<span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> string 操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.1 IO 类</title>
      <link href="/2025/03/28/8.%20IO%E5%BA%93/8.1%20IO%20class/"/>
      <url>/2025/03/28/8.%20IO%E5%BA%93/8.1%20IO%20class/</url>
      
        <content type="html"><![CDATA[<h2 id="IO-库类型和头文件"><a href="#IO-库类型和头文件" class="headerlink" title="IO 库类型和头文件"></a>IO 库类型和头文件</h2><div class="table-container"><table><thead><tr><th style="text-align:center">头文件</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:center">iostream</td><td style="text-align:left">istream, wistream: 从流读出数据 <br> ostream, wostream: 向流写入数据 <br> iostream, wiostream: 读写流</td></tr><tr><td style="text-align:center">fstream</td><td style="text-align:left">ifstream, wifstream: 从文件读取数据 <br> ofstream, wofstream: 向文件写入数据 <br> iofstream, wiostream: 读写文件</td></tr><tr><td style="text-align:center">sstream</td><td style="text-align:left">istringstream, wistringstream: 从 string 读取数据 <br> ostringstream, wostringstream: 向 string 写入数据 <br> stringstream, wstringstream: 读写 string</td></tr></tbody></table></div><h3 id="IO-对象无拷贝或赋值"><a href="#IO-对象无拷贝或赋值" class="headerlink" title="IO 对象无拷贝或赋值"></a>IO 对象无拷贝或赋值</h3><ul><li>通常以<strong>引用</strong>的形式传递和返回流</li></ul><h3 id="条件状态-condition-state"><a href="#条件状态-condition-state" class="headerlink" title="条件状态(condition state)"></a>条件状态(condition state)</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类型与函数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">strm::iostate</td><td style="text-align:left">strm 是一种 IO 类型，iostate 提供了表达condition state的完整功能</td></tr><tr><td style="text-align:left">strm::badbit</td><td style="text-align:left">用来指出流已崩溃</td></tr><tr><td style="text-align:left">strm::failbit</td><td style="text-align:left">用来指出一个 IO 操作失败了</td></tr><tr><td style="text-align:left">strm::eofbit</td><td style="text-align:left">用来指出流到达了文件结束</td></tr><tr><td style="text-align:left">strm::goodbit</td><td style="text-align:left">用来指出流未处于错误状态，此值保证为零</td></tr><tr><td style="text-align:left">s.eof()</td><td style="text-align:left">若流 s 的 eofbit 置位，返回 true</td></tr><tr><td style="text-align:left">s.fail()</td><td style="text-align:left">若 s 的 failbit / badbit 置位，则返回 true</td></tr><tr><td style="text-align:left">s.bad()</td><td style="text-align:left">若 s 的badbit 置位，则返回 true</td></tr><tr><td style="text-align:left">s.good()</td><td style="text-align:left">若 s 处于有效状态，则返回 true</td></tr><tr><td style="text-align:left">s.clear()</td><td style="text-align:left">将流 s 的所有条件状态位置位，将流的状态设置为有效，返回 void</td></tr><tr><td style="text-align:left">s.clear(flags)</td><td style="text-align:left">根据给定的 flag 标志位，将流中对应的条件状态位<strong>复位</strong>。flags 类型为 strm::iostate。返回 void</td></tr><tr><td style="text-align:left">s.setstate(flags)</td><td style="text-align:left">根据给定的 flag 标志位，将流中对应的条件状态位<strong>置位</strong>，flags 类型为 strm::iostate。返回 void</td></tr><tr><td style="text-align:left">s.rdstate()</td><td style="text-align:left">返回流 s 的当前条件状态，返回值类型为 strm::iostate</td></tr></tbody></table></div><h3 id="确定一个流状态的最简单方法"><a href="#确定一个流状态的最简单方法" class="headerlink" title="确定一个流状态的最简单方法"></a>确定一个流状态的最简单方法</h3><ul><li><p>将它作为<strong>条件</strong>来使用</p><p>  while 循环检查 &gt;&gt; 表达式返回的流状态。如果输入操作成功，则保持流状态，条件为真。</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cin &gt;&gt; word) &#123;<br>    <span class="hljs-comment">// ok: 读操作成功</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><ul><li>endl: 输出缓冲区内容和一个换行，然后刷新缓冲区</li><li>flush：输出缓冲区内容，刷新缓冲区，不附加任何字符</li><li>ends：输出缓冲区内容和一个空字符，然后刷新缓冲区</li></ul><h3 id="unitbuf-操纵符"><a href="#unitbuf-操纵符" class="headerlink" title="unitbuf 操纵符"></a>unitbuf 操纵符</h3><p>若想在<strong>每次输出操作后都刷新缓冲区</strong>，可以使用 <strong>unitbuf 操纵符</strong>。它使得流在接下来的每次写操作之后都进行一次 flush 操作。而 <strong>nounitbuf 操纵符</strong>则重置流，<strong>使流恢复正常</strong>的系统管理缓冲区刷新机制。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">cout &lt;&lt; unitbuf;    <span class="hljs-comment">// 之后所有输出操作后都会刷新缓冲区</span><br>                    <span class="hljs-comment">// 任何输出都立即刷新，无缓冲</span><br>cout &lt;&lt; nounitbuf;  <span class="hljs-comment">// 回到正常缓冲方式</span><br></code></pre></td></tr></table></figure><h3 id="关联输入流与输出流"><a href="#关联输入流与输出流" class="headerlink" title="关联输入流与输出流"></a>关联输入流与输出流</h3><ul><li>当一个输入流关联到输出流，任何从输入流读取数据的操作都会刷新关联的输出流</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> IO 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.2 文件输入输出流</title>
      <link href="/2025/03/28/8.%20IO%E5%BA%93/8.2%20%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
      <url>/2025/03/28/8.%20IO%E5%BA%93/8.2%20%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h2><ul><li><p>头文件：fstream.h</p></li><li><p>类型：</p><ul><li>ifstream</li><li>ofstream</li><li>fstream</li></ul></li></ul><hr><h2 id="fstream-特有操作"><a href="#fstream-特有操作" class="headerlink" title="fstream 特有操作"></a>fstream 特有操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left"><strong>fstream</strong> fstrm</td><td style="text-align:left">创建一个未绑定的文件流，fstream 是头文件 fstream 中定义的类型</td></tr><tr><td style="text-align:left"><strong>fstream</strong> fstrm(s)</td><td style="text-align:left">创建一个fstream object, 并打开名为 s 的文件。s 可以是 <strong>string</strong>，也可以是 <strong>C 风格字符串的指针</strong>，这些构造函数都是 explicit 的。<strong>默认文件 mode 依赖于 fstream 的类型</strong>。</td></tr><tr><td style="text-align:left"><strong>fstream</strong> fstrm(s, mode)</td><td style="text-align:left">按指定 mode 打开文件</td></tr><tr><td style="text-align:left">fstrm.open(s)</td><td style="text-align:left">打开一个名为 s 的文件，并将 s 与 fstrm 绑定。默认文件 mode 依赖于 fstream 的类型。返回 void</td></tr><tr><td style="text-align:left">fstrm.close()</td><td style="text-align:left">关闭与 fstrm 绑定的文件。返回 void</td></tr><tr><td style="text-align:left">fstrm.is_open()</td><td style="text-align:left">返回一个 bool 值，指出与 fstrm 绑定的文件是否成功打开且尚未关闭</td></tr></tbody></table></div><p><strong>NOTE:</strong> 当一个 fstream 对象被销毁时，close() 会自动被调用。</p><hr><h2 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Mode</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">以读的方式打开</td></tr><tr><td style="text-align:left">out</td><td style="text-align:left">以写的方式打开</td></tr><tr><td style="text-align:left">app</td><td style="text-align:left">每次写操作之前均定位到文件末尾</td></tr><tr><td style="text-align:left">ate</td><td style="text-align:left">打开文件后立即定位到文件末尾</td></tr><tr><td style="text-align:left">trunc</td><td style="text-align:left">截断文件</td></tr><tr><td style="text-align:left">binary</td><td style="text-align:left">以二进制方式进行 IO</td></tr></tbody></table></div><p><strong>NOTE:</strong> 指定文件模式有以下限制</p><ul><li>只可以对 <strong>ofstream 或 fstream 对象</strong>设定 <strong>out mode</strong></li><li>只可以对 <strong>ifstream 或 fstream 对象</strong>设定 <strong>in mode</strong></li><li>只有当 out 也被设定时，才可以设定 trunc</li><li>只要 trunc 没被设定，就可以设定 app 模式。<strong>app mode 下，默认指定 out mode</strong></li><li><strong>默认情况下</strong>，即使没有指定 trunc mode, 以 out mode 打开的文件也总会被截断。<strong>为了保留 out mode 下文件的内容，必须同时指定 app mode</strong>.</li><li><strong>ate mode 和 binary mode</strong> 可<strong>用于任何类型的文件流对象</strong>，且可以与其他任何文件 mode 组合使用</li><li>与 <strong>ifstream</strong> 关联的文件默认以 <strong>in mode</strong> 打开；与 <strong>ofstream</strong> 关联的文件默认以 <strong>out mode</strong> 打开；与 <strong>fstream</strong> 关联的文件默认以 <strong>in, out mode</strong>打开</li></ul><h3 id="out-mode-打开文件会丢弃已有数据"><a href="#out-mode-打开文件会丢弃已有数据" class="headerlink" title="out mode 打开文件会丢弃已有数据"></a>out mode 打开文件会丢弃已有数据</h3><ul><li>阻止一个 ofstream 清空数据的方法是<strong>显式指定 app mode 或 in mode</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这几条语句中，file1 都被截断</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>)</span></span>;    <span class="hljs-comment">// 隐含以 out mode 打开文件并截断文件</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::out)</span></span>; <span class="hljs-comment">// 隐含的截断文件</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;<br><br><span class="hljs-comment">// 为保留文件内容，显式指定 app mode</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::app)</span></span>; <span class="hljs-comment">// 隐含为 out mode</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::app | ofstream::out)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="每次调用-open-确定文件模式"><a href="#每次调用-open-确定文件模式" class="headerlink" title="每次调用 open 确定文件模式"></a>每次调用 open 确定文件模式</h3><ul><li>调用 open 打开文件的<strong>默认文件模式</strong>是 <strong>out mode</strong>，而一般 out mode 意味着同时使用 trunc mode.</li><li>调用 open 打开文件，可以显式地指定文件模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> file stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.3 string 流</title>
      <link href="/2025/03/28/8.%20IO%E5%BA%93/8.3%20string%20stream/"/>
      <url>/2025/03/28/8.%20IO%E5%BA%93/8.3%20string%20stream/</url>
      
        <content type="html"><![CDATA[<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><pre><code>#include &lt;sstream&gt;</code></pre><p>头文件中定义了三个类类型来支持 IO：</p><ul><li><code>istringstream</code>: 从 string 读数据</li><li><code>ostringstream</code>: 从 string 写数据</li><li><code>stringstream</code>: 既可读，也可写</li></ul><h2 id="stringstream-特有的操作"><a href="#stringstream-特有的操作" class="headerlink" title="stringstream 特有的操作"></a>stringstream 特有的操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left">sstream strm</td><td style="text-align:left">strm 是一个未绑定的 stringstream 对象，sstream 是头文件中定义的一个类型</td></tr><tr><td style="text-align:left">sstream strm(s)</td><td style="text-align:left">strm 是个 stringstream 对象，保存 string s 的一个拷贝。<br> 此构造函数是 explicite 的</td></tr><tr><td style="text-align:left"><strong>strm.str()</strong></td><td style="text-align:left"><strong>返回所保存的 string 的拷贝</strong></td></tr><tr><td style="text-align:left"><strong>strm.str(s)</strong></td><td style="text-align:left"><strong>将 string s 拷贝到 strm 中，返回 void</strong></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> string stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Some Question about file stream in cpp</title>
      <link href="/2025/03/28/8.%20IO%E5%BA%93/IO%20file%20stream%20Question/"/>
      <url>/2025/03/28/8.%20IO%E5%BA%93/IO%20file%20stream%20Question/</url>
      
        <content type="html"><![CDATA[<h2 id="current-work-directory"><a href="#current-work-directory" class="headerlink" title="current work directory"></a>current work directory</h2><p>windows 获取当前工作目录：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;direct.h&gt;</span> <span class="hljs-comment">// windows</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> cwd[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">if</span> (_getcwd(cwd, <span class="hljs-built_in">sizeof</span>(cwd)) != <span class="hljs-literal">NULL</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;当前工作目录: &quot;</span> &lt;&lt; cwd &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;获取工作目录失败&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="file-path"><a href="#file-path" class="headerlink" title="file path"></a>file path</h2><p>例如打开一个文件：</p><ul><li><p>使用相对路径：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;../data/example.txt&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure><p> <strong>NOTE:</strong> <code>../</code> <strong>表示 current work directory 的父目录</strong></p></li><li><p>使用绝对路径：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;E:/WorkSpace/Employment/KnowledgeTest/data/example.txt&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="如何在文件处理中进行异常处理"><a href="#如何在文件处理中进行异常处理" class="headerlink" title="如何在文件处理中进行异常处理"></a>如何在文件处理中进行异常处理</h2><p>contents</p><h3 id="使用try-catch-机制捕获并处理异常"><a href="#使用try-catch-机制捕获并处理异常" class="headerlink" title="使用try-catch 机制捕获并处理异常"></a>使用try-catch 机制捕获并处理异常</h3><p>contents</p><h2 id="cpp-对字符串的处理"><a href="#cpp-对字符串的处理" class="headerlink" title="cpp 对字符串的处理"></a>cpp 对字符串的处理</h2><h3 id="find-funciton"><a href="#find-funciton" class="headerlink" title="find() funciton"></a>find() funciton</h3><ul><li>作用: 用于<strong>查找某个子字符串(或字符)首次出现的位置</strong>。</li><li>返回值：查找<strong>成功返回</strong>该子字符串的<strong>起始索引</strong>，查找<strong>失败返回 std::string::npos</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li>str 是要查找的子字符串</li><li>ch 是要查找的字符</li><li>pos 是查找起始位置，默认从 0 开始。</li></ul><h4 id="KMP-算法原理"><a href="#KMP-算法原理" class="headerlink" title="KMP 算法原理"></a>KMP 算法原理</h4><p>contents</p><h3 id="replace-function"><a href="#replace-function" class="headerlink" title="replace() function"></a>replace() function</h3><ul><li>作用: 用于替换字符串中的一部分内容。可以替换<strong>字符、字符串、用迭代器指定的字符范围</strong>。</li><li><p><strong>语法:</strong></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string &amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> std::string &amp; str)</span></span>;<br><span class="hljs-function">std::string &amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> std::string &amp; str, <span class="hljs-type">size_t</span> subpos, <span class="hljs-type">size_t</span> sublen)</span></span>;<br><span class="hljs-function">std::string &amp; <span class="hljs-title">replace</span><span class="hljs-params">(const_iterator first, const_iterator last, <span class="hljs-type">const</span> std::string &amp; str)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>pos: 要替换的起始位置</p></li><li>len: 要替换的字符或子字符串的长度</li><li>str: 用于替换的字符串</li><li>subpos, sublen: 如果用于替换的字符串是另一个字符串的一部分，可以指定字符串的起始位置和长度</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> file stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1 顺序容器概述</title>
      <link href="/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.1%20Sequentail%20Containers/"/>
      <url>/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.1%20Sequentail%20Containers/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序容器类型"><a href="#顺序容器类型" class="headerlink" title="顺序容器类型"></a>顺序容器类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Description</th><th style="text-align:left">Application</th><th style="text-align:left">Time Complexity (insert/delete/visit)</th></tr></thead><tbody><tr><td style="text-align:left">vector</td><td style="text-align:left"><strong>动态数组</strong>, 支持<strong>随机访问</strong>，<strong>尾部之外</strong>的位置插入删除会很慢</td><td style="text-align:left">大部分场景首选</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr><tr><td style="text-align:left">list</td><td style="text-align:left"><strong>双向链表</strong>，支持<strong>双向顺序访问</strong>，在任何位置<strong>插入删除都很快</strong></td><td style="text-align:left">频繁的插入删除操作</td><td style="text-align:left">insert/delete O(1), visit O(n)</td></tr><tr><td style="text-align:left">deque</td><td style="text-align:left"><strong>双端队列</strong>，支持<strong>快速随机访问</strong>，<strong>头尾位置插入、删除速度很快</strong></td><td style="text-align:left">双端插入、删除操作</td><td style="text-align:left">insert/delete O(1), visit O(1)</td></tr><tr><td style="text-align:left">array</td><td style="text-align:left"><strong>定长数组</strong>，支持快速<strong>随机访问</strong>元素，<strong>不能添加或删除</strong>元素</td><td style="text-align:left">大小固定的数组</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr><tr><td style="text-align:left">forward_list</td><td style="text-align:left">单向链表，只支持<strong>单向顺序访问</strong>，在任何位置的插入删除都很快</td><td style="text-align:left">更节省内存的链表</td><td style="text-align:left">insert/delete O(1), visit O(n)</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">字符序列，与 vector 相似，<strong>专门用于保存字符</strong>。支持<strong>随机访问</strong>，<strong>尾部的插入删除速度快</strong></td><td style="text-align:left">存储和操作文本数据</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr></tbody></table></div><p>NOTE: forward_list 中没有 size 操作。</p><h3 id="选择容器的基本原则"><a href="#选择容器的基本原则" class="headerlink" title="选择容器的基本原则"></a>选择容器的基本原则</h3><ul><li><strong>首选 vector</strong></li><li>程序有<strong>很多小的元素</strong>，且<strong>空间的额外开销</strong>很重要，则<strong>不要使用 list</strong> 或 <strong>forward_list</strong></li><li>要求<strong>随机访问元素</strong>，使用 <strong>vector</strong> 或 <strong>deque</strong></li><li>要求在容器<strong>中间插入或删除元素</strong>，使用 <strong>list</strong> 或 <strong>forward_list</strong></li><li>需要在容器<strong>头尾插入或删除元素</strong>，但<strong>不会在中间位置进行插入删除操作</strong>，使用 <strong>deque</strong></li><li><p>如果程序只有在<strong>读取输入时</strong>才需要在容器<strong>中间位置插入</strong>元素，随后需要<strong>随机访问元素</strong></p><ul><li>首先确定是否真的需要在容器中间位置添加元素。处理输入数据时，通常向 <strong>vector</strong> 追加元素，再使用<strong>标准库 sort 函数重排</strong>元素，避免在容器中间位置添加元素</li><li>如果必须在中间位置插入元素，考虑在<strong>输入阶段使用 list</strong>，一旦输入完成，将 <strong>list 内容拷贝到 vector</strong> 中</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 顺序容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2 容器库概览</title>
      <link href="/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.2%20%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88/"/>
      <url>/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.2%20%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="容器的通用操作"><a href="#容器的通用操作" class="headerlink" title="容器的通用操作"></a>容器的通用操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类型别名</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">iterator</td><td style="text-align:left">此容器类型的迭代器类型</td></tr><tr><td style="text-align:left">const_iterator</td><td style="text-align:left">可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td style="text-align:left">size_type</td><td style="text-align:left">无符号整数类型，足够保存此种容器类型最大可能容器大小</td></tr><tr><td style="text-align:left">difference_type</td><td style="text-align:left">带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td style="text-align:left">value_type</td><td style="text-align:left">元素类型</td></tr><tr><td style="text-align:left">reference</td><td style="text-align:left">元素的左值类型，与 <code>value_type &amp;</code> 含义相同</td></tr><tr><td style="text-align:left">const_reference</td><td style="text-align:left">元素的 const 左值类型 (即 <code>const value_type &amp;</code> )</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">构造函数</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">C c</td><td style="text-align:left">默认构造函数</td></tr><tr><td style="text-align:left">C c1(c2)</td><td style="text-align:left">构造 c2 的拷贝 c1</td></tr><tr><td style="text-align:left">C c(b, e)</td><td style="text-align:left">构造 c, 将迭代器 b 和 e 指定范围内的元素拷贝到 c (<strong>array 不支持</strong>)</td></tr><tr><td style="text-align:left">C c{a, b, c, …} <br> C c = {a, b, c, …}</td><td style="text-align:left">列表初始化, c 初始化为列表中元素的拷贝，列表元素类型必须与 C 中元素类型相容；对于 array，列表中<strong>元素数量必须小于等于 array 大小</strong></td></tr><tr><td style="text-align:left">C seq(n)</td><td style="text-align:left">seq 包含 n 个元素，元素进行了值初始化；此构造函数是 explicit。<strong>string 不适用</strong></td></tr><tr><td style="text-align:left">C seq(n, t)</td><td style="text-align:left">seq 包含 n 个 值初始化为 t 的元素</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">赋值与 swap</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1 = c2</td><td style="text-align:left">将 c1 中的元素替换为 c2 中的元素</td></tr><tr><td style="text-align:left">c1 = {a, b, c, …}</td><td style="text-align:left">将 c1 中的元素替换为列表中的元素(不支持 array)</td></tr><tr><td style="text-align:left">a.swap(b)</td><td style="text-align:left">交换 a 和 b 的元素</td></tr><tr><td style="text-align:left">swap(a, b)</td><td style="text-align:left">与 a.swap(b) 等价</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">大小</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.size()</td><td style="text-align:left">c 中元素的数目(不支持 forward_list)</td></tr><tr><td style="text-align:left">c.max_size()</td><td style="text-align:left">c 中可保存的最大元素数目</td></tr><tr><td style="text-align:left">c.empty()</td><td style="text-align:left">若 c 中存储了元素，返回 false，否则返回 true</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">添加/刪除元素(不适用于 array)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.insert(args)</td><td style="text-align:left">将 args 中的元素拷贝到 c 中</td></tr><tr><td style="text-align:left">c.emplace(inits)</td><td style="text-align:left">使用 inits 构造 c 中的一个元素</td></tr><tr><td style="text-align:left">c.eraser(args)</td><td style="text-align:left">删除 args 指定的的元素</td></tr><tr><td style="text-align:left">c.clear()</td><td style="text-align:left">删除 c 中的所有元素，返回 void</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">关系运算符</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">==, !=</td><td style="text-align:left">所有容器都支持</td></tr><tr><td style="text-align:left">&lt;, &lt;=, &gt;, &gt;=</td><td style="text-align:left">无需关联容器不支持</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">获取迭代器</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.begin(), c.end()</td><td style="text-align:left">返回指向 c 的首元素和尾元素之后位置的迭代器</td></tr><tr><td style="text-align:left">c.cbegin(), c.cend()</td><td style="text-align:left">返回 const_iterator</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">反向容器的额外成员(不支持 forward_list)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">reverse_iterator</td><td style="text-align:left">按逆序寻址元素的迭代器</td></tr><tr><td style="text-align:left">const_reverse_itrator</td><td style="text-align:left">不能修改元素的逆序迭代器</td></tr><tr><td style="text-align:left">c.rbegin(), c.rend()</td><td style="text-align:left">返回指向尾元素和首元素之前位置的迭代器</td></tr><tr><td style="text-align:left">c.crbegin(), c.crend()</td><td style="text-align:left">返回 const_reverse_itrator</td></tr></tbody></table></div><hr><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="若-begin-end-构成合法的迭代器范围"><a href="#若-begin-end-构成合法的迭代器范围" class="headerlink" title="若 begin, end 构成合法的迭代器范围"></a>若 begin, end 构成合法的迭代器范围</h3><ul><li>begin==end, 容器为空</li><li>begin!=end, 容器至少含有一个元素</li><li>可以通过对 begin 的若干次递增，使得 begin==end</li></ul><h3 id="begin-end-有多个版本"><a href="#begin-end-有多个版本" class="headerlink" title="begin, end 有多个版本"></a>begin, end 有多个版本</h3><ul><li>begin, end：正常版本，支持对容器读写操作</li><li>cbegin, cend：const 版本，只支持对容器读操作</li><li>rbegin, rend：返回反向迭代器，支持读写操作</li><li>crbegin, crend：const 版本反向迭代器，只支持读操作</li></ul><p><strong>NOTE：</strong></p><ul><li>forward_list 不支持递减运算符 “—“；</li></ul><hr><h2 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h2><ul><li>迭代器类型</li><li>反向迭代器类型</li><li>通过<strong>类型别名</strong>，可以在不知道元素类型的情况下使用它<ul><li>需要<strong>元素类型</strong>，使用容器的 <strong>value_type</strong></li><li>需要<strong>元素类型的引用</strong>，使用容器的 <strong>reference</strong> 或 <strong>const_reference</strong></li></ul></li></ul><hr><h2 id="容器定义与初始化"><a href="#容器定义与初始化" class="headerlink" title="容器定义与初始化"></a>容器定义与初始化</h2><h3 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h3><ul><li>直接拷贝整个容器</li><li>拷贝由一个迭代器对指定的范围( array 除外)</li><li>当将一个容器初始化为另一个容器的拷贝时，<strong>容器类型</strong>和<strong>元素类型必须相同</strong></li><li><p>使用迭代器范围的构造函数：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 拷贝元素，直到（但不包括）it 指向的元素</span><br><span class="hljs-function">deque&lt;string&gt; <span class="hljs-title">authList</span><span class="hljs-params">(author.begin(), it)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="与顺序容器大小有关的构造函数"><a href="#与顺序容器大小有关的构造函数" class="headerlink" title="与顺序容器大小有关的构造函数"></a>与顺序容器大小有关的构造函数</h3><ul><li><p><strong>只有顺序容器</strong>(不包含 array)才能<strong>接受大小参数</strong>, 关联容器不支持</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">C <span class="hljs-title">seq</span><span class="hljs-params">(n)</span></span>;       <span class="hljs-comment">// seq 包含了 n 个元素，这些元素进行了值初始化，</span><br>                <span class="hljs-comment">// 此构造函数是 explicit 的，string 不适用</span><br><span class="hljs-function">C <span class="hljs-title">seq</span><span class="hljs-params">(n, v)</span></span>;    <span class="hljs-comment">// seq 包含 n 个值为 v 的元素</span><br></code></pre></td></tr></table></figure></li><li><p>array 具有固定大小，使用 <strong>array 时必须指定元素类型与大小</strong></p></li><li><p>array 不支持普通的容器构造函数，一个默认构造的 array 是非空的，元素都进行默认初始化</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>, 10&gt; ia1;        <span class="hljs-comment">// 数组类型包括元素类型与大小</span><br>array&lt;<span class="hljs-type">int</span>, 10&gt; ia2 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; ia3 = &#123;<span class="hljs-number">42</span>&#125;; <span class="hljs-comment">// ia3[0] 的元素为42，其余元素为 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>内置数组类型不能进行拷贝或对象赋值操作</strong>，但 array 可以</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> digs[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> cop[<span class="hljs-number">10</span>] = digs;     <span class="hljs-comment">// 错误！内置数组类型不支持拷贝或赋值</span><br>array&lt;<span class="hljs-type">int</span>, 10&gt; digits = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; copys = digits;      <span class="hljs-comment">// 正确：只要数组类型匹配即合法</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="赋值与-swap"><a href="#赋值与-swap" class="headerlink" title="赋值与 swap"></a>赋值与 swap</h2><ul><li>赋值运算符将其左边容器中的全部元素替换为右边容器中的拷贝，大小也变得与右边容器相等</li><li><p>array 类型允许赋值，“=” 左右容器类型与元素类型必须相同（包括 <strong>array 的大小</strong>）</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>, 10&gt; a1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; a2 = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-comment">// 10 个元素全部初始化为 0</span><br>a1 = a2;    <span class="hljs-comment">// 替换 a1 中的元素</span><br></code></pre></td></tr></table></figure></li><li><p>由于 “=” 左右容器大小可能不容，array 不支持 assign，也不允许 {} 包围的值列表进行赋值（<strong>注意区分赋值与初始化</strong>）</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">a2 = &#123;<span class="hljs-number">0</span>&#125;;   <span class="hljs-comment">// 错误！不允许值列表进行赋值</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="容器赋值运算"><a href="#容器赋值运算" class="headerlink" title="容器赋值运算"></a>容器赋值运算</h3><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1 = c2</td><td style="text-align:left">将 c1 中的元素替换为 c2 中元素的拷贝。c1, c2 必须具有相同类型</td></tr><tr><td style="text-align:left">c = {a, b, c, …}</td><td style="text-align:left">将 c 中的元素替换为列表中元素的拷贝。<strong>array 不支持</strong></td></tr></tbody></table></div><h3 id="使用-assign-成员"><a href="#使用-assign-成员" class="headerlink" title="使用 assign 成员"></a>使用 assign 成员</h3><ul><li>顺序容器(array 除外)定义了 assign 成员，assign 操作用参数指定的元素的拷贝替换左边容器中的所有元素</li><li><strong>assign</strong> 允许从一个<strong>不同但相容的类型赋值</strong></li><li><strong>assign</strong> 允许从<strong>容器的一个子序列赋值</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">assign Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">seq.assign(b, e)</td><td style="text-align:left">将 seq 中的元素替换为迭代器 b, e所指向范围内的元素(<strong>迭代器b,e不能指向 seq</strong>)</td></tr><tr><td style="text-align:left">seq.assign(il)</td><td style="text-align:left">将 seq 中的元素替换为初始化列表 il 中的元素</td></tr><tr><td style="text-align:left">seq.assign(n, v)</td><td style="text-align:left">将 seq 中的元素替换为 n 个值为 v 的元素</td></tr></tbody></table></div><p><strong>NOTE:</strong></p><ul><li><strong>assign 操作不能用于关联容器和 array</strong></li></ul><h3 id="使用-swap"><a href="#使用-swap" class="headerlink" title="使用 swap"></a>使用 swap</h3><div class="table-container"><table><thead><tr><th style="text-align:left">Swap Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1. swap(c2) <br> swap(c1, c2)</td><td style="text-align:left">交换 c1, c2中的元素(c1 和 c2 必须具有相同的类型)。<strong>swap 通常比从 c2 向 c1 拷贝元素快</strong></td></tr></tbody></table></div><ul><li>除 array 外，交换两个容器内容的操作很快——<strong>容器本身并未交换，只是交换了两个容器的内部数据结构</strong></li><li>除 array 外，<strong>swap 不对任何元素进行拷贝、删除或插入操作</strong>，因此可以保证在常数时间内完成。</li><li>swap 两个 <strong>array</strong> 会真正交换它们的元素</li><li>标准库中既提供成员函数版本的 swap, 也提供非成员函数版本的 swap</li></ul><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li><strong>赋值相关运算</strong>会<strong>导致</strong>指向<strong>左边容器内部</strong>的<strong>迭代器、引用和指针失效</strong>，而<strong>除 string 外</strong>，<strong>swap</strong> 操作将容器内容交换<strong>不会导致</strong>指向容器的迭代器、引用、指针失效</li></ul><hr><h2 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h2><ul><li>成员函数 size, 返回容器中元素的数目</li><li>empty：当 size 为 0 时返回 true, 否则返回 false</li><li>max_size: 返回一个大于或等于该容器所能容纳的最大元素数量的值</li><li>forward_list 支持 max_size 和 empty, 不支持 size</li></ul><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><ul><li><strong>每个容器</strong>都支持相等运算符 <strong>“==”</strong> 和 <strong>“!=”</strong></li><li><strong>除无序容器外</strong>的所有容器<strong>都支持</strong>关系运算符：<strong>“&gt;, &gt;=, &lt;, &lt;=”</strong></li><li>关系运算符左右两边的<strong>容器必须是相同类型</strong>，且<strong>保存相同类型元素</strong></li></ul><h3 id="运算符工作方式与-string-相似"><a href="#运算符工作方式与-string-相似" class="headerlink" title="运算符工作方式与 string 相似"></a>运算符工作方式与 string 相似</h3><ul><li>两容器大小相等，所有元素两两对应相等，则两容器相等</li><li>两容器大小不等，小容器中元素都等于大容器中对应位置元素，则小容器小于大容器</li><li>两容器都不是另一个容器的前缀子序列，它们的比较结果取决于第一个不相等的元素</li></ul><h3 id="容器的关系运算符使用元素的关系运算符完成比较"><a href="#容器的关系运算符使用元素的关系运算符完成比较" class="headerlink" title="容器的关系运算符使用元素的关系运算符完成比较"></a>容器的关系运算符使用元素的关系运算符完成比较</h3><ul><li>只有元素类型也定义了相应的比较运算符时，容器才可以使用关系运算符比较</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 容器库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3 顺序容器操作</title>
      <link href="/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.3%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.3%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h2><ul><li>除 array 外，所有容器都可以动态添加或删除元素</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.push_back(t) <br> c.emplace_back(args)</td><td>在 c 的尾部创建一个值为 t 或由 args 创建的元素。返回 void</td></tr><tr><td>c.push_front(t) <br> c.emplace_front(args)</td><td>在 c 的头部创建一个值为 t 或由 args 创建的元素。返回void</td></tr><tr><td>c.insert(p, t) <br> c.emplace(p, args)</td><td>在迭代器 <strong>p 指向的元素之前</strong>创建一个值为 t 或由 args 创建的元素。<strong>返回指向新添加元素的迭代器</strong></td></tr><tr><td>c.insert(p, n, t)</td><td>在迭代器 <strong>p 指向的元素之前</strong>插入 n 个值为 t 的元素。<strong>返回指向新添加的第一个元素的迭代器</strong>；若 <strong>n 为 0</strong>，则<strong>返回 p</strong>。</td></tr><tr><td>c.insert(p, begin, end)</td><td>将迭代器 begin 和 end 指向范围内的元素插入到迭代器 p 指向的元素之前。<strong>begin 和 end 不能指向 c 中的元素</strong>。<strong>返回指向新添加第一个元素的迭代器</strong>；若<strong>范围为空</strong>，则<strong>返回 p</strong></td></tr><tr><td>c.insert(p, il)</td><td>il 是 {} 包围的元素值列表。将这些给定值插入到迭代器 p 指向的元素之前。<strong>返回指向新添加第一个元素的迭代器</strong>；若列表为空，则返回 p</td></tr></tbody></table></div><ul><li>forward_list 有自己专有版本的 insert 和 emplace</li><li><strong>forward_list</strong> <strong>不支持</strong> push_back 和 emplace_back</li><li><strong>vector 和 string 不支持</strong> push_front 和 emplace_front</li><li>向 <strong>vector、string、deque 插入元素</strong>会使指向容器的<strong>所有迭代器、引用、指针失效</strong></li><li>不同容器使用不同的内存分配策略</li><li>在 <strong>vector 或 string 尾部之外</strong>，或 <strong>deque 的首尾之外</strong>的任何位置<strong>添加元素</strong>，都<strong>需要移动元素</strong></li><li>向 vector 或 string 添加元素，可能引起整个对象存储空间的重新分配。重新分配对象存储空间需要重新分配内存，并将元素从旧的内存空间移动到新的内存空间</li></ul><h3 id="元素容器是拷贝"><a href="#元素容器是拷贝" class="headerlink" title="元素容器是拷贝"></a>元素容器是拷贝</h3><ul><li>使用对象来初始化容器，或将一个对象插入到容器中时，实际放入容器的是对象的拷贝</li></ul><h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><ul><li>vector, string, list, deque 都支持 push_back</li></ul><h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><ul><li>list, forward_list, deque 支持 push_front</li><li>vector 不支持 push_front</li></ul><h3 id="在容器特定位置添加元素"><a href="#在容器特定位置添加元素" class="headerlink" title="在容器特定位置添加元素"></a>在容器特定位置添加元素</h3><ul><li>vector, deque, list, string 都支持 insert</li><li>forward_list 有自己版本的 insert</li><li><p>有些容器不支持 push_front，但支持 insert，可以用 insert 在容器开始位置添加元素</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; vec;<br>vec.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">begin</span>(), <span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="emplace-操作"><a href="#emplace-操作" class="headerlink" title="emplace 操作"></a>emplace 操作</h4><ul><li>emplace, emplace_front, emplace_back 是<strong>构造元素</strong>，而不是拷贝元素</li><li>调用 push 或 insert 成员，是将元素类型的对象传递给它们，这些<strong>对象被拷贝到容器中</strong></li><li>调用 emplace 成员，是将参数传递给元素类型的构造函数。emplace 成员使用参数在容器管理的内存空间直接构造元素</li><li>传递给 emplace 函数的参数必须与元素类型的构造函数相匹配</li></ul><hr><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><ul><li>所有顺序容器都有 front 成员函数，返回首元素引用</li><li><strong>除 forward_list 之外</strong>，所有顺序容器都有 back 成员函数，返回尾元素引用</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.back()</td><td>返回 c 中尾元素的引用。若 c 为空，则函数行为未定义</td></tr><tr><td>c.front()</td><td>返回 c 中首元素的引用。若 c 为空，则函数行为未定义</td></tr><tr><td>c[n]</td><td>返回 c 中下标为 n 的元素的引用。n 是无符号整数，若 n &gt; c.size(), 则函数行为未定义</td></tr><tr><td>c.at(n)</td><td>返回 c 中下标为 n 的元素的引用。如果下标越界，抛出 out_of_range 异常</td></tr></tbody></table></div><ul><li>at 只适用于 string，vector，deque，array</li><li>back 不适用于 forward_list</li></ul><hr><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.pop_back()</td><td>删除 c 中尾元素。若 c 为空，函数行为未定义。返回 void</td></tr><tr><td>c.pop_front()</td><td>删除 c 中首元素。若 c 为空，函数行为未定义。返回 void</td></tr><tr><td>c.erase(p)</td><td>删除迭代器 p 指向的元素，<strong>返回一个指向被删元素之后元素的迭代器</strong>。若 p 指向尾元素，则返回尾后(off-the-end)顶点。若 p 是尾后迭代器，函数行为未定义</td></tr><tr><td>c.erase(b, e)</td><td>删除迭代器 b, e 指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器。若 e 本身是尾后迭代器，则返回的也是尾后迭代器</td></tr><tr><td>c.clear()</td><td>删除 c 中所有元素，返回 void</td></tr></tbody></table></div><ul><li>这些删除操作会改变容器大小，因此不适用于 array</li><li>forward_list 有自己版本的 erase</li><li>f<strong>orward_list 不支持 pop_back</strong></li><li><strong>vector、string 不支持 pop_fron</strong>t</li><li>删除 <strong>deque 除首尾之外</strong>的元素，会使所有迭代器、引用、指针失效</li><li>指向 <strong>vector 或 string 删除点之后位置</strong>的迭代器、引用、指针失效</li><li>删除元素的成员函数不检查参数，因此必须确保被删除元素存在</li></ul><hr><h2 id="forward-list-特殊操作"><a href="#forward-list-特殊操作" class="headerlink" title="forward_list 特殊操作"></a>forward_list 特殊操作</h2><ul><li>在单向链表中，没有简单的方法来获取一个元素的前驱。</li><li>在 forward_list 中添加删除操作都是通过<strong>改变给定元素之后的元素</strong>来完成</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>lst.before_begin() <br> lst.cbefore_begin()</td><td><strong>返回指向链表首元素之前不存在元素的迭代器</strong>。此迭代器<strong>不能解引用</strong>。cbefore_begin 返回 const_iterator</td></tr><tr><td>lst.insert_after(p, t) <br> lst.insert_after(p, n, t) <br> lst.insert_after(p, b, e) <br> lst.insert(p, il)</td><td>在迭代器 <strong>p 之后的位置插入元素</strong>。<br> t 是一个对象，n 是数量，b 和 e 是一对表示范围的迭代器（<strong>b，e 不能指向 lst 内</strong>），il 是一个花括号列表。<br> <strong>返回指向最后一个插入元素的迭代器</strong>。如果<strong>范围为空，则返回 p</strong>。如果 p 是尾后迭代器，则函数行为未定义</td></tr><tr><td>emplace_after(p, args)</td><td>使用 args 在 <strong>p 指定位置之后创建</strong>一个元素。<br> <strong>返回一个指向新元素的迭代器</strong>。若 p 为尾后迭代器，函数行为未定义</td></tr><tr><td>lst.erase_after(p) <br> lst.erase_after(b, e)</td><td>删除迭代器 <strong>p 指定位置之后</strong>的元素。或删除 <strong>从 b 之后直到（但不包括） e</strong> 之间的元素。<br> <strong>返回一个指向被删元素之后元素的迭代器</strong>。若<strong>不存在</strong>这样的元素，<strong>返回尾后迭代器</strong>；如果 <strong>p 指向 lst 的尾元素</strong>或者是<strong>尾后迭代器</strong>，函数行为未定义</td></tr></tbody></table></div><ul><li><p>在 forward_list 中添加或删除元素时，必须关注两个迭代器：一<strong>个指向要处理的元素</strong>，另<strong>一个指向其前驱</strong></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">forward_list&lt;<span class="hljs-type">int</span>&gt; flst&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">auto</span> prev = flst.<span class="hljs-built_in">before_begin</span>();        <span class="hljs-comment">// 指向 flst 的首前元素</span><br><span class="hljs-keyword">auto</span> curr = flst.<span class="hljs-built_in">begin</span>();               <span class="hljs-comment">// 指向 flst 的首元素</span><br><span class="hljs-keyword">while</span> (curr != flst.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (*curr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        curr = flst.<span class="hljs-built_in">erase_after</span>(prev);  <span class="hljs-comment">// 删除元素并移动 curr</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev = curr;                    <br>        ++curr;                         <span class="hljs-comment">// 移动 curr，指向下一个元素，prev 指向 curr 前驱</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h2><ul><li>使用 <strong>resize</strong> 增大或缩小容器大小</li><li>当前大小 &lt; 要求大小，容器后面元素会被删除</li><li>当前大小 &gt; 要求大小，会将新元素添加到容器后面</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.resize(n)</td><td>调整 c 的大小为 n 个元素。<br> 若 n &lt; c.size(), 则多出的元素会被删除 <br> 若必须添加新元素，则对新元素进行值初始化</td></tr><tr><td>c.resize(n, t)</td><td>调整 c 的大小为 n 个元素。<br> 任何新添加的元素都初始化为 t</td></tr></tbody></table></div><ul><li>resize 不适用于 array</li><li>如果 resize 缩小容器大小，则指向被删除元素的迭代器、指针、引用都失效</li><li>对 vector、string、deque 使用 resize 可能导致迭代器、引用、指针失效</li></ul><hr><h2 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h2><h3 id="向容器添加元素后"><a href="#向容器添加元素后" class="headerlink" title="向容器添加元素后"></a>向容器添加元素后</h3><ul><li><strong>vector</strong> 、<strong>string</strong>：<strong>存储空间被重新分配</strong>，则指向容器的<strong>迭代器、引用、指针失效</strong>；<strong>存储空间未重新分配</strong>，则指向<strong>插入元素之前</strong>的<strong>迭代器、引用、指针有效</strong>，指向<strong>插入元素之后</strong>的<strong>迭代器、引用、指针都失效</strong></li><li><strong>deque</strong>：插入到<strong>首尾位置之外</strong>的任何位置<strong>都会使迭代器、引用、指针失效</strong>。<strong>首尾位置添加元素</strong>，<strong>迭代器会失效</strong>，<strong>但</strong>指向容器内元素的<strong>引用、指针不会失效</strong></li><li><strong>list</strong>、<strong>forward_list</strong>：<strong>迭代器、指针、引用仍有效</strong></li></ul><h3 id="从容器删除元素后"><a href="#从容器删除元素后" class="headerlink" title="从容器删除元素后"></a>从容器删除元素后</h3><ul><li><strong>vector、string</strong>：指向<strong>被删元素之前</strong>的迭代器、引用、指针仍有效</li><li><strong>deque</strong>：<strong>首尾之外</strong>删除元素，指向被删元素之外的<strong>其他迭代器、引用、指针都失效</strong>。<strong>删除尾元素</strong>，<strong>尾后迭代器失效</strong>，其他迭代器、引用、指针仍有效。<strong>删除首元素</strong>，不会受影响</li><li><strong>list、forward_list</strong>：指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用、指针<strong>仍有效</strong></li></ul><h3 id="不要保存-end-返回的迭代器"><a href="#不要保存-end-返回的迭代器" class="headerlink" title="不要保存 end 返回的迭代器"></a>不要保存 end 返回的迭代器</h3><ul><li>vector、string 添加删除元素，或 deque 除首位置之外添加删除元素，都<strong>会导致尾后迭代器失效</strong>，因此添加删除元素的循环过程必须反复调用 end()，不能在循环前保存 end</li></ul><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li><strong>复合赋值语句</strong>（+=）只适用于 vector、string、deque、array，<strong>不适用于 list，forward_list</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 顺序容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 类的其他特性</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.3%20%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.3%20%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="定义类型成员"><a href="#定义类型成员" class="headerlink" title="定义类型成员"></a>定义类型成员</h2><p>自定义某种类型在类中的别名：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>typedef std::string::size_type pos;</code> 等价于 <code>using pos = std::string::size_type;</code></p><h2 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h2><ul><li>在类内部使用 <code>inline</code>作为函数声明的一部分，将函数显示的声明为内联函数</li><li><p>也可以在类外部用 <code>inline</code> 关键字修饰函数的定义</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];        <span class="hljs-comment">// 隐式内联</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">// 显示内联</span><br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span>                          <span class="hljs-comment">// 在函数定义处指定 inline</span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">Screen::move</span><span class="hljs-params">(Screen::pos r, Screen::pos c)</span> </span>&#123;<br>    pos row = r * width;        <span class="hljs-comment">// 计算行的位置</span><br>    cursor = row + c;           <span class="hljs-comment">// 将光标移动到指定的列</span><br>    <span class="hljs-keyword">return</span>  *<span class="hljs-keyword">this</span>;              <span class="hljs-comment">// 以左值的形式返回对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(Screen::pos r, Screen::pos c)</span> <span class="hljs-type">const</span> </span>&#123;      <span class="hljs-comment">// 在类的内部声明为内联函数</span><br>    pos row = r * width;        <span class="hljs-comment">// 计算行的位置</span><br>    <span class="hljs-keyword">return</span> contents[row + c];   <span class="hljs-comment">// 返回给定列的字符</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h2><ul><li><p>可变数据成员(mutable data member)永远不会是 cosnt, 即使它是const 对象的成员。因此一个 const 成员函数可以改变一个可变成员的值</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>通过 access_ctr 可变成员，追踪成员函数被调用次数</p></li><li>some_member() 是一个 const 成员函数，但依旧可以改变 access_ctr 可变成员的值</li></ul><h2 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h2><p>定义一个窗口管理类并用它表示显示器上的一组 Screen。这个类包含一个 Screen 类型的 vector，每个元素表示一个特定的 Screen，默认情况下，Window_mgr 类有一个默认初始化的 Screen</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br>    std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&#x27; &#x27;</span>)&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>类内初始值必须使用 <strong>=的初始化形式</strong>或者 <strong>{}的直接初始化形式</strong></li></ul><h2 id="返回-this-的成员函数"><a href="#返回-this-的成员函数" class="headerlink" title="返回 *this 的成员函数"></a>返回 *this 的成员函数</h2><ul><li><p>添加函数，负责设置光标所在位置字符或其他任一给定位置字符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd) &#123; contents = ht * wd, <span class="hljs-string">&#x27; &#x27;</span>; &#125;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(pos, pos, <span class="hljs-type">char</span>)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br>&#125;;<br></code></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    contents[cursor] = c;       <span class="hljs-comment">// 设置当前光标所在位置新值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;               <span class="hljs-comment">// 将 this 对象作为左值返回</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(pos r, pos col, <span class="hljs-type">char</span> c)</span> </span>&#123;<br>    contents[r*width + col] = c;        <span class="hljs-comment">// 设置指定位置的值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                       <span class="hljs-comment">// 将 this 对象作为左值返回</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回引用的函数是左值的，这些函数返回对象本身而不是对象的副本。此时可进行如下操作：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 把光标移动到指定位置，然后设置该位置的值</span><br>myscreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>).<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="从-const-成员函数返回-this"><a href="#从-const-成员函数返回-this" class="headerlink" title="从 const 成员函数返回 *this"></a>从 const 成员函数返回 *this</h3><p>添加 display() 操作，负责打印 Screen 的内容。</p><ul><li>若将 display() 设置为 const, 则 this 是指向 const 的指针，而 *this 是 const 对象</li><li>一个 <strong>const 成员函数</strong>如果以<strong>引用</strong>形式返回 *this，那么它的<strong>返回类型是常量引用</strong></li></ul><h3 id="基于-const-的重载"><a href="#基于-const-的重载" class="headerlink" title="基于 const 的重载"></a>基于 const 的重载</h3><p>由于非常量版本函数对于常量对象不可用，所以重载一个 const 版本的成员函数很有必要</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd) &#123; contents = ht * wd, <span class="hljs-string">&#x27; &#x27;</span>; &#125;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(pos, pos, <span class="hljs-type">char</span>)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 根据对象是否是 const 重载了 display 函数</span><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp; os)</span> </span>&#123;<br>        <span class="hljs-built_in">do_display</span>(os); <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> Screen &amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">do_display</span>(os);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br><br>    <span class="hljs-comment">// 该函数负责显示 Screen 的内容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span> </span>&#123; os &lt;&lt; contents; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 do_display 完成后，display 返回解引用 this 所得的对象</p><ul><li>非常量版本中，<strong>this 指向一个非常量对象</strong>，因此 display 返回一个 非常量引用</li><li>const 成员中，<strong>this 指向一个常量对象</strong>，display返回一个常量引用</li></ul><h2 id="类之间的友元关系"><a href="#类之间的友元关系" class="headerlink" title="类之间的友元关系"></a>类之间的友元关系</h2><p>A 类若想访问 B 类的私有成员，需要被 B 类声明为友元。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-comment">// window_mgr 成员可以访问 Screen 的私有成员</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span>;<br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br>    std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&#x27; &#x27;</span>)&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(window_mgr::ScreenIndex i)</span> </span>&#123;<br>    <span class="hljs-comment">// s 是 Screen 的引用，指向想清空的那个 Screen</span><br>    Screen &amp;s = screens[i];<br>    <span class="hljs-comment">// 将选定 Screen 重置为空白</span><br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将 window_mgr 声明为 Screen 的友元，则 window_mgr 的成员可以访问 Screen 的私有成员</li><li><strong>友元关系不存在传递性</strong>，每个类负责控制自己的友元类或友元函数</li></ul><h2 id="成员函数作为友元"><a href="#成员函数作为友元" class="headerlink" title="成员函数作为友元"></a>成员函数作为友元</h2><h3 id="程序设计步骤"><a href="#程序设计步骤" class="headerlink" title="程序设计步骤"></a>程序设计步骤</h3><ul><li><strong>首先，定义 window_mgr 类</strong>，在其中声明 clear 成员，但不定义它。<strong>在 clear 函数使用 Screen 的成员之前必须声明 Screen 类</strong></li><li><strong>接下来定义 Screen,</strong> 包括对于 clear 的友元声明</li><li><strong>最后定义 clear</strong>, 此时它才可以使用 Screen 的成员</li></ul><p>Screen 只为 window_mgr 的成员 clear 提供访问权限</p><h3 id="详细代码示例"><a href="#详细代码示例" class="headerlink" title="详细代码示例"></a>详细代码示例</h3><ol><li><p>首先<strong>定义 window_mgr 类</strong></p><ul><li>在 window_mgr.h 中使用 Screen 类的<strong>前置声明</strong>，防止循环依赖</li><li><p>在 window_mgr 类中<strong>声明 clear 成员</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br><span class="hljs-comment">//    std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;</span><br>    std::vector&lt;Screen&gt; screens;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>其次<strong>定义 Screen 类</strong></p><ul><li>在 <strong>Screen.h</strong> 文件中使用 <code>#include &quot;window_mgr.h&quot;</code>，使得 <strong>clear 声明在 Screen 类之前</strong></li><li><p>在 Screen 类中声明 clear 为友元函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;window_mgr.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-comment">// window_mgr 成员可以访问 Screen 的私有成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(ScreenIndex)</span></span>;  <span class="hljs-comment">// 声明window_mgr的clear为友元函数</span><br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>最后<strong>定义 clear 成员</strong></p><ul><li>在 window_mgr.cpp 中 包含 Screen.h, 使得 <strong>Screen 类的声明在 clear 定义之前</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;window_mgr.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Screen.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(window_mgr::ScreenIndex i)</span> </span>&#123;<br>    <span class="hljs-comment">// s 是 Screen 的引用，指向想清空的那个 Screen</span><br>    Screen &amp;s = screens[i];<br>    <span class="hljs-comment">// 将选定 Screen 重置为空白</span><br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="编译器对-Screen-h-Screen-cpp-window-mgr-h-window-mgr-cpp-的处理过程"><a href="#编译器对-Screen-h-Screen-cpp-window-mgr-h-window-mgr-cpp-的处理过程" class="headerlink" title="编译器对 Screen.h, Screen.cpp, window_mgr.h, window_mgr.cpp 的处理过程"></a>编译器对 Screen.h, Screen.cpp, window_mgr.h, window_mgr.cpp 的处理过程</h3><pre class="mermaid">flowchart TD    A["Screen.cpp"]    A --> B["#include "Screen.h""]    B --> C["#include "window_mgr.h""]    C --> D["窗口管理器(window_mgr)的完整声明（含 friend 声明）"]    B --> E["Screen 类定义（友元声明：friend void window_mgr::clear(ScreenIndex);)"]    subgraph TU1["Screen.cpp的翻译单元"]        D        E    end</pre><ul><li>Screen.cpp 中包含 <strong>Screen.h</strong> ,Screen.h 中包含 <strong>window_mgr.h</strong></li><li>此时 window_mgr 已经完整，能正确处理友元声明</li><li>这个翻译单元中包含了 Screen.cpp 的代码，Screen.h 中 Screen 类的定义及友元声明，window_mgr.h 中 window_mgr 的声明（此时 <strong>window_mgr 内部对 Screen 的引用只需前向声明即可</strong>）</li></ul><pre class="mermaid">flowchart TD    A["window_mgr.CPP"]    A --> B["#include "window_mgr.h""]    B --> C["window_mgr 类定义（包含对 Screen 的前向声明）"]    A --> D["#include "Screen.h""]    D --> E[Screen 类的完整定义（含友元声明）]    subgraph "TU2: Window_mgr.cpp 翻译单元"        C        E    end</pre><ul><li><strong>window_mgr.cpp</strong> 首先包含 <strong>window_mgr.h</strong>，这时 window_mgr 中对 Screen 的引用仅为前向声明</li><li>随后在 <strong>window_mgr.cpp</strong> 中包含 <strong>Screen.h</strong>(通过包含获得 Screen.h 的完整定义)，从而可以在 <strong>window_mgr.cpp</strong> 中使用 Screen 类的 <strong>public 成员</strong></li><li>也可以让 clear() 使用 Screen 类的私有成员(clear 已被声明为友元)</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 类的特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 类的作用域</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.4%20%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.4%20%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域和定义在类外部的成员"><a href="#作用域和定义在类外部的成员" class="headerlink" title="作用域和定义在类外部的成员"></a>作用域和定义在类外部的成员</h2><ol><li><p>为什么类外部定义成员函数必须提供类名和函数名</p><ul><li>一个类就是一个作用域</li><li><p>一旦遇到类名，定义的剩余部分就在类的作用域之内，包括参数列表和函数体</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(ScreenIndex i)</span> </span>&#123;<br>    Screen &amp;s = screens[i];<br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译器在处理参数列表之前已经明确了当前正处于 window_mgr 类作用域中，所以不必专门说明 ScreenIndex 是 window_mgr 类定义的。</li><li>screens 也是同理</li></ul></li></ul></li><li><p>函数的返回类型必须指明它是哪个类的成员</p><ul><li><p>函数返回类型在函数名之前，当成员函数定义在类外部时，返回类型中使用的名字在类作用域外部，因此<strong>必须指明返回类型是哪个类的成员</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    ......<br><br>    <span class="hljs-comment">// 向窗口添加一个 Screen, 返回它的编号</span><br>    <span class="hljs-function">ScreenIndex  <span class="hljs-title">addScreen</span><span class="hljs-params">(<span class="hljs-type">const</span> Screen &amp;)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">window_mgr::ScreenIndex             <span class="hljs-comment">// 首先处理返回类型</span><br>        window_mgr::<span class="hljs-built_in">addScreen</span>(<span class="hljs-type">const</span> Screen &amp; s) &#123;<br>    screens.<span class="hljs-built_in">push_back</span>(s);<br>    <span class="hljs-keyword">return</span> screens.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要想使用 ScreenIndex 作为返回类型，<strong>必须明确指明哪个类定义了它</strong></li></ul></li></ul></li></ol><h2 id="名字查找-name-lookup"><a href="#名字查找-name-lookup" class="headerlink" title="名字查找(name lookup)"></a>名字查找(name lookup)</h2><ol><li><p><strong>一般查找过程</strong></p><ul><li>首先在名字所在块儿中寻找声明语句，只考虑在名字使用前出现的声明</li><li>如果没找到，继续查找外层作用域</li><li>如果最终没有找到匹配声明，程序报错</li></ul></li><li><p>对于<strong>定义在类内部的成员函数</strong></p><ul><li><strong>首先，编译成员的声明</strong></li><li>直到<strong>类全部可见后才编译函数体</strong></li></ul></li><li><p><strong>类型名</strong>要特殊处理</p><ul><li><strong>一般的</strong>，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过</li><li><strong>特殊</strong>：在类中，如果成员使用了外层作用域的某个名字，改名字代表类型，则<strong>类不能在之后重新定义该名字</strong></li></ul></li><li><p><strong>成员定义中的普通块作用域的名字查找</strong></p><ul><li>在成员函数内查找该名字声明，同样只考虑函数使用之前出现的名字</li><li>成员函数内没找到，则在类内查找，类的所有成员都可以被考虑</li><li>类内没找到，在成员函数定义之前的作用域内查找</li></ul></li><li><p>类的作用域之后，<strong>在外围作用域查找</strong></p><ul><li>在函数和类中没有找到声明，则在类的外部作用域查找</li><li>若需要使用外层作用域中的同名的名字，可以使用<code>::</code>作用域运算符来进行请求</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 类的作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 再探构造函数</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.5%20%E5%86%8D%E6%8E%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.5%20%E5%86%8D%E6%8E%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h2><h3 id="构造函数的初始值有时必不可少"><a href="#构造函数的初始值有时必不可少" class="headerlink" title="构造函数的初始值有时必不可少"></a>构造函数的初始值有时必不可少</h3><ul><li>如果<strong>成员是 const 或者 引用</strong>，则<strong>必须将其初始化</strong></li><li>必须<strong>通过构造函数初始值列表</strong>为成员提供初值，而<strong>不是通过赋值</strong></li></ul><h3 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h3><ul><li>构造函数初始化列表<strong>只说明用于初始化成员的值</strong>，而<strong>不限定初始化顺序</strong></li><li>成员<strong>初始化顺序与类定义中出现顺序一致</strong></li><li>当一个成员是用另一个成员初始化时，<strong>必须保持类中定义顺序与初始化列表顺序的一致</strong></li></ul><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><ul><li>如果一个构造函数为所有参数提供了默认实参，它实际上也定义了默认构造函数</li></ul><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><ul><li>delegating constructor: 一个委托构造函数使用它所属类的其他构造函数执行自己的初始化过程</li><li>委托构造函数也有成员初始值列表和函数体</li></ul><p>使用委托构造函数重写 Sale_data 类</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br><br>    ......<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 非委托构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>(std::string s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>            <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br><br>    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() : <span class="hljs-built_in">Sale_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s) : <span class="hljs-built_in">Sale_data</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::istream &amp;is) : <span class="hljs-built_in">Sale_data</span>() &#123; <span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>); &#125;<br><br>   ......<br><br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h2><p>默认初始化在下面情况发生：</p><ul><li>当在块作用域内不使用任何初始值定义一个非静态变量或数组时</li><li>当一个类本身含有类类型的成员且使用合成的默认构造函数时</li><li>当类类型的成员没有在构造函数初始值列表中显式地初始化时</li></ul><p>值初始化在以下情况发生：</p><ul><li>数组初始化过程中提供的初始值数量少于数组大小时</li><li>当不使用一个初始值定义局部静态变量时</li><li>当通过书写形如 T() 的表达式显式的请求初始化时(其中 T 是类型名)</li></ul><h2 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h2><ul><li>能通过一个实参调用的构造函数定义了一条<strong>从构造函数的参数类型</strong>向<strong>类类型</strong>隐式转换的规则</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::string null_book = <span class="hljs-string">&quot;9-9999-9999&quot;</span>;<br><span class="hljs-comment">// 构造一个临时的 Sale_data 对象</span><br><span class="hljs-comment">// 该对象成员 bookNo = null_book, units_sold 和 revenue 都等于 0</span><br>item.<span class="hljs-built_in">combine</span>(null_book);<br></code></pre></td></tr></table></figure><ul><li>这里使用 string 实参调用 Sale_data 的 combine 成员，编译器用给定的 string 自动创建了一个 Sale_data 对象，这个临时对象被传递给 combine</li><li>combine 的参数是 常量引用，所以可以给该参数传递一个临时量</li></ul><h3 id="只允许一步类型转换"><a href="#只允许一步类型转换" class="headerlink" title="只允许一步类型转换"></a>只允许一步类型转换</h3><ul><li>编译器只会自动地执行<strong>一步类型转换</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>);    <span class="hljs-comment">// 错误，编译器不会将&quot;9-9999-9999&quot;转换为 Sale_data对象</span><br></code></pre></td></tr></table></figure><ul><li>可以显式的将字符串转换成 string 或者 Sale_data 对象：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>));<br><br>item.<span class="hljs-built_in">combine</span>(<span class="hljs-built_in">Sale_data</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="通过-explicit-阻止隐式的类类型转换"><a href="#通过-explicit-阻止隐式的类类型转换" class="headerlink" title="通过 explicit 阻止隐式的类类型转换"></a>通过 explicit 阻止隐式的类类型转换</h3><ul><li>在构造函数声明时，可加入 <strong>explicit 关键字</strong>阻止隐式类类型转换</li><li>explicit 只对一个实参的构造函数有效</li><li>只能在<strong>类内声明构造函数</strong>时使用 <strong>explicit</strong></li><li>explicit 构造函数<strong>只能用于直接初始化</strong>，不能用于拷贝初始化(=)等</li></ul><h2 id="聚合类-aggregate-class"><a href="#聚合类-aggregate-class" class="headerlink" title="聚合类(aggregate class)"></a>聚合类(aggregate class)</h2><ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，没有 virtual 函数</li></ul><h2 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h2><ul><li>数据成员是字面值常量的聚合类是字面值常量类</li><li><p>如果不是聚合类，但符合以下要求，也是字面值常量类：</p><ul><li>数据成员必须是字面值类型</li><li>类必须至少含有机一个 constexpr 构造函数</li><li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式；或者如果成员属于某种类型，则初始值必须使用成员自己的 constexpr 构造函数</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象</li></ul></li></ul><h3 id="constexpr-构造函数"><a href="#constexpr-构造函数" class="headerlink" title="constexpr 构造函数"></a>constexpr 构造函数</h3><ul><li>构造函数不能是 const 的，但字面值常量类的构造函数可以是 constexpr 函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 类的静态成员</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.6%20%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.6%20%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>使用 <strong>static 关键字</strong>声明静态成员，可以是 public 的，也可以是 private 的。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">rate</span><span class="hljs-params">( <span class="hljs-type">double</span> )</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::string owner;<br>    <span class="hljs-type">double</span> amount;<br>    <span class="hljs-type">static</span> <span class="hljs-type">double</span> interestRate;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>static 成员存在于任何对象之外，对象中不包含与静态成员有关的任何数据</li><li>静态成员函数不和任何对象绑定在一起，不包含 this 指针</li><li><strong>静态成员不能被声明为 const</strong>， 在 <strong>static 函数体内不能使用 this 指针</strong></li></ul><h2 id="使用静态成员"><a href="#使用静态成员" class="headerlink" title="使用静态成员"></a>使用静态成员</h2><ul><li>使用<strong>作用域运算符</strong>直接访问静态成员</li><li>使用类的对象、引用或指针访问静态成员</li><li>成员函数不用通过作用域运算符就可直接使用静态成员</li></ul><h2 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h2><ul><li>既可以在类内部定义，也可以在类外部定义</li><li>在外部定义时，<strong>不能重复使用</strong> static 关键字；和其他成员一样，必须<strong>指明成员所属类名</strong></li><li><strong>不能在类内部初始化静态成员</strong>，一般必须在类外部定义和初始化静态成员</li><li>类似全局变量，静态成员一旦被定义，就一致<strong>存在于程序的整个生命周期</strong></li><li><p>定义静态成员需要指定对象的类型名，然后是类名、作用域运算符、成员自己的名字</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义并初始化一个静态成员</span><br><span class="hljs-type">double</span> Account::interestRate = <span class="hljs-built_in">initRate</span>();<br></code></pre></td></tr></table></figure></li></ul><h2 id="静态成员类内初始化"><a href="#静态成员类内初始化" class="headerlink" title="静态成员类内初始化"></a>静态成员类内初始化</h2><ul><li>一般静态成员不在类内初始化，但是可以为静态成员提供 <strong>const 整数类型</strong>的类内初始值，要求静态成员必须是字面值常量类型的 constexpr。初始值必须是常量表达式。</li></ul><h2 id="静态成员可用于特殊场景"><a href="#静态成员可用于特殊场景" class="headerlink" title="静态成员可用于特殊场景"></a>静态成员可用于特殊场景</h2><ul><li>静态成员可以是<strong>不完全类型</strong></li><li><p>静态成员的类型可以就是它所属的类类型</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Bar mem1; <br>    Bar *mem2;<br>    Bar mem3;       <span class="hljs-comment">// 错误：数据成员必须是完全类型</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>可以使用<strong>静态成员作为默认实参</strong>，而非静态成员不行</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">clear</span><span class="hljs-params">( <span class="hljs-type">char</span> = bkground)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> bkground;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 静态成员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 访问控制与封装</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.2%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.2%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>使用 <strong>访问说明符(access specifiers)</strong>加强类的封装：</p><ul><li><strong>public</strong>: public 成员在<strong>整个程序内可访问</strong>，public 成员定义类的接口</li><li><strong>private</strong>: private 成员可以被<strong>类的成员函数访问</strong>，但<strong>不能被使用该类的代码访问</strong>，private 部分封装了类的实现细节</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span> (std::istream &amp;);<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> units_sold ? revenue / units_sold : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>struct</strong> 定义类：在第一个访问说明符之前的成员是 <strong>public</strong></li><li><strong>class</strong> 定义了：在第一个访问说明符之前的成员是 <strong>private</strong></li></ul><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>类允许其他类或函数访问非公有成员的方法是<strong>友元(friend)</strong>, 使用 <strong>friend</strong> 关键字可将函数或类声明为<strong>友元</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 为 Sale_data 的非成员函数做友元声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span> (std::istream &amp;);<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> units_sold ? revenue / units_sold : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br><br><span class="hljs-comment">// Sale_data 的非成员接口函数</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>一般在类定义开始或结束时定义友元</li><li>友元函数的声明<strong>不是</strong>通常意义的<strong>函数声明</strong>，在进行友元声明之后<strong>需对函数进行一次专门的声明</strong></li></ul><h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><ul><li>确保用户代码不会无意间破坏封装对象的状态</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级代码<ul><li>只要类的接口，用户代码就无需改变</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 封装 </tag>
            
            <tag> 访问控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog</title>
      <link href="/2025/03/20/My-first-blog/"/>
      <url>/2025/03/20/My-first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="This-is-my-first-blog"><a href="#This-is-my-first-blog" class="headerlink" title="This is my first blog"></a>This is my first blog</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1 定义抽象数据类型</title>
      <link href="/2025/03/20/7.%20%E7%B1%BB/7.1%20%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/03/20/7.%20%E7%B1%BB/7.1%20%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Sale-item-class"><a href="#Sale-item-class" class="headerlink" title="Sale_item class"></a>Sale_item class</h2><p>Sale_item class 的作用是表示一本书的总销售额、售出册数、平均售价</p><h2 id="设计-Sale-data-class"><a href="#设计-Sale-data-class" class="headerlink" title="设计 Sale_data class"></a>设计 Sale_data class</h2><ol><li><p>Sale_data 的接口应该包含以下操作：</p><ul><li><strong>isbn 成员函数</strong>，返回对象的 ISBN 编号</li><li><strong>combine 成员函数</strong>，将一个 Sale_data 对象加到另一个对象上</li><li><strong>add 函数</strong>，执行两个 Sale_data 对象的加法</li><li><strong>read 函数</strong>，将数据从 istream 读入到 Sale_data 对象中</li><li><strong>print 函数</strong>，将 Sale_data 对象的值输出到 ostream</li></ul></li><li><p>Sale_data class 数据成员</p><ul><li><strong>bookNo</strong>———string 类型：表示 ISBN 编号</li><li><strong>units_sold</strong>——-unsigned 类型：表示某本书的销量</li><li><strong>revenue</strong>———double 类型：表示这本书的总销售收入</li><li><strong>avg_price 成员函数</strong>，返回售出书籍的平均价格</li></ul></li></ol><ul><li>成员函数声明必须在 class 内部，定义可以在外部，也可以在内部</li><li>非成员函数声明与定义都在 class 外部</li><li>定义在 class 内部的函数是隐式 inline 函数</li></ul><h2 id="Sale-data-class-声明与定义"><a href="#Sale-data-class-声明与定义" class="headerlink" title="Sale_data class 声明与定义"></a>Sale_data class 声明与定义</h2><h3 id="Sale-data-h"><a href="#Sale-data-h" class="headerlink" title="Sale_data.h"></a>Sale_data.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br><br><span class="hljs-comment">// Sale_data 的非成员接口函数</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="解读std-string-isbn-const-return-bookNo"><a href="#解读std-string-isbn-const-return-bookNo" class="headerlink" title="解读std::string isbn() const { return bookNo; }"></a>解读<code>std::string isbn() const &#123; return bookNo; &#125;</code></h3><ul><li><p><strong>this 隐式形参</strong>：</p><ul><li><code>std::string isbn() const &#123; return bookNo; &#125;</code> 等价于 <code>std::string isbn() const &#123; return this.bookNo; &#125;</code>，当一个 Sale_data 对象调用 isbn() 时，编译器将<strong>这个对象的地址</strong>传递给 isbn() 的<strong>隐式形参 this</strong>，相当于 <code>this-&gt;bookNo</code>，所以这条语句中可以直接使用 <code>return bookNo</code></li><li>this 是一个<strong>常量指针</strong>，不允许改变 this 中保存的地址</li></ul></li><li><p><strong>const 成员函数</strong></p><ul><li>在这里使用 const 成员函数的考虑是：无论 <strong>Sale_data 是常量对象</strong>还是<strong>非常量对象</strong>，<strong>都可以调用</strong> isbn()，提高 isbn() 成员函数的灵活性</li><li>一般情况，this 是一个指向<strong>类类型非常量版本</strong>的<strong>常量</strong>指针，为了使 isbn() 只能读取调用它的对象的 data member, 而不能写入新值，就需要改变 this 这个隐式形参类型，使其成为<strong>指向常量对象</strong>的<strong>常量指针</strong>。这种<strong>指向常量对象的常量指针</strong>，也<strong>允许</strong>它指向<strong>非常量对象</strong></li><li>紧随参数列表之后的 const 表示 this 是一个指向常量对象的常量指针。像这种使用 const 的成员函数称为<strong>常量成员函数(const member function)</strong></li><li><strong>NOTE:</strong> 常量对象，常量对象的引用或指针，都只能调用常量成员函数</li></ul></li></ul><h3 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h3><ul><li>在 class 外部定义成员函数，<strong>必须与 class 内部的声明保持一致</strong></li><li><p>class 外部定义的成员的名字<strong>必须包含它所属的类名</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sale_data::avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">if</span> (units_sold)<br>    <span class="hljs-keyword">return</span> revenue / units_sold;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="定义返回-this-对象的函数"><a href="#定义返回-this-对象的函数" class="headerlink" title="定义返回 this 对象的函数"></a>定义返回 this 对象的函数</h3><ul><li><p>函数 combine 的设计类似复合赋值运算符 <strong>+=</strong>, 内置赋值运算符把它<strong>左侧运算对象当成左值返回</strong>，combine 函数也应模仿此操作，返回调用 combine() 的 Sale_data 对象的引用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Sale_data &amp; <span class="hljs-title">Sale_data::combine</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp; rhs)</span> </span>&#123;<br>    units_sold += rhs.units_sold;<br>    revenue += rhs.revenue;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;       <span class="hljs-comment">// 返回调用该函数的对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><ul><li>一般的，如果非成员函数是类接口的组成部分，则这些函数的<strong>声明应与类在同一个头文件中</strong></li><li><p>IO 类是<strong>不能被拷贝</strong>的类型，只能通过<strong>引用传递</strong>；读取和写入会<strong>改变 IO 流的内容</strong>，因此函数接受 IO 的<strong>普通引用</strong>，而不是对常量的引用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输入交易信息包括 ISBN, 售出总数，售出价格</span><br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp; is, Sale_data &amp; item)</span> </span>&#123;<br>    <span class="hljs-type">double</span> price = <span class="hljs-number">0</span>;<br>    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>    item.revenue = price * item.units_sold;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp; os, <span class="hljs-type">const</span> Sale_data &amp; item)</span> </span>&#123;<br>    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>        &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-built_in">avg_price</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// 接受两个 Sale_data 对象，返回一个新的 Sale_data 对象，用于表示两个对象的和</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;lhs, <span class="hljs-type">const</span> Sale_data &amp;rhs)</span> </span>&#123;<br>    Sale_data sum = lhs;<br>    sum.<span class="hljs-built_in">combine</span>(rhs);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>构造函数名字<strong>与类名相同</strong></li><li>构造函数<strong>没有返回类型</strong></li><li>构造函数有参数列表（可能为空）和函数体（可能为空）</li><li>构造函数<strong>不能被声明为 const</strong></li><li>若没有显示的定义构造函数，编译器会隐式的定义一个<strong>默认构造函数(default constructor)</strong></li><li>合成的 default constructor 只适用于非常简单的类<ul><li>只有当类<strong>没有声明任何构造函数</strong>时，编译器才会自动生成 default constructor</li><li>如果类内包含内置类型或复合类型（数组、指针等），只有当这些成员全部被赋予类内初始值时，这个类才适用于合成的默认构造函数</li><li>如果类内包含其他类类型成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员</li></ul></li></ul><h3 id="定义-Sale-data-的构造函数"><a href="#定义-Sale-data-的构造函数" class="headerlink" title="定义 Sale_data 的构造函数"></a>定义 Sale_data 的构造函数</h3><ul><li>constructor1: istream &amp;, 从中读取一条交易信息</li><li>constructor2: const string &amp;, 表示 ISBN 编号；unsigned， 表示售出图书数量；double, 表示图书的售出价格</li><li>constructor3: const string &amp;, 表示 ISBN 编号；其他成员由编译器赋予默认值</li><li>constructor4: 空参数列表（default constructor）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::istream &amp; );<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>= default</strong>: 让编译器自动生成构造函数</li><li><strong>构造函数初始值列表(constructor initialize list)</strong>： “:”之后 “{}” 之前的部分。作用是接受参数列表的内容，赋值给相应成员，未被赋值的成员由编译器赋默认值</li></ul><h3 id="类外部定义构造函数"><a href="#类外部定义构造函数" class="headerlink" title="类外部定义构造函数"></a>类外部定义构造函数</h3><ul><li><p>与其他函数一样，必须指明这个构造函数是哪个类的成员</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 接受 istream &amp; 的构造函数</span><br>Sale_data::<span class="hljs-built_in">Sale_data</span>(std::istream &amp; is) &#123;<br>    <span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个函数没有 constructor initialize list，所以在调用它时，类内成员将通过类内值初始化或执行默认初始化</p></li><li>read() 的第二个参数是 Sale_data 对象的引用，使用 *this 将 “this”对象作为实参传递给 read 函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 定义抽象数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/20/hello-world/"/>
      <url>/2025/03/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
