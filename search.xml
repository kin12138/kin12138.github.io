<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>9.4 vector 对象如何增长</title>
      <link href="/2025/03/29/9.4%20vector%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E9%95%BF/"/>
      <url>/2025/03/29/9.4%20vector%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="减少容器空间重新分配的策略"><a href="#减少容器空间重新分配的策略" class="headerlink" title="减少容器空间重新分配的策略"></a>减少容器空间重新分配的策略</h2><ul><li><strong>vector 和 string</strong> 在内存中是<strong>连续保存</strong>的，如果原先分配的内存已经用完，则会重新分配内存空间，将已有元素从旧空间移动到新空间，然后添加新元素</li><li>当不得不获取新的内存空间时，<strong>vector</strong> 和 <strong>string</strong> 通常<strong>分配比新的空间需求更大的内存空间</strong>，作为备用</li></ul><h2 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h2><div class="table-container"><table><thead><tr><th>Operating</th><th>Description</th></tr></thead><tbody><tr><td>c.shrink_to_fit()</td><td>将 capacity() 减少为与 size() 相同大小</td></tr><tr><td>c.capacity()</td><td>不重新分配内存空间，c 可以保存多少元素</td></tr><tr><td>c.reserve(n)</td><td>分配至少能容纳 n 个元素的内存空间</td></tr></tbody></table></div><ul><li><strong>shrink_to_fit()</strong> 只适用于 <strong>vector, string，deque</strong></li><li><strong>capacity</strong>：容器在<strong>不扩张内存空间</strong>的情况下<strong>可以容纳的元素数</strong></li><li><strong>reserve</strong>：告诉容器<strong>分配至少保存</strong>多少元素的<strong>内存空间</strong></li><li><strong>capacity</strong>，<strong>reserve</strong> 都只适用于 <strong>vector</strong>， <strong>string</strong></li></ul><h2 id="reserve、-resize-辨析"><a href="#reserve、-resize-辨析" class="headerlink" title="reserve、 resize 辨析"></a>reserve、 resize 辨析</h2><ul><li>reserve 不改变容器中元素的数量，仅影响 vector 预先分配多大的内存空间</li><li>只有当<strong>需要的内存空间超过当前容量</strong>时，调用 <strong>reserve</strong> 才会<strong>改变 vector 的容量</strong>；若<strong>不超过</strong>， reserve 什么也不做。</li><li><strong>resize</strong> <strong>只改变</strong>容器中<strong>元素数量</strong>，<strong>不改变容量大小</strong></li></ul><h2 id="capacity、size-辨析"><a href="#capacity、size-辨析" class="headerlink" title="capacity、size 辨析"></a>capacity、size 辨析</h2><ul><li>capacity 是容器在不重新分配内存的情况下最多能保存元素的数量</li><li>size 是指容器已经保存的元素数量</li><li>size 永远不可能大于 capacity</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> vector 增长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.5 额外的 string 操作</title>
      <link href="/2025/03/29/9.5%20%E9%A2%9D%E5%A4%96%E7%9A%84%20string%20%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/29/9.5%20%E9%A2%9D%E5%A4%96%E7%9A%84%20string%20%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="构造-string-的其他方法"><a href="#构造-string-的其他方法" class="headerlink" title="构造 string 的其他方法"></a>构造 string 的其他方法</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>string s(cp, n)</td><td>s 是 <strong>cp 指向的数组</strong>中前 n 个字符的拷贝。<br> 此<strong>数组至少包含 n 个字符</strong></td></tr><tr><td>string s(s2, pos2)</td><td>s 是 s2 从下标 pos2 开始的字符的拷贝。<br> 如果 pos2 &gt; s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2, pos2, len2)</td><td>s 是 s2 从下标 pos2 开始的 len2 个元素的拷贝。<br> 若 pos2 &gt; s2.size()，构造函数行为未定义 <br> 不管 len2 的值是多少，构造函数<strong>至多拷贝 s2.size() - pos2 个元素</strong></td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testStringConstructor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * cp = <span class="hljs-string">&quot;Hello World!!&quot;</span>;      <span class="hljs-comment">// 以空字符结束的数组</span><br>    <span class="hljs-type">char</span> noNull[] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>&#125;;     <span class="hljs-comment">// 不是以空字符结束</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s1</span><span class="hljs-params">(cp)</span></span>;                 <span class="hljs-comment">// 拷贝 cp 中的字符直到遇到空字符；s1 == &quot;Hello World!!&quot;</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s2</span><span class="hljs-params">(noNull, <span class="hljs-number">2</span>)</span></span>;        <span class="hljs-comment">// 从 noNull 拷贝两个字符;s2 == &quot;Hi&quot;</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s3</span><span class="hljs-params">(noNull)</span></span>;             <span class="hljs-comment">// 未定义行为。noNull 不是以空字符结尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s4</span><span class="hljs-params">(cp + <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span></span>;        <span class="hljs-comment">// 从 cp[6] 开始拷贝 5 个字符。</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s5</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 在 s1[6] 开始拷贝 5 个字符</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s6</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>)</span></span>;          <span class="hljs-comment">// 从 s1[6] 开始拷贝，直到 s1 末尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s7</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>, <span class="hljs-number">20</span>)</span></span>;  <span class="hljs-comment">// 从 s1[6] 开始拷贝，直到 s1 末尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s8</span><span class="hljs-params">(s1, <span class="hljs-number">18</span>)</span></span>;         <span class="hljs-comment">// 抛出 out_of_range 异常</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当从一个 <code>const char *</code> <strong>创建 string</strong> 时，指针指向的<strong>数组必须以空字符结尾</strong>，<strong>拷贝操作遇到空字符停止</strong></li><li>但如果还<strong>传递给构造函数一个计数值</strong>，则数组不必以空字符结尾。</li><li>若未传递计数值也未以空字符结尾，或传递的计数值大于数组大小，构造函数行为未定义</li></ul><h3 id="substr-操作"><a href="#substr-操作" class="headerlink" title="substr 操作"></a>substr 操作</h3><ul><li>substr 返回一个 string</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>s.substr(pos, n)</td><td>返回 string，包含 s 中<strong>从 pos 开始的 n 个字符的拷贝</strong>。<br> pos 默认值是 0，n 的默认值是 s.size() - pos, 即拷贝从 pos 开始的所有字符</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testSubstr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello world&quot;</span>)</span></span>;<br>    std::string s1 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// s1 = Hello</span><br>    std::string s2 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>);              <span class="hljs-comment">// s2 = world</span><br>    std::string s3 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>);       <span class="hljs-comment">// s3 = world</span><br>    std::string s4 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">12</span>);             <span class="hljs-comment">// 抛出 out_of_range 异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="改变-string-的其他方法"><a href="#改变-string-的其他方法" class="headerlink" title="改变 string 的其他方法"></a>改变 string 的其他方法</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>args 形式</th><th>Description</th></tr></thead><tbody><tr><td>s.insert(pos, args)</td><td>str <br> str, pos2, len <br> cp, len <br> n, c</td><td>在 <strong>下标 pos 前插入</strong> args 指定的字符。<br> <strong>返回指向 s 的引用</strong></td></tr><tr><td>s.insert(iter, args)</td><td>n, c <br> b2, e2 <br> 初始化列表</td><td>在<strong>迭代器 iter 前</strong>插入 args 指定字符。 <br> <strong>返回指向第一个插入字符的迭代器</strong></td></tr><tr><td>s.erase(pos, len)</td><td></td><td><strong>删除从位置 pos 开始的 len 个字符</strong>。<br> 如果 len 被省略，则删除从 pos 开始直到 s 末尾的所有字符。<br> <strong>返回指向 s 的引用</strong></td></tr><tr><td>s.assign(args)</td><td>str <br> str, pos, len <br> cp, len <br> cp <br> n,c <br> b,e <br> 初始化列表</td><td>将 <strong>s 中的字符替换为 args 指定的字符</strong>。<br> 返回一个指向 s 的引用</td></tr><tr><td>s.append(args)</td><td>str <br> str,pos,len <br> cp,len <br> cp <br> n,c <br> b, e <br> 初始化列表</td><td>将 <strong>args 追加到 s</strong>。返回指向 s 的引用</td></tr><tr><td>s.replace(pos, len, args)</td><td>str <br> str, pos2, len2 <br> cp, len <br> cp <br> n, c</td><td>删除 s 中<strong>从下标 pos 开始的 len 个字符</strong>，替换为 args 指定的字符。<br> <strong>返回指向 s 的引用</strong>。</td></tr><tr><td>s.replace(b, e, args)</td><td>str <br> cp, len <br> cp <br> n, c <br> b2, e2 <br> 初始化列表</td><td>删除 s 中<strong>迭代器 b, e 指定范围的字符</strong>，替换为 args 指定的字符。<br> <strong>返回指向 s 的引用</strong></td></tr></tbody></table></div><ul><li>上表中的 args 可以是下列形式之一；</li><li>append 和 assign 可以使用所有形式</li></ul><div class="table-container"><table><thead><tr><th>Form</th><th>Description</th></tr></thead><tbody><tr><td>str</td><td>字符串 str</td></tr><tr><td>str, pos, len</td><td>str 中从 pos 开始最多 len 个字符</td></tr><tr><td>cp, len</td><td>cp 指向的字符数组的前(最多) len 个字符</td></tr><tr><td>cp</td><td>cp 指向的以空字符结尾的字符数组</td></tr><tr><td>n, c</td><td>n 个 字符 c</td></tr><tr><td>b, e</td><td>迭代器 b, e 指定范围内的字符</td></tr><tr><td>初始化列表</td><td>{} 包围的，以 “,” 分隔的字符列表</td></tr></tbody></table></div><ul><li>str 不能和 s 相同</li><li>迭代器 b,e 不能指向 s</li><li><strong>replace</strong> 和 <strong>insert</strong> 所允许的 args 形式<strong>依赖于 range 和 pos 如何指定</strong></li></ul><div class="table-container"><table><thead><tr><th>replace</th><th>replace</th><th>insert</th><th>insert</th><th>args 可以是</th></tr></thead><tbody><tr><td>(pos, len, args)</td><td>(b, e, args)</td><td>(pos, args)</td><td>(iter, args)</td><td></td></tr><tr><td>是</td><td>是</td><td>是</td><td>否</td><td>str</td></tr><tr><td>是</td><td>否</td><td>是</td><td>否</td><td>str, pos, len</td></tr><tr><td>是</td><td>是</td><td>是</td><td>否</td><td>cp, len</td></tr><tr><td>是</td><td>是</td><td>否</td><td>否</td><td>cp</td></tr><tr><td>是</td><td>是</td><td>是</td><td>是</td><td>n, c</td></tr><tr><td>否</td><td>是</td><td>否</td><td>是</td><td>b2, e2</td></tr><tr><td>否</td><td>是</td><td>否</td><td>是</td><td>初始化列表</td></tr></tbody></table></div><h3 id="接受下标版本的-insert-和-erase"><a href="#接受下标版本的-insert-和-erase" class="headerlink" title="接受下标版本的 insert 和 erase"></a>接受下标版本的 insert 和 erase</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;!&#x27;</span>);     <span class="hljs-comment">// 在 s 的末尾添加 5 个 ！</span><br>s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);       <span class="hljs-comment">// 从 s 中删除最后五个字符</span><br></code></pre></td></tr></table></figure><h3 id="接受-c-风格字符数组的-insert-和-assign"><a href="#接受-c-风格字符数组的-insert-和-assign" class="headerlink" title="接受 c 风格字符数组的 insert 和 assign"></a>接受 c 风格字符数组的 insert 和 assign</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * cp = <span class="hljs-string">&quot;Stately, plump Buck&quot;</span>;<br>s.<span class="hljs-built_in">assign</span>(cp, <span class="hljs-number">7</span>);        <span class="hljs-comment">// s == &quot;Stately&quot;</span><br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">size</span>(), cp<span class="hljs-number">+7</span>);   <span class="hljs-comment">// s == &quot;Stately, plump Buck&quot;</span><br></code></pre></td></tr></table></figure><ul><li>调用 assign，用 cp 指向的地址开始的 7 个字符替换 s 中的内容</li><li>调用 insert，在 s 的结尾(<em>s[size()] 这个不存在的位置</em>) 插入 cp 指向的数组下从 7 开始直到结尾空字符之前字符的拷贝</li></ul><h3 id="指定其他-string-或子字符串的字符插入当前-string-或赋予当前-string"><a href="#指定其他-string-或子字符串的字符插入当前-string-或赋予当前-string" class="headerlink" title="指定其他 string 或子字符串的字符插入当前 string 或赋予当前 string"></a>指定其他 string 或子字符串的字符插入当前 string 或赋予当前 string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;some string&quot;</span>, s2 = <span class="hljs-string">&quot;some other string&quot;</span>;<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, s2);        <span class="hljs-comment">// 在 s 的 下标 0 之前插入 s2 的拷贝</span><br><span class="hljs-comment">// 在 s[0] 之前插入 s2 中从下标 0 开始的 s2.size() 个字符</span><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, s2, <span class="hljs-number">0</span>, s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>());<br></code></pre></td></tr></table></figure><h3 id="append-和-replace-函数"><a href="#append-和-replace-函数" class="headerlink" title="append 和 replace 函数"></a>append 和 replace 函数</h3><ul><li>append 是在 string 末尾进行插入操作</li><li>replace 是 调用 erase 和 insert 的一种简写</li><li>调用 <strong>replace</strong> 时，<strong>插入文本可以与删除文本长度不同</strong></li></ul><h3 id="改变-string-的多种重载函数"><a href="#改变-string-的多种重载函数" class="headerlink" title="改变 string 的多种重载函数"></a>改变 string 的多种重载函数</h3><ul><li><p><strong>assign 和 append 函数 无需指定要替换 string 中哪个部分</strong>：</p><ul><li>assign 总是替换 string 中的所有内容</li><li>append 总是将新字符添加到 string 末尾</li></ul></li><li><p><strong>replace</strong> 提供<strong>两种指定删除元素范围的方式</strong>：</p><ul><li>通过一个位置和一个长度指定范围</li><li>通过一个迭代器范围来指定</li></ul></li><li><p><strong>insert</strong> 提供<strong>两种方式指定插入点</strong>：</p><ul><li>一个下标</li><li>一个迭代器</li><li><strong>新元素都会插入到给定下标或迭代器之前的位置</strong></li></ul></li><li><p>多种方式指定要添加到 string 中的字符：</p><ul><li>新字符可以来自另一个 string</li><li>可以来自字符指针（指向的字符数组）</li><li>可以来自花括号包围的字符列表</li><li>或是一个字符和一个计数值</li><li>当新字符<strong>来自另一个 string 或 字符数组</strong>时，可以<strong>传递一个额外参数来控制是拷贝部分还是全部</strong></li></ul></li></ul><h2 id="string-的搜索操作"><a href="#string-的搜索操作" class="headerlink" title="string 的搜索操作"></a>string 的搜索操作</h2><ul><li>string 提供 6 个不同的搜索函数，每个搜索函数有 4 个重载版本</li><li>每个搜索操作都返回一个 string::size_type 值，表示匹配发生位置下标</li><li>搜索失败，返回一个 string::npos 的 static 成员。npos 是 const string::size_type 类型，初始化值为 -1。</li></ul><div class="table-container"><table><thead><tr><th>Search Operation</th><th>Description</th></tr></thead><tbody><tr><td>s.find(args)</td><td>查找 s 中 <strong>args 第一次出现</strong>的位置</td></tr><tr><td>s.rfind(args)</td><td>查找 s 中 <strong>args 最后一次出现</strong>的位置</td></tr><tr><td>s.find_first_of(args)</td><td>在 s 中查找 <strong>args 中任何一个字符第一次出现</strong>的位置</td></tr><tr><td>s.find_last_of(arsg)</td><td>在 s 中查找 <strong>args 中任何一个字符最后一次出现</strong>的位置</td></tr><tr><td>s.find_first_not_of(args)</td><td>在 s 中查找<strong>第一个不在 args 中</strong>的字符</td></tr><tr><td>s.find_last_not_of(args)</td><td>在 s 中查找<strong>最后一个不在 args 中</strong>的字符</td></tr></tbody></table></div><ul><li>args 必须是以下形式</li></ul><div class="table-container"><table><thead><tr><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>c, pos</td><td>从 s 中位置 pos 开始查找字符 c 。<br> pos 默认为 0</td></tr><tr><td>s2, pos</td><td>从 s 中位置 pos 开始查找字符串 s2 。<br> pos 默认为 0</td></tr><tr><td>cp, pos</td><td>从 s 中位置 pos  开始查找 cp 指向的以空字符结尾的 C 风格字符串。<br> pos 默认为 0</td></tr><tr><td>cp, pos, n</td><td>从 s 中位置 pos 开始查找 cp 指向的数组的前 n 个字符。<br> pos 和 n 无默认值</td></tr></tbody></table></div><h3 id="指定在哪里搜索"><a href="#指定在哪里搜索" class="headerlink" title="指定在哪里搜索"></a>指定在哪里搜索</h3><ul><li><p>循环搜索子字符串出现的所有位置</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_substring_pos</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;dfadafdasfd343245232t434543254545435132343476y 55243eq6tr6&quot;</span>)</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">number</span><span class="hljs-params">(<span class="hljs-string">&quot;34&quot;</span>)</span></span>;<br>    std::string::size_type pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((pos = name.<span class="hljs-built_in">find_first_of</span>(number, pos)) != std::string::npos) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;find number at index: &quot;</span> &lt;&lt; pos <br>                      &lt;&lt; <span class="hljs-string">&quot;, element is &quot;</span> &lt;&lt; name[pos] &lt;&lt; std::endl;<br>            ++pos;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ul><li>如果一个字母延伸到中线之上，如d或f，则称其有上出头部分（ascender）。如果一个字母延伸到中线之下，如p或g，则称其有下出头部分（descender）。编写程序，读入一个单词文件，输出最长的既不包含上出头部分，也不包含下出头部分的单词。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkMax</span><span class="hljs-params">(std::string &amp; currWord, std::string &amp; maxWord)</span></span>&#123;<br>    maxWord = currWord.<span class="hljs-built_in">size</span>() &gt; maxWord.<span class="hljs-built_in">size</span>() ? currWord : maxWord;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkWord</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; word)</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">target</span><span class="hljs-params">(<span class="hljs-string">&quot;acemnorsuvwxz&quot;</span>)</span></span>;<br>    std::string::size_type pos = word.<span class="hljs-built_in">find_first_not_of</span>(target);<br>    <span class="hljs-keyword">return</span> pos == std::string::npos;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_longest_noAscender_noDescender</span><span class="hljs-params">(std::ifstream &amp; ifs)</span> </span>&#123;<br>    std::string maxWord, currWord;<br>    <span class="hljs-keyword">while</span> (ifs &gt;&gt; currWord) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkWord</span>(currWord))<br>            <span class="hljs-built_in">checkMax</span>(currWord, maxWord);<br>    &#125;<br>    std::cout &lt;&lt; maxWord &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-type">void</span> _9_49() &#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;../Resource/letter.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span>(!ifs) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">find_longest_noAscender_noDescender</span>(ifs);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="compare-函数"><a href="#compare-函数" class="headerlink" title="compare 函数"></a>compare 函数</h2><ul><li>除关系运算符外，标准库 string 提供 compare 函数</li><li>s.compare 根据 s 是大于、小于、等于参数给定的字符串，返回 正数、负数、零</li><li>compare 有 6 个版本</li></ul><div class="table-container"><table><thead><tr><th>Compare Arguments</th><th>Description</th></tr></thead><tbody><tr><td>s2</td><td>比较 s 和 s2</td></tr><tr><td>pos1, n1, s2</td><td>将 s 中从 pos1 开始的 n1 个字符与 s2 比较</td></tr><tr><td>pos1, n1, s2, pos2, n2</td><td>将 <strong>s 中从 pos1 开始的 n1 个字符</strong>，与 <strong>s2 中 pos2 开始的 n2个字符</strong>进行比较</td></tr><tr><td>cp</td><td>比较 s 与 cp 指向的以空字符结尾的字符数组</td></tr><tr><td>pos1, n1, cp</td><td>将 s 中从 pos1 开始的 n1 个字符，与 cp 指向的以空字符结尾的字符数组进行比较</td></tr><tr><td>pos1, n1, cp, n2</td><td>将 s 中从 pos1 开始的 n1 个字符，与 cp 指向的字符数组中前 n2 个字符进行比较</td></tr></tbody></table></div><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><div class="table-container"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td>to_string(val)</td><td>一组重载函数，返回 val 的 string 表示。<br> val 可以是任何算数类型。<br> 对每个浮点类型和 int 或更大的整型，都有相应版本的 to_string()</td></tr><tr><td>stoi(s, p, b) <br> stol(s, p, b) <br> stoul(s, p, b) <br> stoll(s, p, b) <br> stoull(s, p, b)</td><td><strong>返回</strong> s 的起始字符串（表示<strong>整数</strong>内容）的<strong>数值</strong>，返回类型分别是 int, long, unsigned long, long long, unsigned long long。<br> <strong>b 表示转换所用基数</strong>，<strong>默认值为 10</strong> <br> <strong>p 是 size_t 指针</strong>，用来<strong>保存 s 中第一个非数值字符的下标</strong>，p 默认是 0，即函数不保存下标</td></tr><tr><td>stof(s, p) <br> stod(s, p) <br> stold(s, p)</td><td><strong>返回</strong> s 的起始字符串（表示<strong>浮点数</strong>内容）的<strong>数值</strong>，返回类型分别是 float, double, long double。<br> <strong>p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标</strong>，默认 是 0，即函数不保存下标</td></tr></tbody></table></div><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testChangeNumber</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>    std::string s = std::<span class="hljs-built_in">to_string</span>(i);<br>    <span class="hljs-type">double</span> d = std::<span class="hljs-built_in">stod</span>(s);<br><br>    std::string s2 = <span class="hljs-string">&quot;pi = 3.14&quot;</span>;<br>    <span class="hljs-comment">// 转换 s2 中以数字开始的第一个子串</span><br>    d = std::<span class="hljs-built_in">stod</span>(s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;+-.0123456789&quot;</span>)));     <span class="hljs-comment">// d = 3.14</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>string 中<strong>第一个非空白符</strong>必须是<strong>符号(+ 或 -)</strong> 或 <strong>数字</strong></li><li>string 可以以 <strong>0x</strong> 或 <strong>0X</strong> 开头来<strong>表示十六进制数</strong></li><li>字符串<strong>转为浮点数</strong>的函数，string 参数也<strong>可以以 (</strong>.<strong>) 开头</strong>, 并<strong>可以包含 e 或 E 来表示指数部分</strong></li><li>字符串转为<strong>整型值</strong>的函数，根据<strong>基数不同</strong>，<strong>string 参数可以包含字母字符</strong></li><li>若 string 不能转为一个数值，函数抛出 invalid_argument 异常。</li><li>如果转换后的数值无法用任何类型来表示，则抛出 out_of_range 异常</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>题目： 设计一个类，它有三个unsigned成员，分别表示年、月和日。为其编写构造函数，接受一个表示日期的string参数。你的构造函数应该能处理不同的数据格式，如January 1,1900、1/1/1990、Jan 1 1900 等。</p><ul><li><p>Date 类实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数接受表示日期的 string 参数</span><br>    <span class="hljs-comment">// 可以处理如 January 1, 1990、1/1/1990、Jan 1 1990 等不同数据格式</span><br>    <span class="hljs-built_in">Date</span>(std::string &amp; date);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">monthCovert</span><span class="hljs-params">(std::string &amp; s)</span></span>;<br>    <span class="hljs-type">unsigned</span> _year;<br>    <span class="hljs-type">unsigned</span> _month;<br>    <span class="hljs-type">unsigned</span> _day;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>构造函数实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Date::<span class="hljs-built_in">Date</span>(std::string &amp;date) &#123;<br>    <span class="hljs-type">unsigned</span> format = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) != std::string::npos)<br>        format = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) != std::string::npos)&#123;<br>        format = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) == std::string::npos &amp;&amp; date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) == std::string::npos) &#123;<br>        format = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (format) &#123;<br>        <span class="hljs-comment">// 1/1/1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        &#123;<br>            _month = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>)));<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// January 1, 1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        &#123;<br>            <span class="hljs-keyword">auto</span> month = date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>            _month = <span class="hljs-built_in">monthCovert</span>(month);<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>( date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;123456789&quot;</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>)), <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// Jan 1 1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        &#123;<br>            <span class="hljs-keyword">auto</span> month = date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>            _month = <span class="hljs-built_in">monthCovert</span>(month);<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>monthCovert 私有成员实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">Date::monthCovert</span><span class="hljs-params">(std::string &amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jan&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Feb&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Mar&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Apr&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;May&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jun&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jul&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Aug&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Sep&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Oct&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Nov&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Dec&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>print 成员实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::print</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;year: &quot;</span> &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>            &lt;&lt; <span class="hljs-string">&quot;month: &quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>            &lt;&lt; <span class="hljs-string">&quot;day: &quot;</span> &lt;&lt; _day &lt;&lt; std::endl;<br>    std::cout &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot; 年 &quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot; 月 &quot;</span> &lt;&lt; _day &lt;&lt; <span class="hljs-string">&quot; 日&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试函数</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str;<br>    std::<span class="hljs-built_in">getline</span>(std::cin, str);<br>    <span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(str)</span></span>;<br>    date.<span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> string 操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.2 文件输入输出流</title>
      <link href="/2025/03/28/8.2%20%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
      <url>/2025/03/28/8.2%20%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h2><ul><li><p>头文件：fstream.h</p></li><li><p>类型：</p><ul><li>ifstream</li><li>ofstream</li><li>fstream</li></ul></li></ul><hr><h2 id="fstream-特有操作"><a href="#fstream-特有操作" class="headerlink" title="fstream 特有操作"></a>fstream 特有操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left"><strong>fstream</strong> fstrm</td><td style="text-align:left">创建一个未绑定的文件流，fstream 是头文件 fstream 中定义的类型</td></tr><tr><td style="text-align:left"><strong>fstream</strong> fstrm(s)</td><td style="text-align:left">创建一个fstream object, 并打开名为 s 的文件。s 可以是 <strong>string</strong>，也可以是 <strong>C 风格字符串的指针</strong>，这些构造函数都是 explicit 的。<strong>默认文件 mode 依赖于 fstream 的类型</strong>。</td></tr><tr><td style="text-align:left"><strong>fstream</strong> fstrm(s, mode)</td><td style="text-align:left">按指定 mode 打开文件</td></tr><tr><td style="text-align:left">fstrm.open(s)</td><td style="text-align:left">打开一个名为 s 的文件，并将 s 与 fstrm 绑定。默认文件 mode 依赖于 fstream 的类型。返回 void</td></tr><tr><td style="text-align:left">fstrm.close()</td><td style="text-align:left">关闭与 fstrm 绑定的文件。返回 void</td></tr><tr><td style="text-align:left">fstrm.is_open()</td><td style="text-align:left">返回一个 bool 值，指出与 fstrm 绑定的文件是否成功打开且尚未关闭</td></tr></tbody></table></div><p><strong>NOTE:</strong> 当一个 fstream 对象被销毁时，close() 会自动被调用。</p><hr><h2 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Mode</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">以读的方式打开</td></tr><tr><td style="text-align:left">out</td><td style="text-align:left">以写的方式打开</td></tr><tr><td style="text-align:left">app</td><td style="text-align:left">每次写操作之前均定位到文件末尾</td></tr><tr><td style="text-align:left">ate</td><td style="text-align:left">打开文件后立即定位到文件末尾</td></tr><tr><td style="text-align:left">trunc</td><td style="text-align:left">截断文件</td></tr><tr><td style="text-align:left">binary</td><td style="text-align:left">以二进制方式进行 IO</td></tr></tbody></table></div><p><strong>NOTE:</strong> 指定文件模式有以下限制</p><ul><li>只可以对 <strong>ofstream 或 fstream 对象</strong>设定 <strong>out mode</strong></li><li>只可以对 <strong>ifstream 或 fstream 对象</strong>设定 <strong>in mode</strong></li><li>只有当 out 也被设定时，才可以设定 trunc</li><li>只要 trunc 没被设定，就可以设定 app 模式。<strong>app mode 下，默认指定 out mode</strong></li><li><strong>默认情况下</strong>，即使没有指定 trunc mode, 以 out mode 打开的文件也总会被截断。<strong>为了保留 out mode 下文件的内容，必须同时指定 app mode</strong>.</li><li><strong>ate mode 和 binary mode</strong> 可<strong>用于任何类型的文件流对象</strong>，且可以与其他任何文件 mode 组合使用</li><li>与 <strong>ifstream</strong> 关联的文件默认以 <strong>in mode</strong> 打开；与 <strong>ofstream</strong> 关联的文件默认以 <strong>out mode</strong> 打开；与 <strong>fstream</strong> 关联的文件默认以 <strong>in, out mode</strong>打开</li></ul><h3 id="out-mode-打开文件会丢弃已有数据"><a href="#out-mode-打开文件会丢弃已有数据" class="headerlink" title="out mode 打开文件会丢弃已有数据"></a>out mode 打开文件会丢弃已有数据</h3><ul><li>阻止一个 ofstream 清空数据的方法是<strong>显式指定 app mode 或 in mode</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这几条语句中，file1 都被截断</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>)</span></span>;    <span class="hljs-comment">// 隐含以 out mode 打开文件并截断文件</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::out)</span></span>; <span class="hljs-comment">// 隐含的截断文件</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;<br><br><span class="hljs-comment">// 为保留文件内容，显式指定 app mode</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::app)</span></span>; <span class="hljs-comment">// 隐含为 out mode</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::app | ofstream::out)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="每次调用-open-确定文件模式"><a href="#每次调用-open-确定文件模式" class="headerlink" title="每次调用 open 确定文件模式"></a>每次调用 open 确定文件模式</h3><ul><li>调用 open 打开文件的<strong>默认文件模式</strong>是 <strong>out mode</strong>，而一般 out mode 意味着同时使用 trunc mode.</li><li>调用 open 打开文件，可以显式地指定文件模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> file stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.1 IO 类</title>
      <link href="/2025/03/28/8.1%20IO%20class/"/>
      <url>/2025/03/28/8.1%20IO%20class/</url>
      
        <content type="html"><![CDATA[<h2 id="IO-库类型和头文件"><a href="#IO-库类型和头文件" class="headerlink" title="IO 库类型和头文件"></a>IO 库类型和头文件</h2><div class="table-container"><table><thead><tr><th style="text-align:center">头文件</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:center">iostream</td><td style="text-align:left">istream, wistream: 从流读出数据 <br> ostream, wostream: 向流写入数据 <br> iostream, wiostream: 读写流</td></tr><tr><td style="text-align:center">fstream</td><td style="text-align:left">ifstream, wifstream: 从文件读取数据 <br> ofstream, wofstream: 向文件写入数据 <br> iofstream, wiostream: 读写文件</td></tr><tr><td style="text-align:center">sstream</td><td style="text-align:left">istringstream, wistringstream: 从 string 读取数据 <br> ostringstream, wostringstream: 向 string 写入数据 <br> stringstream, wstringstream: 读写 string</td></tr></tbody></table></div><h3 id="IO-对象无拷贝或赋值"><a href="#IO-对象无拷贝或赋值" class="headerlink" title="IO 对象无拷贝或赋值"></a>IO 对象无拷贝或赋值</h3><ul><li>通常以<strong>引用</strong>的形式传递和返回流</li></ul><h3 id="条件状态-condition-state"><a href="#条件状态-condition-state" class="headerlink" title="条件状态(condition state)"></a>条件状态(condition state)</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类型与函数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">strm::iostate</td><td style="text-align:left">strm 是一种 IO 类型，iostate 提供了表达condition state的完整功能</td></tr><tr><td style="text-align:left">strm::badbit</td><td style="text-align:left">用来指出流已崩溃</td></tr><tr><td style="text-align:left">strm::failbit</td><td style="text-align:left">用来指出一个 IO 操作失败了</td></tr><tr><td style="text-align:left">strm::eofbit</td><td style="text-align:left">用来指出流到达了文件结束</td></tr><tr><td style="text-align:left">strm::goodbit</td><td style="text-align:left">用来指出流未处于错误状态，此值保证为零</td></tr><tr><td style="text-align:left">s.eof()</td><td style="text-align:left">若流 s 的 eofbit 置位，返回 true</td></tr><tr><td style="text-align:left">s.fail()</td><td style="text-align:left">若 s 的 failbit / badbit 置位，则返回 true</td></tr><tr><td style="text-align:left">s.bad()</td><td style="text-align:left">若 s 的badbit 置位，则返回 true</td></tr><tr><td style="text-align:left">s.good()</td><td style="text-align:left">若 s 处于有效状态，则返回 true</td></tr><tr><td style="text-align:left">s.clear()</td><td style="text-align:left">将流 s 的所有条件状态位置位，将流的状态设置为有效，返回 void</td></tr><tr><td style="text-align:left">s.clear(flags)</td><td style="text-align:left">根据给定的 flag 标志位，将流中对应的条件状态位<strong>复位</strong>。flags 类型为 strm::iostate。返回 void</td></tr><tr><td style="text-align:left">s.setstate(flags)</td><td style="text-align:left">根据给定的 flag 标志位，将流中对应的条件状态位<strong>置位</strong>，flags 类型为 strm::iostate。返回 void</td></tr><tr><td style="text-align:left">s.rdstate()</td><td style="text-align:left">返回流 s 的当前条件状态，返回值类型为 strm::iostate</td></tr></tbody></table></div><h3 id="确定一个流状态的最简单方法"><a href="#确定一个流状态的最简单方法" class="headerlink" title="确定一个流状态的最简单方法"></a>确定一个流状态的最简单方法</h3><ul><li><p>将它作为<strong>条件</strong>来使用</p><p>  while 循环检查 &gt;&gt; 表达式返回的流状态。如果输入操作成功，则保持流状态，条件为真。</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cin &gt;&gt; word) &#123;<br>    <span class="hljs-comment">// ok: 读操作成功</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><ul><li>endl: 输出缓冲区内容和一个换行，然后刷新缓冲区</li><li>flush：输出缓冲区内容，刷新缓冲区，不附加任何字符</li><li>ends：输出缓冲区内容和一个空字符，然后刷新缓冲区</li></ul><h3 id="unitbuf-操纵符"><a href="#unitbuf-操纵符" class="headerlink" title="unitbuf 操纵符"></a>unitbuf 操纵符</h3><p>若想在<strong>每次输出操作后都刷新缓冲区</strong>，可以使用 <strong>unitbuf 操纵符</strong>。它使得流在接下来的每次写操作之后都进行一次 flush 操作。而 <strong>nounitbuf 操纵符</strong>则重置流，<strong>使流恢复正常</strong>的系统管理缓冲区刷新机制。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">cout &lt;&lt; unitbuf;    <span class="hljs-comment">// 之后所有输出操作后都会刷新缓冲区</span><br>                    <span class="hljs-comment">// 任何输出都立即刷新，无缓冲</span><br>cout &lt;&lt; nounitbuf;  <span class="hljs-comment">// 回到正常缓冲方式</span><br></code></pre></td></tr></table></figure><h3 id="关联输入流与输出流"><a href="#关联输入流与输出流" class="headerlink" title="关联输入流与输出流"></a>关联输入流与输出流</h3><ul><li>当一个输入流关联到输出流，任何从输入流读取数据的操作都会刷新关联的输出流</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> IO 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.3 string 流</title>
      <link href="/2025/03/28/8.3%20string%20stream/"/>
      <url>/2025/03/28/8.3%20string%20stream/</url>
      
        <content type="html"><![CDATA[<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><pre><code>#include &lt;sstream&gt;</code></pre><p>头文件中定义了三个类类型来支持 IO：</p><ul><li><code>istringstream</code>: 从 string 读数据</li><li><code>ostringstream</code>: 从 string 写数据</li><li><code>stringstream</code>: 既可读，也可写</li></ul><h2 id="stringstream-特有的操作"><a href="#stringstream-特有的操作" class="headerlink" title="stringstream 特有的操作"></a>stringstream 特有的操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left">sstream strm</td><td style="text-align:left">strm 是一个未绑定的 stringstream 对象，sstream 是头文件中定义的一个类型</td></tr><tr><td style="text-align:left">sstream strm(s)</td><td style="text-align:left">strm 是个 stringstream 对象，保存 string s 的一个拷贝。<br> 此构造函数是 explicite 的</td></tr><tr><td style="text-align:left"><strong>strm.str()</strong></td><td style="text-align:left"><strong>返回所保存的 string 的拷贝</strong></td></tr><tr><td style="text-align:left"><strong>strm.str(s)</strong></td><td style="text-align:left"><strong>将 string s 拷贝到 strm 中，返回 void</strong></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> string stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1 顺序容器概述</title>
      <link href="/2025/03/28/9.1%20Sequentail%20Containers/"/>
      <url>/2025/03/28/9.1%20Sequentail%20Containers/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序容器类型"><a href="#顺序容器类型" class="headerlink" title="顺序容器类型"></a>顺序容器类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Description</th><th style="text-align:left">Application</th><th style="text-align:left">Time Complexity (insert/delete/visit)</th></tr></thead><tbody><tr><td style="text-align:left">vector</td><td style="text-align:left"><strong>动态数组</strong>, 支持<strong>随机访问</strong>，<strong>尾部之外</strong>的位置插入删除会很慢</td><td style="text-align:left">大部分场景首选</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr><tr><td style="text-align:left">list</td><td style="text-align:left"><strong>双向链表</strong>，支持<strong>双向顺序访问</strong>，在任何位置<strong>插入删除都很快</strong></td><td style="text-align:left">频繁的插入删除操作</td><td style="text-align:left">insert/delete O(1), visit O(n)</td></tr><tr><td style="text-align:left">deque</td><td style="text-align:left"><strong>双端队列</strong>，支持<strong>快速随机访问</strong>，<strong>头尾位置插入、删除速度很快</strong></td><td style="text-align:left">双端插入、删除操作</td><td style="text-align:left">insert/delete O(1), visit O(1)</td></tr><tr><td style="text-align:left">array</td><td style="text-align:left"><strong>定长数组</strong>，支持快速<strong>随机访问</strong>元素，<strong>不能添加或删除</strong>元素</td><td style="text-align:left">大小固定的数组</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr><tr><td style="text-align:left">forward_list</td><td style="text-align:left">单向链表，只支持<strong>单向顺序访问</strong>，在任何位置的插入删除都很快</td><td style="text-align:left">更节省内存的链表</td><td style="text-align:left">insert/delete O(1), visit O(n)</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">字符序列，与 vector 相似，<strong>专门用于保存字符</strong>。支持<strong>随机访问</strong>，<strong>尾部的插入删除速度快</strong></td><td style="text-align:left">存储和操作文本数据</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr></tbody></table></div><p>NOTE: forward_list 中没有 size 操作。</p><h3 id="选择容器的基本原则"><a href="#选择容器的基本原则" class="headerlink" title="选择容器的基本原则"></a>选择容器的基本原则</h3><ul><li><strong>首选 vector</strong></li><li>程序有<strong>很多小的元素</strong>，且<strong>空间的额外开销</strong>很重要，则<strong>不要使用 list</strong> 或 <strong>forward_list</strong></li><li>要求<strong>随机访问元素</strong>，使用 <strong>vector</strong> 或 <strong>deque</strong></li><li>要求在容器<strong>中间插入或删除元素</strong>，使用 <strong>list</strong> 或 <strong>forward_list</strong></li><li>需要在容器<strong>头尾插入或删除元素</strong>，但<strong>不会在中间位置进行插入删除操作</strong>，使用 <strong>deque</strong></li><li><p>如果程序只有在<strong>读取输入时</strong>才需要在容器<strong>中间位置插入</strong>元素，随后需要<strong>随机访问元素</strong></p><ul><li>首先确定是否真的需要在容器中间位置添加元素。处理输入数据时，通常向 <strong>vector</strong> 追加元素，再使用<strong>标准库 sort 函数重排</strong>元素，避免在容器中间位置添加元素</li><li>如果必须在中间位置插入元素，考虑在<strong>输入阶段使用 list</strong>，一旦输入完成，将 <strong>list 内容拷贝到 vector</strong> 中</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 顺序容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3 顺序容器操作</title>
      <link href="/2025/03/28/9.3%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/28/9.3%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h2><ul><li>除 array 外，所有容器都可以动态添加或删除元素</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.push_back(t) <br> c.emplace_back(args)</td><td>在 c 的尾部创建一个值为 t 或由 args 创建的元素。返回 void</td></tr><tr><td>c.push_front(t) <br> c.emplace_front(args)</td><td>在 c 的头部创建一个值为 t 或由 args 创建的元素。返回void</td></tr><tr><td>c.insert(p, t) <br> c.emplace(p, args)</td><td>在迭代器 <strong>p 指向的元素之前</strong>创建一个值为 t 或由 args 创建的元素。<strong>返回指向新添加元素的迭代器</strong></td></tr><tr><td>c.insert(p, n, t)</td><td>在迭代器 <strong>p 指向的元素之前</strong>插入 n 个值为 t 的元素。<strong>返回指向新添加的第一个元素的迭代器</strong>；若 <strong>n 为 0</strong>，则<strong>返回 p</strong>。</td></tr><tr><td>c.insert(p, begin, end)</td><td>将迭代器 begin 和 end 指向范围内的元素插入到迭代器 p 指向的元素之前。<strong>begin 和 end 不能指向 c 中的元素</strong>。<strong>返回指向新添加第一个元素的迭代器</strong>；若<strong>范围为空</strong>，则<strong>返回 p</strong></td></tr><tr><td>c.insert(p, il)</td><td>il 是 {} 包围的元素值列表。将这些给定值插入到迭代器 p 指向的元素之前。<strong>返回指向新添加第一个元素的迭代器</strong>；若列表为空，则返回 p</td></tr></tbody></table></div><ul><li>forward_list 有自己专有版本的 insert 和 emplace</li><li><strong>forward_list</strong> <strong>不支持</strong> push_back 和 emplace_back</li><li><strong>vector 和 string 不支持</strong> push_front 和 emplace_front</li><li>向 <strong>vector、string、deque 插入元素</strong>会使指向容器的<strong>所有迭代器、引用、指针失效</strong></li><li>不同容器使用不同的内存分配策略</li><li>在 <strong>vector 或 string 尾部之外</strong>，或 <strong>deque 的首尾之外</strong>的任何位置<strong>添加元素</strong>，都<strong>需要移动元素</strong></li><li>向 vector 或 string 添加元素，可能引起整个对象存储空间的重新分配。重新分配对象存储空间需要重新分配内存，并将元素从旧的内存空间移动到新的内存空间</li></ul><h3 id="元素容器是拷贝"><a href="#元素容器是拷贝" class="headerlink" title="元素容器是拷贝"></a>元素容器是拷贝</h3><ul><li>使用对象来初始化容器，或将一个对象插入到容器中时，实际放入容器的是对象的拷贝</li></ul><h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><ul><li>vector, string, list, deque 都支持 push_back</li></ul><h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><ul><li>list, forward_list, deque 支持 push_front</li><li>vector 不支持 push_front</li></ul><h3 id="在容器特定位置添加元素"><a href="#在容器特定位置添加元素" class="headerlink" title="在容器特定位置添加元素"></a>在容器特定位置添加元素</h3><ul><li>vector, deque, list, string 都支持 insert</li><li>forward_list 有自己版本的 insert</li><li><p>有些容器不支持 push_front，但支持 insert，可以用 insert 在容器开始位置添加元素</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; vec;<br>vec.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">begin</span>(), <span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="emplace-操作"><a href="#emplace-操作" class="headerlink" title="emplace 操作"></a>emplace 操作</h4><ul><li>emplace, emplace_front, emplace_back 是<strong>构造元素</strong>，而不是拷贝元素</li><li>调用 push 或 insert 成员，是将元素类型的对象传递给它们，这些<strong>对象被拷贝到容器中</strong></li><li>调用 emplace 成员，是将参数传递给元素类型的构造函数。emplace 成员使用参数在容器管理的内存空间直接构造元素</li><li>传递给 emplace 函数的参数必须与元素类型的构造函数相匹配</li></ul><hr><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><ul><li>所有顺序容器都有 front 成员函数，返回首元素引用</li><li><strong>除 forward_list 之外</strong>，所有顺序容器都有 back 成员函数，返回尾元素引用</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.back()</td><td>返回 c 中尾元素的引用。若 c 为空，则函数行为未定义</td></tr><tr><td>c.front()</td><td>返回 c 中首元素的引用。若 c 为空，则函数行为未定义</td></tr><tr><td>c[n]</td><td>返回 c 中下标为 n 的元素的引用。n 是无符号整数，若 n &gt; c.size(), 则函数行为未定义</td></tr><tr><td>c.at(n)</td><td>返回 c 中下标为 n 的元素的引用。如果下标越界，抛出 out_of_range 异常</td></tr></tbody></table></div><ul><li>at 只适用于 string，vector，deque，array</li><li>back 不适用于 forward_list</li></ul><hr><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.pop_back()</td><td>删除 c 中尾元素。若 c 为空，函数行为未定义。返回 void</td></tr><tr><td>c.pop_front()</td><td>删除 c 中首元素。若 c 为空，函数行为未定义。返回 void</td></tr><tr><td>c.erase(p)</td><td>删除迭代器 p 指向的元素，<strong>返回一个指向被删元素之后元素的迭代器</strong>。若 p 指向尾元素，则返回尾后(off-the-end)顶点。若 p 是尾后迭代器，函数行为未定义</td></tr><tr><td>c.erase(b, e)</td><td>删除迭代器 b, e 指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器。若 e 本身是尾后迭代器，则返回的也是尾后迭代器</td></tr><tr><td>c.clear()</td><td>删除 c 中所有元素，返回 void</td></tr></tbody></table></div><ul><li>这些删除操作会改变容器大小，因此不适用于 array</li><li>forward_list 有自己版本的 erase</li><li>f<strong>orward_list 不支持 pop_back</strong></li><li><strong>vector、string 不支持 pop_fron</strong>t</li><li>删除 <strong>deque 除首尾之外</strong>的元素，会使所有迭代器、引用、指针失效</li><li>指向 <strong>vector 或 string 删除点之后位置</strong>的迭代器、引用、指针失效</li><li>删除元素的成员函数不检查参数，因此必须确保被删除元素存在</li></ul><hr><h2 id="forward-list-特殊操作"><a href="#forward-list-特殊操作" class="headerlink" title="forward_list 特殊操作"></a>forward_list 特殊操作</h2><ul><li>在单向链表中，没有简单的方法来获取一个元素的前驱。</li><li>在 forward_list 中添加删除操作都是通过<strong>改变给定元素之后的元素</strong>来完成</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>lst.before_begin() <br> lst.cbefore_begin()</td><td><strong>返回指向链表首元素之前不存在元素的迭代器</strong>。此迭代器<strong>不能解引用</strong>。cbefore_begin 返回 const_iterator</td></tr><tr><td>lst.insert_after(p, t) <br> lst.insert_after(p, n, t) <br> lst.insert_after(p, b, e) <br> lst.insert(p, il)</td><td>在迭代器 <strong>p 之后的位置插入元素</strong>。<br> t 是一个对象，n 是数量，b 和 e 是一对表示范围的迭代器（<strong>b，e 不能指向 lst 内</strong>），il 是一个花括号列表。<br> <strong>返回指向最后一个插入元素的迭代器</strong>。如果<strong>范围为空，则返回 p</strong>。如果 p 是尾后迭代器，则函数行为未定义</td></tr><tr><td>emplace_after(p, args)</td><td>使用 args 在 <strong>p 指定位置之后创建</strong>一个元素。<br> <strong>返回一个指向新元素的迭代器</strong>。若 p 为尾后迭代器，函数行为未定义</td></tr><tr><td>lst.erase_after(p) <br> lst.erase_after(b, e)</td><td>删除迭代器 <strong>p 指定位置之后</strong>的元素。或删除 <strong>从 b 之后直到（但不包括） e</strong> 之间的元素。<br> <strong>返回一个指向被删元素之后元素的迭代器</strong>。若<strong>不存在</strong>这样的元素，<strong>返回尾后迭代器</strong>；如果 <strong>p 指向 lst 的尾元素</strong>或者是<strong>尾后迭代器</strong>，函数行为未定义</td></tr></tbody></table></div><ul><li><p>在 forward_list 中添加或删除元素时，必须关注两个迭代器：一<strong>个指向要处理的元素</strong>，另<strong>一个指向其前驱</strong></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">forward_list&lt;<span class="hljs-type">int</span>&gt; flst&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">auto</span> prev = flst.<span class="hljs-built_in">before_begin</span>();        <span class="hljs-comment">// 指向 flst 的首前元素</span><br><span class="hljs-keyword">auto</span> curr = flst.<span class="hljs-built_in">begin</span>();               <span class="hljs-comment">// 指向 flst 的首元素</span><br><span class="hljs-keyword">while</span> (curr != flst.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (*curr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        curr = flst.<span class="hljs-built_in">erase_after</span>(prev);  <span class="hljs-comment">// 删除元素并移动 curr</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev = curr;                    <br>        ++curr;                         <span class="hljs-comment">// 移动 curr，指向下一个元素，prev 指向 curr 前驱</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h2><ul><li>使用 <strong>resize</strong> 增大或缩小容器大小</li><li>当前大小 &lt; 要求大小，容器后面元素会被删除</li><li>当前大小 &gt; 要求大小，会将新元素添加到容器后面</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.resize(n)</td><td>调整 c 的大小为 n 个元素。<br> 若 n &lt; c.size(), 则多出的元素会被删除 <br> 若必须添加新元素，则对新元素进行值初始化</td></tr><tr><td>c.resize(n, t)</td><td>调整 c 的大小为 n 个元素。<br> 任何新添加的元素都初始化为 t</td></tr></tbody></table></div><ul><li>resize 不适用于 array</li><li>如果 resize 缩小容器大小，则指向被删除元素的迭代器、指针、引用都失效</li><li>对 vector、string、deque 使用 resize 可能导致迭代器、引用、指针失效</li></ul><hr><h2 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h2><h3 id="向容器添加元素后"><a href="#向容器添加元素后" class="headerlink" title="向容器添加元素后"></a>向容器添加元素后</h3><ul><li><strong>vector</strong> 、<strong>string</strong>：<strong>存储空间被重新分配</strong>，则指向容器的<strong>迭代器、引用、指针失效</strong>；<strong>存储空间未重新分配</strong>，则指向<strong>插入元素之前</strong>的<strong>迭代器、引用、指针有效</strong>，指向<strong>插入元素之后</strong>的<strong>迭代器、引用、指针都失效</strong></li><li><strong>deque</strong>：插入到<strong>首尾位置之外</strong>的任何位置<strong>都会使迭代器、引用、指针失效</strong>。<strong>首尾位置添加元素</strong>，<strong>迭代器会失效</strong>，<strong>但</strong>指向容器内元素的<strong>引用、指针不会失效</strong></li><li><strong>list</strong>、<strong>forward_list</strong>：<strong>迭代器、指针、引用仍有效</strong></li></ul><h3 id="从容器删除元素后"><a href="#从容器删除元素后" class="headerlink" title="从容器删除元素后"></a>从容器删除元素后</h3><ul><li><strong>vector、string</strong>：指向<strong>被删元素之前</strong>的迭代器、引用、指针仍有效</li><li><strong>deque</strong>：<strong>首尾之外</strong>删除元素，指向被删元素之外的<strong>其他迭代器、引用、指针都失效</strong>。<strong>删除尾元素</strong>，<strong>尾后迭代器失效</strong>，其他迭代器、引用、指针仍有效。<strong>删除首元素</strong>，不会受影响</li><li><strong>list、forward_list</strong>：指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用、指针<strong>仍有效</strong></li></ul><h3 id="不要保存-end-返回的迭代器"><a href="#不要保存-end-返回的迭代器" class="headerlink" title="不要保存 end 返回的迭代器"></a>不要保存 end 返回的迭代器</h3><ul><li>vector、string 添加删除元素，或 deque 除首位置之外添加删除元素，都<strong>会导致尾后迭代器失效</strong>，因此添加删除元素的循环过程必须反复调用 end()，不能在循环前保存 end</li></ul><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li><strong>复合赋值语句</strong>（+=）只适用于 vector、string、deque、array，<strong>不适用于 list，forward_list</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 顺序容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2 容器库概览</title>
      <link href="/2025/03/28/9.2%20%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88/"/>
      <url>/2025/03/28/9.2%20%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="容器的通用操作"><a href="#容器的通用操作" class="headerlink" title="容器的通用操作"></a>容器的通用操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类型别名</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">iterator</td><td style="text-align:left">此容器类型的迭代器类型</td></tr><tr><td style="text-align:left">const_iterator</td><td style="text-align:left">可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td style="text-align:left">size_type</td><td style="text-align:left">无符号整数类型，足够保存此种容器类型最大可能容器大小</td></tr><tr><td style="text-align:left">difference_type</td><td style="text-align:left">带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td style="text-align:left">value_type</td><td style="text-align:left">元素类型</td></tr><tr><td style="text-align:left">reference</td><td style="text-align:left">元素的左值类型，与 <code>value_type &amp;</code> 含义相同</td></tr><tr><td style="text-align:left">const_reference</td><td style="text-align:left">元素的 const 左值类型 (即 <code>const value_type &amp;</code> )</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">构造函数</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">C c</td><td style="text-align:left">默认构造函数</td></tr><tr><td style="text-align:left">C c1(c2)</td><td style="text-align:left">构造 c2 的拷贝 c1</td></tr><tr><td style="text-align:left">C c(b, e)</td><td style="text-align:left">构造 c, 将迭代器 b 和 e 指定范围内的元素拷贝到 c (<strong>array 不支持</strong>)</td></tr><tr><td style="text-align:left">C c{a, b, c, …} <br> C c = {a, b, c, …}</td><td style="text-align:left">列表初始化, c 初始化为列表中元素的拷贝，列表元素类型必须与 C 中元素类型相容；对于 array，列表中<strong>元素数量必须小于等于 array 大小</strong></td></tr><tr><td style="text-align:left">C seq(n)</td><td style="text-align:left">seq 包含 n 个元素，元素进行了值初始化；此构造函数是 explicit。<strong>string 不适用</strong></td></tr><tr><td style="text-align:left">C seq(n, t)</td><td style="text-align:left">seq 包含 n 个 值初始化为 t 的元素</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">赋值与 swap</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1 = c2</td><td style="text-align:left">将 c1 中的元素替换为 c2 中的元素</td></tr><tr><td style="text-align:left">c1 = {a, b, c, …}</td><td style="text-align:left">将 c1 中的元素替换为列表中的元素(不支持 array)</td></tr><tr><td style="text-align:left">a.swap(b)</td><td style="text-align:left">交换 a 和 b 的元素</td></tr><tr><td style="text-align:left">swap(a, b)</td><td style="text-align:left">与 a.swap(b) 等价</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">大小</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.size()</td><td style="text-align:left">c 中元素的数目(不支持 forward_list)</td></tr><tr><td style="text-align:left">c.max_size()</td><td style="text-align:left">c 中可保存的最大元素数目</td></tr><tr><td style="text-align:left">c.empty()</td><td style="text-align:left">若 c 中存储了元素，返回 false，否则返回 true</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">添加/刪除元素(不适用于 array)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.insert(args)</td><td style="text-align:left">将 args 中的元素拷贝到 c 中</td></tr><tr><td style="text-align:left">c.emplace(inits)</td><td style="text-align:left">使用 inits 构造 c 中的一个元素</td></tr><tr><td style="text-align:left">c.eraser(args)</td><td style="text-align:left">删除 args 指定的的元素</td></tr><tr><td style="text-align:left">c.clear()</td><td style="text-align:left">删除 c 中的所有元素，返回 void</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">关系运算符</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">==, !=</td><td style="text-align:left">所有容器都支持</td></tr><tr><td style="text-align:left">&lt;, &lt;=, &gt;, &gt;=</td><td style="text-align:left">无需关联容器不支持</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">获取迭代器</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.begin(), c.end()</td><td style="text-align:left">返回指向 c 的首元素和尾元素之后位置的迭代器</td></tr><tr><td style="text-align:left">c.cbegin(), c.cend()</td><td style="text-align:left">返回 const_iterator</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">反向容器的额外成员(不支持 forward_list)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">reverse_iterator</td><td style="text-align:left">按逆序寻址元素的迭代器</td></tr><tr><td style="text-align:left">const_reverse_itrator</td><td style="text-align:left">不能修改元素的逆序迭代器</td></tr><tr><td style="text-align:left">c.rbegin(), c.rend()</td><td style="text-align:left">返回指向尾元素和首元素之前位置的迭代器</td></tr><tr><td style="text-align:left">c.crbegin(), c.crend()</td><td style="text-align:left">返回 const_reverse_itrator</td></tr></tbody></table></div><hr><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="若-begin-end-构成合法的迭代器范围"><a href="#若-begin-end-构成合法的迭代器范围" class="headerlink" title="若 begin, end 构成合法的迭代器范围"></a>若 begin, end 构成合法的迭代器范围</h3><ul><li>begin==end, 容器为空</li><li>begin!=end, 容器至少含有一个元素</li><li>可以通过对 begin 的若干次递增，使得 begin==end</li></ul><h3 id="begin-end-有多个版本"><a href="#begin-end-有多个版本" class="headerlink" title="begin, end 有多个版本"></a>begin, end 有多个版本</h3><ul><li>begin, end：正常版本，支持对容器读写操作</li><li>cbegin, cend：const 版本，只支持对容器读操作</li><li>rbegin, rend：返回反向迭代器，支持读写操作</li><li>crbegin, crend：const 版本反向迭代器，只支持读操作</li></ul><p><strong>NOTE：</strong></p><ul><li>forward_list 不支持递减运算符 “—“；</li></ul><hr><h2 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h2><ul><li>迭代器类型</li><li>反向迭代器类型</li><li>通过<strong>类型别名</strong>，可以在不知道元素类型的情况下使用它<ul><li>需要<strong>元素类型</strong>，使用容器的 <strong>value_type</strong></li><li>需要<strong>元素类型的引用</strong>，使用容器的 <strong>reference</strong> 或 <strong>const_reference</strong></li></ul></li></ul><hr><h2 id="容器定义与初始化"><a href="#容器定义与初始化" class="headerlink" title="容器定义与初始化"></a>容器定义与初始化</h2><h3 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h3><ul><li>直接拷贝整个容器</li><li>拷贝由一个迭代器对指定的范围( array 除外)</li><li>当将一个容器初始化为另一个容器的拷贝时，<strong>容器类型</strong>和<strong>元素类型必须相同</strong></li><li><p>使用迭代器范围的构造函数：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 拷贝元素，直到（但不包括）it 指向的元素</span><br><span class="hljs-function">deque&lt;string&gt; <span class="hljs-title">authList</span><span class="hljs-params">(author.begin(), it)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="与顺序容器大小有关的构造函数"><a href="#与顺序容器大小有关的构造函数" class="headerlink" title="与顺序容器大小有关的构造函数"></a>与顺序容器大小有关的构造函数</h3><ul><li><p><strong>只有顺序容器</strong>(不包含 array)才能<strong>接受大小参数</strong>, 关联容器不支持</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">C <span class="hljs-title">seq</span><span class="hljs-params">(n)</span></span>;       <span class="hljs-comment">// seq 包含了 n 个元素，这些元素进行了值初始化，</span><br>                <span class="hljs-comment">// 此构造函数是 explicit 的，string 不适用</span><br><span class="hljs-function">C <span class="hljs-title">seq</span><span class="hljs-params">(n, v)</span></span>;    <span class="hljs-comment">// seq 包含 n 个值为 v 的元素</span><br></code></pre></td></tr></table></figure></li><li><p>array 具有固定大小，使用 <strong>array 时必须指定元素类型与大小</strong></p></li><li><p>array 不支持普通的容器构造函数，一个默认构造的 array 是非空的，元素都进行默认初始化</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>, 10&gt; ia1;        <span class="hljs-comment">// 数组类型包括元素类型与大小</span><br>array&lt;<span class="hljs-type">int</span>, 10&gt; ia2 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; ia3 = &#123;<span class="hljs-number">42</span>&#125;; <span class="hljs-comment">// ia3[0] 的元素为42，其余元素为 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>内置数组类型不能进行拷贝或对象赋值操作</strong>，但 array 可以</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> digs[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> cop[<span class="hljs-number">10</span>] = digs;     <span class="hljs-comment">// 错误！内置数组类型不支持拷贝或赋值</span><br>array&lt;<span class="hljs-type">int</span>, 10&gt; digits = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; copys = digits;      <span class="hljs-comment">// 正确：只要数组类型匹配即合法</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="赋值与-swap"><a href="#赋值与-swap" class="headerlink" title="赋值与 swap"></a>赋值与 swap</h2><ul><li>赋值运算符将其左边容器中的全部元素替换为右边容器中的拷贝，大小也变得与右边容器相等</li><li><p>array 类型允许赋值，“=” 左右容器类型与元素类型必须相同（包括 <strong>array 的大小</strong>）</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>, 10&gt; a1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; a2 = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-comment">// 10 个元素全部初始化为 0</span><br>a1 = a2;    <span class="hljs-comment">// 替换 a1 中的元素</span><br></code></pre></td></tr></table></figure></li><li><p>由于 “=” 左右容器大小可能不容，array 不支持 assign，也不允许 {} 包围的值列表进行赋值（<strong>注意区分赋值与初始化</strong>）</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">a2 = &#123;<span class="hljs-number">0</span>&#125;;   <span class="hljs-comment">// 错误！不允许值列表进行赋值</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="容器赋值运算"><a href="#容器赋值运算" class="headerlink" title="容器赋值运算"></a>容器赋值运算</h3><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1 = c2</td><td style="text-align:left">将 c1 中的元素替换为 c2 中元素的拷贝。c1, c2 必须具有相同类型</td></tr><tr><td style="text-align:left">c = {a, b, c, …}</td><td style="text-align:left">将 c 中的元素替换为列表中元素的拷贝。<strong>array 不支持</strong></td></tr></tbody></table></div><h3 id="使用-assign-成员"><a href="#使用-assign-成员" class="headerlink" title="使用 assign 成员"></a>使用 assign 成员</h3><ul><li>顺序容器(array 除外)定义了 assign 成员，assign 操作用参数指定的元素的拷贝替换左边容器中的所有元素</li><li><strong>assign</strong> 允许从一个<strong>不同但相容的类型赋值</strong></li><li><strong>assign</strong> 允许从<strong>容器的一个子序列赋值</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">assign Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">seq.assign(b, e)</td><td style="text-align:left">将 seq 中的元素替换为迭代器 b, e所指向范围内的元素(<strong>迭代器b,e不能指向 seq</strong>)</td></tr><tr><td style="text-align:left">seq.assign(il)</td><td style="text-align:left">将 seq 中的元素替换为初始化列表 il 中的元素</td></tr><tr><td style="text-align:left">seq.assign(n, v)</td><td style="text-align:left">将 seq 中的元素替换为 n 个值为 v 的元素</td></tr></tbody></table></div><p><strong>NOTE:</strong></p><ul><li><strong>assign 操作不能用于关联容器和 array</strong></li></ul><h3 id="使用-swap"><a href="#使用-swap" class="headerlink" title="使用 swap"></a>使用 swap</h3><div class="table-container"><table><thead><tr><th style="text-align:left">Swap Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1. swap(c2) <br> swap(c1, c2)</td><td style="text-align:left">交换 c1, c2中的元素(c1 和 c2 必须具有相同的类型)。<strong>swap 通常比从 c2 向 c1 拷贝元素快</strong></td></tr></tbody></table></div><ul><li>除 array 外，交换两个容器内容的操作很快——<strong>容器本身并未交换，只是交换了两个容器的内部数据结构</strong></li><li>除 array 外，<strong>swap 不对任何元素进行拷贝、删除或插入操作</strong>，因此可以保证在常数时间内完成。</li><li>swap 两个 <strong>array</strong> 会真正交换它们的元素</li><li>标准库中既提供成员函数版本的 swap, 也提供非成员函数版本的 swap</li></ul><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li><strong>赋值相关运算</strong>会<strong>导致</strong>指向<strong>左边容器内部</strong>的<strong>迭代器、引用和指针失效</strong>，而<strong>除 string 外</strong>，<strong>swap</strong> 操作将容器内容交换<strong>不会导致</strong>指向容器的迭代器、引用、指针失效</li></ul><hr><h2 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h2><ul><li>成员函数 size, 返回容器中元素的数目</li><li>empty：当 size 为 0 时返回 true, 否则返回 false</li><li>max_size: 返回一个大于或等于该容器所能容纳的最大元素数量的值</li><li>forward_list 支持 max_size 和 empty, 不支持 size</li></ul><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><ul><li><strong>每个容器</strong>都支持相等运算符 <strong>“==”</strong> 和 <strong>“!=”</strong></li><li><strong>除无序容器外</strong>的所有容器<strong>都支持</strong>关系运算符：<strong>“&gt;, &gt;=, &lt;, &lt;=”</strong></li><li>关系运算符左右两边的<strong>容器必须是相同类型</strong>，且<strong>保存相同类型元素</strong></li></ul><h3 id="运算符工作方式与-string-相似"><a href="#运算符工作方式与-string-相似" class="headerlink" title="运算符工作方式与 string 相似"></a>运算符工作方式与 string 相似</h3><ul><li>两容器大小相等，所有元素两两对应相等，则两容器相等</li><li>两容器大小不等，小容器中元素都等于大容器中对应位置元素，则小容器小于大容器</li><li>两容器都不是另一个容器的前缀子序列，它们的比较结果取决于第一个不相等的元素</li></ul><h3 id="容器的关系运算符使用元素的关系运算符完成比较"><a href="#容器的关系运算符使用元素的关系运算符完成比较" class="headerlink" title="容器的关系运算符使用元素的关系运算符完成比较"></a>容器的关系运算符使用元素的关系运算符完成比较</h3><ul><li>只有元素类型也定义了相应的比较运算符时，容器才可以使用关系运算符比较</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 容器库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 再探构造函数</title>
      <link href="/2025/03/27/7.5%20%E5%86%8D%E6%8E%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2025/03/27/7.5%20%E5%86%8D%E6%8E%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h2><h3 id="构造函数的初始值有时必不可少"><a href="#构造函数的初始值有时必不可少" class="headerlink" title="构造函数的初始值有时必不可少"></a>构造函数的初始值有时必不可少</h3><ul><li>如果<strong>成员是 const 或者 引用</strong>，则<strong>必须将其初始化</strong></li><li>必须<strong>通过构造函数初始值列表</strong>为成员提供初值，而<strong>不是通过赋值</strong></li></ul><h3 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h3><ul><li>构造函数初始化列表<strong>只说明用于初始化成员的值</strong>，而<strong>不限定初始化顺序</strong></li><li>成员<strong>初始化顺序与类定义中出现顺序一致</strong></li><li>当一个成员是用另一个成员初始化时，<strong>必须保持类中定义顺序与初始化列表顺序的一致</strong></li></ul><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><ul><li>如果一个构造函数为所有参数提供了默认实参，它实际上也定义了默认构造函数</li></ul><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><ul><li>delegating constructor: 一个委托构造函数使用它所属类的其他构造函数执行自己的初始化过程</li><li>委托构造函数也有成员初始值列表和函数体</li></ul><p>使用委托构造函数重写 Sale_data 类</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br><br>    ......<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 非委托构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>(std::string s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>            <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br><br>    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() : <span class="hljs-built_in">Sale_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s) : <span class="hljs-built_in">Sale_data</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::istream &amp;is) : <span class="hljs-built_in">Sale_data</span>() &#123; <span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>); &#125;<br><br>   ......<br><br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h2><p>默认初始化在下面情况发生：</p><ul><li>当在块作用域内不使用任何初始值定义一个非静态变量或数组时</li><li>当一个类本身含有类类型的成员且使用合成的默认构造函数时</li><li>当类类型的成员没有在构造函数初始值列表中显式地初始化时</li></ul><p>值初始化在以下情况发生：</p><ul><li>数组初始化过程中提供的初始值数量少于数组大小时</li><li>当不使用一个初始值定义局部静态变量时</li><li>当通过书写形如 T() 的表达式显式的请求初始化时(其中 T 是类型名)</li></ul><h2 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h2><ul><li>能通过一个实参调用的构造函数定义了一条<strong>从构造函数的参数类型</strong>向<strong>类类型</strong>隐式转换的规则</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::string null_book = <span class="hljs-string">&quot;9-9999-9999&quot;</span>;<br><span class="hljs-comment">// 构造一个临时的 Sale_data 对象</span><br><span class="hljs-comment">// 该对象成员 bookNo = null_book, units_sold 和 revenue 都等于 0</span><br>item.<span class="hljs-built_in">combine</span>(null_book);<br></code></pre></td></tr></table></figure><ul><li>这里使用 string 实参调用 Sale_data 的 combine 成员，编译器用给定的 string 自动创建了一个 Sale_data 对象，这个临时对象被传递给 combine</li><li>combine 的参数是 常量引用，所以可以给该参数传递一个临时量</li></ul><h3 id="只允许一步类型转换"><a href="#只允许一步类型转换" class="headerlink" title="只允许一步类型转换"></a>只允许一步类型转换</h3><ul><li>编译器只会自动地执行<strong>一步类型转换</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>);    <span class="hljs-comment">// 错误，编译器不会将&quot;9-9999-9999&quot;转换为 Sale_data对象</span><br></code></pre></td></tr></table></figure><ul><li>可以显式的将字符串转换成 string 或者 Sale_data 对象：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>));<br><br>item.<span class="hljs-built_in">combine</span>(<span class="hljs-built_in">Sale_data</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="通过-explicit-阻止隐式的类类型转换"><a href="#通过-explicit-阻止隐式的类类型转换" class="headerlink" title="通过 explicit 阻止隐式的类类型转换"></a>通过 explicit 阻止隐式的类类型转换</h3><ul><li>在构造函数声明时，可加入 <strong>explicit 关键字</strong>阻止隐式类类型转换</li><li>explicit 只对一个实参的构造函数有效</li><li>只能在<strong>类内声明构造函数</strong>时使用 <strong>explicit</strong></li><li>explicit 构造函数<strong>只能用于直接初始化</strong>，不能用于拷贝初始化(=)等</li></ul><h2 id="聚合类-aggregate-class"><a href="#聚合类-aggregate-class" class="headerlink" title="聚合类(aggregate class)"></a>聚合类(aggregate class)</h2><ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，没有 virtual 函数</li></ul><h2 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h2><ul><li>数据成员是字面值常量的聚合类是字面值常量类</li><li><p>如果不是聚合类，但符合以下要求，也是字面值常量类：</p><ul><li>数据成员必须是字面值类型</li><li>类必须至少含有机一个 constexpr 构造函数</li><li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式；或者如果成员属于某种类型，则初始值必须使用成员自己的 constexpr 构造函数</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象</li></ul></li></ul><h3 id="constexpr-构造函数"><a href="#constexpr-构造函数" class="headerlink" title="constexpr 构造函数"></a>constexpr 构造函数</h3><ul><li>构造函数不能是 const 的，但字面值常量类的构造函数可以是 constexpr 函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++ primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 类的静态成员</title>
      <link href="/2025/03/27/7.6%20%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
      <url>/2025/03/27/7.6%20%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>使用 <strong>static 关键字</strong>声明静态成员，可以是 public 的，也可以是 private 的。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">rate</span><span class="hljs-params">( <span class="hljs-type">double</span> )</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::string owner;<br>    <span class="hljs-type">double</span> amount;<br>    <span class="hljs-type">static</span> <span class="hljs-type">double</span> interestRate;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>static 成员存在于任何对象之外，对象中不包含与静态成员有关的任何数据</li><li>静态成员函数不和任何对象绑定在一起，不包含 this 指针</li><li><strong>静态成员不能被声明为 cons</strong>t， 在 <strong>static 函数体内不能使用 this 指针</strong></li></ul><h2 id="使用静态成员"><a href="#使用静态成员" class="headerlink" title="使用静态成员"></a>使用静态成员</h2><ul><li>使用<strong>作用域运算符</strong>直接访问静态成员</li><li>使用类的对象、引用或指针访问静态成员</li><li>成员函数不用通过作用域运算符就可直接使用静态成员</li></ul><h2 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h2><ul><li>既可以在类内部定义，也可以在类外部定义</li><li>在外部定义时，<strong>不能重复使用</strong> static 关键字；和其他成员一样，必须<strong>指明成员所属类名</strong></li><li><strong>不能在类内部初始化静态成员</strong>，一般必须在类外部定义和初始化静态成员</li><li>类似全局变量，静态成员一旦被定义，就一致<strong>存在于程序的整个生命周期</strong></li><li><p>定义静态成员需要指定对象的类型名，然后是类名、作用域运算符、成员自己的名字</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义并初始化一个静态成员</span><br><span class="hljs-type">double</span> Account::interestRate = <span class="hljs-built_in">initRate</span>();<br></code></pre></td></tr></table></figure></li></ul><h2 id="静态成员类内初始化"><a href="#静态成员类内初始化" class="headerlink" title="静态成员类内初始化"></a>静态成员类内初始化</h2><ul><li>一般静态成员不在类内初始化，但是可以为静态成员提供 <strong>const 整数类型</strong>的类内初始值，要求静态成员必须是字面值常量类型的 constexpr。初始值必须是常量表达式。</li></ul><h2 id="静态成员可用于特殊场景"><a href="#静态成员可用于特殊场景" class="headerlink" title="静态成员可用于特殊场景"></a>静态成员可用于特殊场景</h2><ul><li>静态成员可以是<strong>不完全类型</strong></li><li><p>静态成员的类型可以就是它所属的类类型</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Bar mem1; <br>    Bar *mem2;<br>    Bar mem3;       <span class="hljs-comment">// 错误：数据成员必须是完全类型</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>可以使用<strong>静态成员作为默认实参</strong>，而非静态成员不行</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">clear</span><span class="hljs-params">( <span class="hljs-type">char</span> = bkground)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> bkground;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++ primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 类的作用域</title>
      <link href="/2025/03/27/7.4%20%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2025/03/27/7.4%20%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域和定义在类外部的成员"><a href="#作用域和定义在类外部的成员" class="headerlink" title="作用域和定义在类外部的成员"></a>作用域和定义在类外部的成员</h2><ol><li><p>为什么类外部定义成员函数必须提供类名和函数名</p><ul><li>一个类就是一个作用域</li><li><p>一旦遇到类名，定义的剩余部分就在类的作用域之内，包括参数列表和函数体</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(ScreenIndex i)</span> </span>&#123;<br>    Screen &amp;s = screens[i];<br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译器在处理参数列表之前已经明确了当前正处于 window_mgr 类作用域中，所以不必专门说明 ScreenIndex 是 window_mgr 类定义的。</li><li>screens 也是同理</li></ul></li></ul></li><li><p>函数的返回类型必须指明它是哪个类的成员</p><ul><li><p>函数返回类型在函数名之前，当成员函数定义在类外部时，返回类型中使用的名字在类作用域外部，因此<strong>必须指明返回类型是哪个类的成员</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    ......<br><br>    <span class="hljs-comment">// 向窗口添加一个 Screen, 返回它的编号</span><br>    <span class="hljs-function">ScreenIndex  <span class="hljs-title">addScreen</span><span class="hljs-params">(<span class="hljs-type">const</span> Screen &amp;)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">window_mgr::ScreenIndex             <span class="hljs-comment">// 首先处理返回类型</span><br>        window_mgr::<span class="hljs-built_in">addScreen</span>(<span class="hljs-type">const</span> Screen &amp; s) &#123;<br>    screens.<span class="hljs-built_in">push_back</span>(s);<br>    <span class="hljs-keyword">return</span> screens.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要想使用 ScreenIndex 作为返回类型，<strong>必须明确指明哪个类定义了它</strong></li></ul></li></ul></li></ol><h2 id="名字查找-name-lookup"><a href="#名字查找-name-lookup" class="headerlink" title="名字查找(name lookup)"></a>名字查找(name lookup)</h2><ol><li><p><strong>一般查找过程</strong></p><ul><li>首先在名字所在块儿中寻找声明语句，只考虑在名字使用前出现的声明</li><li>如果没找到，继续查找外层作用域</li><li>如果最终没有找到匹配声明，程序报错</li></ul></li><li><p>对于<strong>定义在类内部的成员函数</strong></p><ul><li><strong>首先，编译成员的声明</strong></li><li>直到<strong>类全部可见后才编译函数体</strong></li></ul></li><li><p><strong>类型名</strong>要特殊处理</p><ul><li><strong>一般的</strong>，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过</li><li><strong>特殊</strong>：在类中，如果成员使用了外层作用域的某个名字，改名字代表类型，则<strong>类不能在之后重新定义该名字</strong></li></ul></li><li><p><strong>成员定义中的普通块作用域的名字查找</strong></p><ul><li>在成员函数内查找该名字声明，同样只考虑函数使用之前出现的名字</li><li>成员函数内没找到，则在类内查找，类的所有成员都可以被考虑</li><li>类内没找到，在成员函数定义之前的作用域内查找</li></ul></li><li><p>类的作用域之后，<strong>在外围作用域查找</strong></p><ul><li>在函数和类中没有找到声明，则在类的外部作用域查找</li><li>若需要使用外层作用域中的同名的名字，可以使用<code>::</code>作用域运算符来进行请求</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++ primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 类的其他特性</title>
      <link href="/2025/03/27/7.3%20%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/"/>
      <url>/2025/03/27/7.3%20%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="定义类型成员"><a href="#定义类型成员" class="headerlink" title="定义类型成员"></a>定义类型成员</h2><p>自定义某种类型在类中的别名：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>typedef std::string::size_type pos;</code> 等价于 <code>using pos = std::string::size_type;</code></p><h2 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h2><ul><li>在类内部使用 <code>inline</code>作为函数声明的一部分，将函数显示的声明为内联函数</li><li><p>也可以在类外部用 <code>inline</code> 关键字修饰函数的定义</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];        <span class="hljs-comment">// 隐式内联</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">// 显示内联</span><br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span>                          <span class="hljs-comment">// 在函数定义处指定 inline</span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">Screen::move</span><span class="hljs-params">(Screen::pos r, Screen::pos c)</span> </span>&#123;<br>    pos row = r * width;        <span class="hljs-comment">// 计算行的位置</span><br>    cursor = row + c;           <span class="hljs-comment">// 将光标移动到指定的列</span><br>    <span class="hljs-keyword">return</span>  *<span class="hljs-keyword">this</span>;              <span class="hljs-comment">// 以左值的形式返回对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(Screen::pos r, Screen::pos c)</span> <span class="hljs-type">const</span> </span>&#123;      <span class="hljs-comment">// 在类的内部声明为内联函数</span><br>    pos row = r * width;        <span class="hljs-comment">// 计算行的位置</span><br>    <span class="hljs-keyword">return</span> contents[row + c];   <span class="hljs-comment">// 返回给定列的字符</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h2><ul><li><p>可变数据成员(mutable data member)永远不会是 cosnt, 即使它是const 对象的成员。因此一个 const 成员函数可以改变一个可变成员的值</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>通过 access_ctr 可变成员，追踪成员函数被调用次数</p></li><li>some_member() 是一个 const 成员函数，但依旧可以改变 access_ctr 可变成员的值</li></ul><h2 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h2><p>定义一个窗口管理类并用它表示显示器上的一组 Screen。这个类包含一个 Screen 类型的 vector，每个元素表示一个特定的 Screen，默认情况下，Window_mgr 类有一个默认初始化的 Screen</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br>    std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&#x27; &#x27;</span>)&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>类内初始值必须使用 <strong>=的初始化形式</strong>或者 <strong>{}的直接初始化形式</strong></li></ul><h2 id="返回-this-的成员函数"><a href="#返回-this-的成员函数" class="headerlink" title="返回 *this 的成员函数"></a>返回 *this 的成员函数</h2><ul><li><p>添加函数，负责设置光标所在位置字符或其他任一给定位置字符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd) &#123; contents = ht * wd, <span class="hljs-string">&#x27; &#x27;</span>; &#125;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(pos, pos, <span class="hljs-type">char</span>)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br>&#125;;<br></code></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    contents[cursor] = c;       <span class="hljs-comment">// 设置当前光标所在位置新值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;               <span class="hljs-comment">// 将 this 对象作为左值返回</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(pos r, pos col, <span class="hljs-type">char</span> c)</span> </span>&#123;<br>    contents[r*width + col] = c;        <span class="hljs-comment">// 设置指定位置的值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                       <span class="hljs-comment">// 将 this 对象作为左值返回</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回引用的函数是左值的，这些函数返回对象本身而不是对象的副本。此时可进行如下操作：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 把光标移动到指定位置，然后设置该位置的值</span><br>myscreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>).<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="从-const-成员函数返回-this"><a href="#从-const-成员函数返回-this" class="headerlink" title="从 const 成员函数返回 *this"></a>从 const 成员函数返回 *this</h3><p>添加 display() 操作，负责打印 Screen 的内容。</p><ul><li>若将 display() 设置为 const, 则 this 是指向 const 的指针，而 *this 是 const 对象</li><li>一个 <strong>const 成员函数</strong>如果以<strong>引用</strong>形式返回 *this，那么它的<strong>返回类型是常量引用</strong></li></ul><h3 id="基于-const-的重载"><a href="#基于-const-的重载" class="headerlink" title="基于 const 的重载"></a>基于 const 的重载</h3><p>由于非常量版本函数对于常量对象不可用，所以重载一个 const 版本的成员函数很有必要</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd) &#123; contents = ht * wd, <span class="hljs-string">&#x27; &#x27;</span>; &#125;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(pos, pos, <span class="hljs-type">char</span>)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 根据对象是否是 const 重载了 display 函数</span><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp; os)</span> </span>&#123;<br>        <span class="hljs-built_in">do_display</span>(os); <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> Screen &amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">do_display</span>(os);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br><br>    <span class="hljs-comment">// 该函数负责显示 Screen 的内容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span> </span>&#123; os &lt;&lt; contents; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 do_display 完成后，display 返回解引用 this 所得的对象</p><ul><li>非常量版本中，<strong>this 指向一个非常量对象</strong>，因此 display 返回一个 非常量引用</li><li>const 成员中，<strong>this 指向一个常量对象</strong>，display返回一个常量引用</li></ul><h2 id="类之间的友元关系"><a href="#类之间的友元关系" class="headerlink" title="类之间的友元关系"></a>类之间的友元关系</h2><p>A 类若想访问 B 类的私有成员，需要被 B 类声明为友元。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-comment">// window_mgr 成员可以访问 Screen 的私有成员</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span>;<br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br>    std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&#x27; &#x27;</span>)&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(window_mgr::ScreenIndex i)</span> </span>&#123;<br>    <span class="hljs-comment">// s 是 Screen 的引用，指向想清空的那个 Screen</span><br>    Screen &amp;s = screens[i];<br>    <span class="hljs-comment">// 将选定 Screen 重置为空白</span><br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将 window_mgr 声明为 Screen 的友元，则 window_mgr 的成员可以访问 Screen 的私有成员</li><li><strong>友元关系不存在传递性</strong>，每个类负责控制自己的友元类或友元函数</li></ul><h2 id="成员函数作为友元"><a href="#成员函数作为友元" class="headerlink" title="成员函数作为友元"></a>成员函数作为友元</h2><h3 id="程序设计步骤"><a href="#程序设计步骤" class="headerlink" title="程序设计步骤"></a>程序设计步骤</h3><ul><li><strong>首先，定义 window_mgr 类</strong>，在其中声明 clear 成员，但不定义它。<strong>在 clear 函数使用 Screen 的成员之前必须声明 Screen 类</strong></li><li><strong>接下来定义 Screen,</strong> 包括对于 clear 的友元声明</li><li><strong>最后定义 clear</strong>, 此时它才可以使用 Screen 的成员</li></ul><p>Screen 只为 window_mgr 的成员 clear 提供访问权限</p><h3 id="详细代码示例"><a href="#详细代码示例" class="headerlink" title="详细代码示例"></a>详细代码示例</h3><ol><li><p>首先<strong>定义 window_mgr 类</strong></p><ul><li>在 window_mgr.h 中使用 Screen 类的<strong>前置声明</strong>，防止循环依赖</li><li><p>在 window_mgr 类中<strong>声明 clear 成员</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br><span class="hljs-comment">//    std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;</span><br>    std::vector&lt;Screen&gt; screens;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>其次<strong>定义 Screen 类</strong></p><ul><li>在 <strong>Screen.h</strong> 文件中使用 <code>#include &quot;window_mgr.h&quot;</code>，使得 <strong>clear 声明在 Screen 类之前</strong></li><li><p>在 Screen 类中声明 clear 为友元函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;window_mgr.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-comment">// window_mgr 成员可以访问 Screen 的私有成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(ScreenIndex)</span></span>;  <span class="hljs-comment">// 声明window_mgr的clear为友元函数</span><br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>最后<strong>定义 clear 成员</strong></p><ul><li>在 window_mgr.cpp 中 包含 Screen.h, 使得 <strong>Screen 类的声明在 clear 定义之前</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;window_mgr.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Screen.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(window_mgr::ScreenIndex i)</span> </span>&#123;<br>    <span class="hljs-comment">// s 是 Screen 的引用，指向想清空的那个 Screen</span><br>    Screen &amp;s = screens[i];<br>    <span class="hljs-comment">// 将选定 Screen 重置为空白</span><br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="编译器对-Screen-h-Screen-cpp-window-mgr-h-window-mgr-cpp-的处理过程"><a href="#编译器对-Screen-h-Screen-cpp-window-mgr-h-window-mgr-cpp-的处理过程" class="headerlink" title="编译器对 Screen.h, Screen.cpp, window_mgr.h, window_mgr.cpp 的处理过程"></a>编译器对 Screen.h, Screen.cpp, window_mgr.h, window_mgr.cpp 的处理过程</h3><pre class="mermaid">flowchart TD    A["Screen.cpp"]    A --> B["#include "Screen.h""]    B --> C["#include "window_mgr.h""]    C --> D["窗口管理器(window_mgr)的完整声明（含 friend 声明）"]    B --> E["Screen 类定义（友元声明：friend void window_mgr::clear(ScreenIndex);)"]    subgraph TU1["Screen.cpp的翻译单元"]        D        E    end</pre><ul><li>Screen.cpp 中包含 <strong>Screen.h</strong> ,Screen.h 中包含 <strong>window_mgr.h</strong></li><li>此时 window_mgr 已经完整，能正确处理友元声明</li><li>这个翻译单元中包含了 Screen.cpp 的代码，Screen.h 中 Screen 类的定义及友元声明，window_mgr.h 中 window_mgr 的声明（此时 <strong>window_mgr 内部对 Screen 的引用只需前向声明即可</strong>）</li></ul><pre class="mermaid">flowchart TD    A["window_mgr.CPP"]    A --> B["#include "window_mgr.h""]    B --> C["window_mgr 类定义（包含对 Screen 的前向声明）"]    A --> D["#include "Screen.h""]    D --> E[Screen 类的完整定义（含友元声明）]    subgraph "TU2: Window_mgr.cpp 翻译单元"        C        E    end</pre><ul><li><strong>window_mgr.cpp</strong> 首先包含 <strong>window_mgr.h</strong>，这时 window_mgr 中对 Screen 的引用仅为前向声明</li><li>随后在 <strong>window_mgr.cpp</strong> 中包含 <strong>Screen.h</strong>(通过包含获得 Screen.h 的完整定义)，从而可以在 <strong>window_mgr.cpp</strong> 中使用 Screen 类的 <strong>public 成员</strong></li><li>也可以让 clear() 使用 Screen 类的私有成员(clear 已被声明为友元)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 访问控制与封装</title>
      <link href="/2025/03/27/7.2%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85/"/>
      <url>/2025/03/27/7.2%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>使用 <strong>访问说明符(access specifiers)</strong>加强类的封装：</p><ul><li><strong>public</strong>: public 成员在<strong>整个程序内可访问</strong>，public 成员定义类的接口</li><li><strong>private</strong>: private 成员可以被<strong>类的成员函数访问</strong>，但<strong>不能被使用该类的代码访问</strong>，private 部分封装了类的实现细节</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span> (std::istream &amp;);<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> units_sold ? revenue / units_sold : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>struct</strong> 定义类：在第一个访问说明符之前的成员是 <strong>public</strong></li><li><strong>class</strong> 定义了：在第一个访问说明符之前的成员是 <strong>private</strong></li></ul><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>类允许其他类或函数访问非公有成员的方法是<strong>友元(friend)</strong>, 使用 <strong>friend</strong> 关键字可将函数或类声明为<strong>友元</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 为 Sale_data 的非成员函数做友元声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span> (std::istream &amp;);<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> units_sold ? revenue / units_sold : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br><br><span class="hljs-comment">// Sale_data 的非成员接口函数</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>一般在类定义开始或结束时定义友元</li><li>友元函数的声明<strong>不是</strong>通常意义的<strong>函数声明</strong>，在进行友元声明之后<strong>需对函数进行一次专门的声明</strong></li></ul><h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><ul><li>确保用户代码不会无意间破坏封装对象的状态</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级代码<ul><li>只要类的接口，用户代码就无需改变</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++ primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1 定义抽象数据类型</title>
      <link href="/2025/03/20/7.1%20%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/03/20/7.1%20%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Sale-item-class"><a href="#Sale-item-class" class="headerlink" title="Sale_item class"></a>Sale_item class</h2><p>Sale_item class 的作用是表示一本书的总销售额、售出册数、平均售价</p><h2 id="设计-Sale-data-class"><a href="#设计-Sale-data-class" class="headerlink" title="设计 Sale_data class"></a>设计 Sale_data class</h2><ol><li><p>Sale_data 的接口应该包含以下操作：</p><ul><li><strong>isbn 成员函数</strong>，返回对象的 ISBN 编号</li><li><strong>combine 成员函数</strong>，将一个 Sale_data 对象加到另一个对象上</li><li><strong>add 函数</strong>，执行两个 Sale_data 对象的加法</li><li><strong>read 函数</strong>，将数据从 istream 读入到 Sale_data 对象中</li><li><strong>print 函数</strong>，将 Sale_data 对象的值输出到 ostream</li></ul></li><li><p>Sale_data class 数据成员</p><ul><li><strong>bookNo</strong>———string 类型：表示 ISBN 编号</li><li><strong>units_sold</strong>——-unsigned 类型：表示某本书的销量</li><li><strong>revenue</strong>———double 类型：表示这本书的总销售收入</li><li><strong>avg_price 成员函数</strong>，返回售出书籍的平均价格</li></ul></li></ol><ul><li>成员函数声明必须在 class 内部，定义可以在外部，也可以在内部</li><li>非成员函数声明与定义都在 class 外部</li><li>定义在 class 内部的函数是隐式 inline 函数</li></ul><h2 id="Sale-data-class-声明与定义"><a href="#Sale-data-class-声明与定义" class="headerlink" title="Sale_data class 声明与定义"></a>Sale_data class 声明与定义</h2><h3 id="Sale-data-h"><a href="#Sale-data-h" class="headerlink" title="Sale_data.h"></a>Sale_data.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br><br><span class="hljs-comment">// Sale_data 的非成员接口函数</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="解读std-string-isbn-const-return-bookNo"><a href="#解读std-string-isbn-const-return-bookNo" class="headerlink" title="解读std::string isbn() const { return bookNo; }"></a>解读<code>std::string isbn() const &#123; return bookNo; &#125;</code></h3><ul><li><p><strong>this 隐式形参</strong>：</p><ul><li><code>std::string isbn() const &#123; return bookNo; &#125;</code> 等价于 <code>std::string isbn() const &#123; return this.bookNo; &#125;</code>，当一个 Sale_data 对象调用 isbn() 时，编译器将<strong>这个对象的地址</strong>传递给 isbn() 的<strong>隐式形参 this</strong>，相当于 <code>this-&gt;bookNo</code>，所以这条语句中可以直接使用 <code>return bookNo</code></li><li>this 是一个<strong>常量指针</strong>，不允许改变 this 中保存的地址</li></ul></li><li><p><strong>const 成员函数</strong></p><ul><li>在这里使用 const 成员函数的考虑是：无论 <strong>Sale_data 是常量对象</strong>还是<strong>非常量对象</strong>，<strong>都可以调用</strong> isbn()，提高 isbn() 成员函数的灵活性</li><li>一般情况，this 是一个指向<strong>类类型非常量版本</strong>的<strong>常量</strong>指针，为了使 isbn() 只能读取调用它的对象的 data member, 而不能写入新值，就需要改变 this 这个隐式形参类型，使其成为<strong>指向常量对象</strong>的<strong>常量指针</strong>。这种<strong>指向常量对象的常量指针</strong>，也<strong>允许</strong>它指向<strong>非常量对象</strong></li><li>紧随参数列表之后的 const 表示 this 是一个指向常量对象的常量指针。像这种使用 const 的成员函数称为<strong>常量成员函数(const member function)</strong></li><li><strong>NOTE:</strong> 常量对象，常量对象的引用或指针，都只能调用常量成员函数</li></ul></li></ul><h3 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h3><ul><li>在 class 外部定义成员函数，<strong>必须与 class 内部的声明保持一致</strong></li><li><p>class 外部定义的成员的名字<strong>必须包含它所属的类名</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sale_data::avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">if</span> (units_sold)<br>    <span class="hljs-keyword">return</span> revenue / units_sold;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="定义返回-this-对象的函数"><a href="#定义返回-this-对象的函数" class="headerlink" title="定义返回 this 对象的函数"></a>定义返回 this 对象的函数</h3><ul><li><p>函数 combine 的设计类似复合赋值运算符 <strong>+=</strong>, 内置赋值运算符把它<strong>左侧运算对象当成左值返回</strong>，combine 函数也应模仿此操作，返回调用 combine() 的 Sale_data 对象的引用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Sale_data &amp; <span class="hljs-title">Sale_data::combine</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp; rhs)</span> </span>&#123;<br>    units_sold += rhs.units_sold;<br>    revenue += rhs.revenue;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;       <span class="hljs-comment">// 返回调用该函数的对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><ul><li>一般的，如果非成员函数是类接口的组成部分，则这些函数的<strong>声明应与类在同一个头文件中</strong></li><li><p>IO 类是<strong>不能被拷贝</strong>的类型，只能通过<strong>引用传递</strong>；读取和写入会<strong>改变 IO 流的内容</strong>，因此函数接受 IO 的<strong>普通引用</strong>，而不是对常量的引用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输入交易信息包括 ISBN, 售出总数，售出价格</span><br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp; is, Sale_data &amp; item)</span> </span>&#123;<br>    <span class="hljs-type">double</span> price = <span class="hljs-number">0</span>;<br>    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>    item.revenue = price * item.units_sold;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp; os, <span class="hljs-type">const</span> Sale_data &amp; item)</span> </span>&#123;<br>    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>        &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-built_in">avg_price</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// 接受两个 Sale_data 对象，返回一个新的 Sale_data 对象，用于表示两个对象的和</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;lhs, <span class="hljs-type">const</span> Sale_data &amp;rhs)</span> </span>&#123;<br>    Sale_data sum = lhs;<br>    sum.<span class="hljs-built_in">combine</span>(rhs);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>构造函数名字<strong>与类名相同</strong></li><li>构造函数<strong>没有返回类型</strong></li><li>构造函数有参数列表（可能为空）和函数体（可能为空）</li><li>构造函数<strong>不能被声明为 const</strong></li><li>若没有显示的定义构造函数，编译器会隐式的定义一个<strong>默认构造函数(default constructor)</strong></li><li>合成的 default constructor 只适用于非常简单的类<ul><li>只有当类<strong>没有声明任何构造函数</strong>时，编译器才会自动生成 default constructor</li><li>如果类内包含内置类型或复合类型（数组、指针等），只有当这些成员全部被赋予类内初始值时，这个类才适用于合成的默认构造函数</li><li>如果类内包含其他类类型成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员</li></ul></li></ul><h3 id="定义-Sale-data-的构造函数"><a href="#定义-Sale-data-的构造函数" class="headerlink" title="定义 Sale_data 的构造函数"></a>定义 Sale_data 的构造函数</h3><ul><li>constructor1: istream &amp;, 从中读取一条交易信息</li><li>constructor2: const string &amp;, 表示 ISBN 编号；unsigned， 表示售出图书数量；double, 表示图书的售出价格</li><li>constructor3: const string &amp;, 表示 ISBN 编号；其他成员由编译器赋予默认值</li><li>constructor4: 空参数列表（default constructor）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::istream &amp; );<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>= default</strong>: 让编译器自动生成构造函数</li><li><strong>构造函数初始值列表(constructor initialize list)</strong>： “:”之后 “{}” 之前的部分。作用是接受参数列表的内容，赋值给相应成员，未被赋值的成员由编译器赋默认值</li></ul><h3 id="类外部定义构造函数"><a href="#类外部定义构造函数" class="headerlink" title="类外部定义构造函数"></a>类外部定义构造函数</h3><ul><li><p>与其他函数一样，必须指明这个构造函数是哪个类的成员</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 接受 istream &amp; 的构造函数</span><br>Sale_data::<span class="hljs-built_in">Sale_data</span>(std::istream &amp; is) &#123;<br>    <span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个函数没有 constructor initialize list，所以在调用它时，类内成员将通过类内值初始化或执行默认初始化</p></li><li>read() 的第二个参数是 Sale_data 对象的引用，使用 *this 将 “this”对象作为实参传递给 read 函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> c++ primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog</title>
      <link href="/2025/03/20/My-first-blog/"/>
      <url>/2025/03/20/My-first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="This-is-my-first-blog"><a href="#This-is-my-first-blog" class="headerlink" title="This is my first blog"></a>This is my first blog</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/20/hello-world/"/>
      <url>/2025/03/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
