<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>11.4 无序容器</title>
      <link href="/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.4%20%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
      <url>/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.4%20%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>新标准定义了 4 个无序容器</li><li>无序容器使用一个<strong>哈希函数(hash function)</strong> 和<strong>关键字类型的 <code>==</code> 运算符</strong>来组织元素</li></ul><h2 id="使用无序容器"><a href="#使用无序容器" class="headerlink" title="使用无序容器"></a>使用无序容器</h2><ul><li>通常可以用一个无序容器替换对应的有序容器，反之亦然</li></ul><h2 id="管理桶"><a href="#管理桶" class="headerlink" title="管理桶"></a>管理桶</h2><ul><li>无序容器<strong>在存储上组织为一组桶</strong>，每个桶保存零个或多个元素</li><li>使用一个<strong>哈希函数将元素映射到桶</strong></li><li>容器将具有<strong>特定哈希值</strong>的元素存储到一个桶中。<strong>如果允许关键字重复，则所有具有相同关键字的元素都在一个桶中</strong></li><li>访问一个元素，首先计算哈希值，指出应该搜索哪个桶</li><li>无序容器的<strong>性能依赖于哈希函数的质量</strong>和<strong>桶的数量与大小</strong></li></ul><h3 id="无序容器管理操作"><a href="#无序容器管理操作" class="headerlink" title="无序容器管理操作"></a>无序容器管理操作</h3><h4 id="桶接口"><a href="#桶接口" class="headerlink" title="桶接口"></a>桶接口</h4><div class="table-container"><table><thead><tr><th>Bucket Interface</th><th>Description</th></tr></thead><tbody><tr><td><strong>c.bucket_count()</strong></td><td>正在使用的桶的数量</td></tr><tr><td><strong>c.max_buckket_count()</strong></td><td>容器能容纳的最多的桶的数量</td></tr><tr><td><strong>c.bucket_size(n)</strong></td><td>第 n 个桶中有多少元素</td></tr><tr><td><strong>c.bucket(k)</strong></td><td>关键字为 k 的元素在哪个桶中</td></tr></tbody></table></div><h4 id="桶迭代"><a href="#桶迭代" class="headerlink" title="桶迭代"></a>桶迭代</h4><div class="table-container"><table><thead><tr><th>Bucket Iterator</th><th>Description</th></tr></thead><tbody><tr><td>local_iterator</td><td>可以用来访问桶中元素的迭代器类型</td></tr><tr><td>const_local_iterator</td><td>桶迭代器的 const 版本</td></tr><tr><td><strong>c.begin(n), c.end(n)</strong></td><td>桶 n 的首元素迭代器和尾后迭代器</td></tr><tr><td><strong>c.cbegin(n), c.cend(n)</strong></td><td>与前两个函数类似，返回 const_local_iterator</td></tr></tbody></table></div><h4 id="哈希策略"><a href="#哈希策略" class="headerlink" title="哈希策略"></a>哈希策略</h4><div class="table-container"><table><thead><tr><th>Hash Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>c.load_factor()</strong></td><td><strong>每个桶的平均元素数量，返回 float 值</strong></td></tr><tr><td><strong>c.max_load_factor()</strong></td><td>c 试图维护的平均桶大小，返回 float 值 <br> c 在需要时添加新的桶，以使得 load_factor &lt;= max_load_factor</td></tr><tr><td><strong>c.rehash(n)</strong></td><td>重组存储，使得 <strong>bucket_count &gt;= n</strong> 且 <strong>bucket_count &gt; size / max_load_factor</strong></td></tr><tr><td><strong>c.reserve(n)</strong></td><td>重组存储，使得 c 可以保存 n 个元素而不必 rehash</td></tr></tbody></table></div><h2 id="无序容器对关键字类型的要求"><a href="#无序容器对关键字类型的要求" class="headerlink" title="无序容器对关键字类型的要求"></a>无序容器对关键字类型的要求</h2><ul><li>默认情况下，无序容器使用关键字类型的 <code>==</code> 运算符来比较元素，还使用一个 hash<key_type> 类型的对象来生成每个元素的哈希值</li><li>不能直接定义自定义类类型的无序容器，必须提供自己的 hash 模板版本</li><li><p>不使用默认 hash，而使用一种类似于有序容器重载关键字类型的默认比较操作</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">hasher</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;sd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">hash</span>&lt;string&gt; () (sd.<span class="hljs-built_in">isbn</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">eqOp</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp; lhs, <span class="hljs-type">const</span> Sale_data &amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>hasher 函数使用标准库 hash 类型对象来计算 ISBN 成员的 hash 值</p></li><li>eqOp 函数通过比较 ISBN 来比较两个 Sale_data 对象</li><li>使用这些函数来定义一个 unordered_multiset</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> SD_multiset = std::unordered_multiset&lt;Sale_data, <span class="hljs-keyword">decltype</span>(hasher) *, <span class="hljs-keyword">decltype</span>(eqOp) *&gt;;<br><br><span class="hljs-comment">// 参数是桶大小，哈希函数指针，相等性判断运算符指针</span><br><span class="hljs-function">SD_multiset <span class="hljs-title">bookstore</span><span class="hljs-params">(<span class="hljs-number">42</span>, hasher, eqOp)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>如果已经定义了 <code>==</code> 运算符，则只需要传入自定义的哈希函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 关联容器 </tag>
            
            <tag> 无序容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.3 关联容器操作</title>
      <link href="/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.3%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/04/08/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.3%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>关联容器额外的类型别名</li></ul><div class="table-container"><table><thead><tr><th>Class name</th><th>Description</th></tr></thead><tbody><tr><td>key_type</td><td>此容器类型的关键字类型</td></tr><tr><td>mapped_type</td><td>每个关键字关联的类型：<strong>只适用于 map</strong></td></tr><tr><td>value_type</td><td>对于 <strong>set</strong> ，<strong>与 key_type 相同</strong> <br> 对于 <strong>map</strong>，为 <strong>pair<const key_type, mapped_type></strong></td></tr></tbody></table></div><ul><li>map 中的每个元素是一个 pair 对象，包含一个关键字和一个关联的值</li></ul><h2 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h2><ul><li>解引用一个关联容器迭代器，得到一个类型为容器的 value_type 的值的引用</li><li>一个 map 的元素类型是 pair，<strong>关键字成员类型是 const，不能被改变</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取一个迭代器</span><br><span class="hljs-keyword">auto</span> map_it = word_count.<span class="hljs-built_in">begin</span>();<br>cout &lt;&lt; map_it-&gt; first;     <span class="hljs-comment">// 打印此元素的关键字</span><br>cout &lt;&lt; map_it -&gt; second;   <span class="hljs-comment">// 打印此元素的值</span><br>map_it -&gt; first = <span class="hljs-string">&quot;new key&quot;</span>;    <span class="hljs-comment">// 错误，关键字是 const 的</span><br>++map_it -&gt; second;         <span class="hljs-comment">// 正确，可以通过迭代器改变元素的值</span><br></code></pre></td></tr></table></figure><h3 id="set-的迭代器是-const-的"><a href="#set-的迭代器是-const-的" class="headerlink" title="set 的迭代器是 const 的"></a>set 的迭代器是 const 的</h3><ul><li>set 容器同时定义了 iterator 和 const_iterator 类型，但两种类型都<strong>只允许只读访问 set 中的元素</strong></li><li>set 中的关键字也是 const 的，可以用一个迭代器来读取元素的值，但不能修改</li></ul><h3 id="关联容器和算法"><a href="#关联容器和算法" class="headerlink" title="关联容器和算法"></a>关联容器和算法</h3><ul><li>通常不对关联容器使用泛型算法</li><li>实际编程中，真要对关联容器使用算法，要么将它当做一个源序列，要么当做一个目的位置。</li></ul><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><h3 id="关联容器的-insert-操作"><a href="#关联容器的-insert-操作" class="headerlink" title="关联容器的 insert 操作"></a>关联容器的 insert 操作</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.insert(v) <br> c.emplace(args)</td><td>v 是 value_type 类型的对象，args 用来构造一个元素 <br> 对于 map 和 set，只有当元素不在容器中时才插入或构造。<strong>函数返回一个 pair</strong>，包含<strong>一个迭代器指向具有指定关键字的元素</strong>，和<strong>一个插入是否成功的 bool 值</strong> <br> 对于 multimap 和 multiset，总是插入或构造，并</td></tr><tr><td>c.insert(b, e) <br> c.insert(il)</td><td>b, e 是迭代器范围，表示一个 c::value_type 类型值的范围，il 是这种值的花括号列表 <br> 函数返回 void <br> 对于 map 和 set 只插入不在 c 中的元素；对于 multimap 和 multiset，将所有元素插入 c 中</td></tr><tr><td>c.insert(p, v) <br> c.emplace(p, args)</td><td>类似于 c.insert(v), 但将迭代器 p 作为一个提示，指出从哪里开始搜索新元素应该插入的位置。 <br> 返回一个迭代器，指向具有给定关键字的元素</td></tr></tbody></table></div><ul><li>向 map 中添加元素，必须记住 map 中的元素是 pair 类型</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 向 map 添加元素的四种方法</span><br>word_count.<span class="hljs-built_in">insert</span>(&#123;word, <span class="hljs-number">1</span>&#125;);<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(word, <span class="hljs-number">1</span>));<br>word_count.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">size_t</span>&gt; (word, <span class="hljs-number">1</span>));<br>word_count.<span class="hljs-built_in">insert</span>(map&lt;string, <span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">value_type</span>(word, <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><h3 id="检测-insert-返回值"><a href="#检测-insert-返回值" class="headerlink" title="检测 insert 返回值"></a>检测 insert 返回值</h3><ul><li>insert（或 emplace）的返回值依赖于容器类型和参数</li><li><strong>不包含重复元素的容器</strong> map 和 set，<strong>insert 返回一个 pair 对象</strong>，first 成员是一个指向包含给定关键字的元素的迭代器，second 成员是一个 bool 值，若容器已有该元素，返回 false，若没有，返回 true</li></ul><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.erase(k)</td><td>从 c 中删除每个关键字为 k 的元素。<br> <strong>返回一个 size_type 的值，指出删除元素的数量</strong></td></tr><tr><td>c.erase(p)</td><td>从 c 中删除 p 指定的元素。<br> <strong>p 必须指向一个真实元素，不能等于 c.end()</strong> <br> 返回 void，若 p 指向 c 中尾元素，则返回 c.end()</td></tr><tr><td>c.erase(b, e)</td><td>b, e 是一对迭代器，表示范围。<strong>返回 e</strong></td></tr></tbody></table></div><h2 id="map-的下标操作"><a href="#map-的下标操作" class="headerlink" title="map 的下标操作"></a>map 的下标操作</h2><ul><li>map 和 unordered_map 提供了下标和 at 操作</li><li>set 没有下标操作，因为 set 的关键字没有与之对应的值</li><li>multimap 和 unordered_multimap 也没有下标操作，因为它们的关键字有多个值与之对应</li><li>map 的下标操作可以搜索容器中没有的元素，<strong>当元素在容器中不存在时，会创建一个新元素</strong></li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c[k]</td><td>返回关键字为 k 的元素；若 k 不在容器中，添加一个关键字为 k 的元素，并对其进行值初始化</td></tr><tr><td>c.at(k)</td><td>访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出一个 out_of_range 异常</td></tr></tbody></table></div><h3 id="map-下标操作的返回值"><a href="#map-下标操作的返回值" class="headerlink" title="map 下标操作的返回值"></a>map 下标操作的返回值</h3><ul><li>一般情况下，下标操作和解引用迭代器的返回值是一样的</li><li><strong>map 下标操作的返回值是 mapped_type 对象</strong>，而<strong>解引用一个 map 的迭代器会返回一个 value_type 对象</strong></li></ul><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><h3 id="在一个容器中查找元素的操作"><a href="#在一个容器中查找元素的操作" class="headerlink" title="在一个容器中查找元素的操作"></a>在一个容器中查找元素的操作</h3><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>c.find(k)</strong></td><td>返回一个<strong>迭代器，指向第一个关键字为 k 的元素</strong>，若 k 不在容器中，则返回尾后迭代器</td></tr><tr><td><strong>c.count(k)</strong></td><td>返回关键字等于 k 的<strong>元素数量</strong>。对于不允许重复关键字的容器，返回值永远是 0 或 1</td></tr><tr><td><strong>c.lower_bound(k)</strong></td><td>返回一个迭代器，指向<strong>第一个关键字不小于 k 的元素</strong></td></tr><tr><td><strong>c.upper_bound(k)</strong></td><td>返回一个迭代器，指向<strong>第一个关键字大于 k 的元素</strong></td></tr><tr><td><strong>c.equal_range(k)</strong></td><td><strong>返回一个迭代器 pair，表示关键字等于 k 的元素范围</strong>。<br> <strong>若 k 不存在，pair 的两个成员均等于 c.end()</strong></td></tr></tbody></table></div><ul><li><strong>lower_bound 和 upper_bound 操作不适用于无序容器</strong></li><li><strong>下标和 at</strong> 操作<strong>只适用于非 const 的</strong> map 和unordered_map</li><li>只想知道元素是否在 map 中，而不想改变 map，应该使用 find</li><li>在 <strong>multimap</strong> 和 <strong>multiset</strong> 中，<strong>重复元素是相邻存储的</strong></li><li><strong>lower_bound</strong> 返回的迭代器<strong>可能指向具有给定关键字的元素，但也可能不指向</strong>。</li></ul><h3 id="equal-range-函数"><a href="#equal-range-函数" class="headerlink" title="equal_range 函数"></a>equal_range 函数</h3><ul><li>此函数接受一个关键字，返回一个迭代器 pair 。</li><li>若关键字存在，则<strong>第一个迭代器指向第一个与关键字相匹配的元素</strong>，<strong>第二个迭代器指向最后一个匹配元素之后的位置</strong>；若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置</li></ul><h2 id="一个单词转换的-map"><a href="#一个单词转换的-map" class="headerlink" title="一个单词转换的 map"></a>一个单词转换的 map</h2><p>题目：给定一个 string，将它转换为另一个 string。程序的输入是两个文件。第一个文件保存的是一些规则，用来转换第二个文件的文本。每条规则由两部分组成：一个可能出现在输入文件中的单词，和一个用来替换它的短语。表达的含义是：每当第一个单词出现在输入中时，我们就将它替换为相应的短语。第二个文件包含要转换的文本。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">transform</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str, <span class="hljs-type">const</span> std::map&lt;std::string, std::string&gt; &amp;map)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> map_it = map.<span class="hljs-built_in">find</span>(str);<br>    <span class="hljs-keyword">if</span> (map_it != map.<span class="hljs-built_in">end</span>())<br>        <span class="hljs-keyword">return</span> map_it-&gt;second;     <span class="hljs-comment">// 返回转换后的 string</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> str;     <span class="hljs-comment">// 返回原 string</span><br>&#125;<br><br><span class="hljs-function">std::map&lt;std::string, std::string&gt; <span class="hljs-title">buildMap</span><span class="hljs-params">(std::ifstream &amp; map_file)</span> </span>&#123;<br>    std::map&lt;std::string, std::string&gt; trans_rule;<br>    std::string word, sentence;<br>    <span class="hljs-keyword">while</span> (map_file &gt;&gt; word &amp;&amp; std::<span class="hljs-built_in">getline</span>(map_file, sentence)) &#123;<br>        <span class="hljs-keyword">if</span> (sentence.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)        <span class="hljs-comment">// 检查是否有转换规则</span><br>            trans_rule[word] = sentence.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 跳过空格</span><br><span class="hljs-comment">//            trans_rule.insert(&#123;word, sentence.substr(1)&#125;);</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;no rule for &quot;</span> + word);<br>    &#125;<br>    <span class="hljs-keyword">return</span> trans_rule;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">word_transform</span><span class="hljs-params">(std::ifstream &amp; map_file, std::ifstream &amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> trans_map = <span class="hljs-built_in">buildMap</span>(map_file);<br>    std::string text;       <span class="hljs-comment">// 保存输入的每行文本</span><br>    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(input, text)) &#123;<br>        <span class="hljs-function">std::istringstream <span class="hljs-title">stream</span><span class="hljs-params">(text)</span></span>;<br>        std::string word;<br>        <span class="hljs-type">bool</span> firstword = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// 控制是否打印空格</span><br>        <span class="hljs-keyword">while</span> (stream &gt;&gt; word) &#123;<br>            <span class="hljs-keyword">if</span> (firstword)<br>                firstword = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-comment">// transform 返回它的第一个参数或者抓换后的形式</span><br>            std::cout &lt;&lt; <span class="hljs-built_in">transform</span>(word, trans_map);<br>        &#125;<br>        std::cout &lt;&lt; std::endl;     <span class="hljs-comment">// 完成一行转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 关联容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.2 关联容器概述</title>
      <link href="/2025/04/07/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.2%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/04/07/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.2%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>关联容器不支持顺序容器的位置相关操作，如 push_back，push_front</li><li>关联容器不支持构造函数或插入 操作这些接受一个元素值和一个数量值的操作</li><li>关联容器的迭代器都是双向的</li></ul><h2 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">map&lt;string, <span class="hljs-type">size_t</span>&gt; word_count; <span class="hljs-comment">// 空容器</span><br><span class="hljs-comment">// 列表初始化</span><br>set&lt;string&gt; exclude = &#123;<span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-string">&quot;but&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;or&quot;</span>&#125;;<br>map&lt;string, string&gt; authors = &#123; &#123;<span class="hljs-string">&quot;Joyce&quot;</span>, <span class="hljs-string">&quot;James&quot;</span>&#125;,<br>                                &#123;<span class="hljs-string">&quot;Austen&quot;</span>, <span class="hljs-string">&quot;Jane&quot;</span>&#125;,<br>                                &#123;<span class="hljs-string">&quot;Dickens&quot;</span>, <span class="hljs-string">&quot;Charles&quot;</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><ul><li>还可以使用另外一个同类型容器的拷贝来初始化关联容器</li></ul><h2 id="关键字类型的要求"><a href="#关键字类型的要求" class="headerlink" title="关键字类型的要求"></a>关键字类型的要求</h2><ul><li>有序容器 map, multimap, set, multiset 必须定义关键字比较类型，默认使用 <code>&lt;</code> 运算符</li><li>传递给排序算法的<strong>可调用对象</strong>必须满足与关联容器中关键字一样的类型要求</li></ul><h3 id="有序容器的关键字类型"><a href="#有序容器的关键字类型" class="headerlink" title="有序容器的关键字类型"></a>有序容器的关键字类型</h3><ul><li>可以<strong>自定义比较操作</strong>来代替关键字的 <code>&lt;</code> 运算符</li><li>所提供的操作必须在关键字类型上定义一个<strong>严格弱序(strict weak ordering)</strong>, 可以将严格弱序看做<strong>小于等于</strong></li><li>如果一个类型定义了 <code>&lt;</code> 运算符，则它可以用作关键字类型</li></ul><h3 id="使用关键字类型的比较函数"><a href="#使用关键字类型的比较函数" class="headerlink" title="使用关键字类型的比较函数"></a>使用关键字类型的比较函数</h3><ul><li>自定义的操作类型必须在 <code>&lt;&gt;</code> 中紧跟着元素类型给出</li><li><code>&lt;&gt;</code>中的类型仅仅是类型，当创建容器对象时，才会以构造函数形式真正提供比较操作 <strong>(其类型必须与 <code>&lt;&gt;</code> 中提供的类型相吻合)</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareISBN</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp; lhs, <span class="hljs-type">const</span> Sale_data &amp; rhs)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() &lt; rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// bookstore 中多条记录可以有相同的 ISBN</span><br><span class="hljs-comment">// bookstore 中的元素以 ISBN 的顺序进行排序</span><br><span class="hljs-function">std::multiset&lt;Sale_data, <span class="hljs-title">decltype</span><span class="hljs-params">(compareISBN)</span> * &gt;</span><br><span class="hljs-function">        <span class="hljs-title">bookstore</span><span class="hljs-params">(compareISBN)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><strong><code>decltype</code> 返回函数类型</strong>，而不是函数指针类型，<strong>显式的加上 <code>*</code> 表明需要指针</strong>，而不是函数本身</li><li>compareISBN 作为参数初始化 bookstore，表示在向 bookstore 添加元素时，调用 compareISBN 来排序元素</li><li>当直接使用函数名时，<strong>在需要的情况下会自动转换为指针</strong>，等价于使用 <code>&amp;compareISBN</code></li></ul><h2 id="pair-类型"><a href="#pair-类型" class="headerlink" title="pair 类型"></a>pair 类型</h2><ul><li>定义在头文件 <strong>utility</strong> 中</li><li>pair 有两个 <strong>public</strong> 数据成员： <strong>first，second</strong>。是一个模板类型，创建 pair 对象时要提供两个类型名</li><li>默认构造函数对 pair 进行值初始化</li><li>也可以对每个成员提供初始化器</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>pair <T1, T2> p</td><td>p 是一个 pair 对象，两个类型为 T1，T2 的成员进行了值初始化</td></tr><tr><td>pair <T1, T2> p(v1, v2)</td><td>pair 的 first 和 second 成员分别用 v1, v2 进行初始化</td></tr><tr><td>pair <T1, T2> p = {v1, v2}</td><td>等价于 p(v1, v2)</td></tr><tr><td><strong>make_pair(v1, v2)</strong></td><td>返回一个用 v1,v2 初始化的 pair 对象。pair 的类型从 v1, v2 的类型推断出来</td></tr><tr><td>p.first</td><td>返回 pair 的 first 成员</td></tr><tr><td>p.second</td><td>返回 pair 的 second 成员</td></tr><tr><td>p1 <strong>relop</strong> p2</td><td>关系运算符，<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>。当 <code>p1.first &lt; p2.first &amp;&amp; p1.second &lt; p2.second</code> 时，<strong>p1 &lt; p2 为 true</strong></td></tr><tr><td>p1 == p2 <br> p1 != p2</td><td>当 first 和 second 成员分别相等时，两个 pair 相等</td></tr></tbody></table></div><h3 id="创建-pair-对象的函数"><a href="#创建-pair-对象的函数" class="headerlink" title="创建 pair 对象的函数"></a>创建 pair 对象的函数</h3><ul><li>新标准下，可以对返回值进行列表初始化</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;string, <span class="hljs-type">int</span>&gt;</span><br><span class="hljs-function"><span class="hljs-title">process</span><span class="hljs-params">( vector&lt;string&gt; &amp;v)</span> </span>&#123;<br>    <span class="hljs-comment">// process v</span><br>    <span class="hljs-keyword">if</span>(!v.<span class="hljs-built_in">empty</span>()) <br>        <span class="hljs-keyword">return</span> &#123; v.<span class="hljs-built_in">back</span>(), v.<span class="hljs-built_in">size</span>() &#125;;  <span class="hljs-comment">// 列表初始化</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pair</span>&lt;string, <span class="hljs-type">int</span>&gt; ();    <span class="hljs-comment">// 隐式构造返回值</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 关联容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.1 使用关联容器</title>
      <link href="/2025/04/05/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.1%20%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
      <url>/2025/04/05/11.%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/11.1%20%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>标准库提供 8 个关联容器，它们的不同体现在：<ul><li>是 <strong>map</strong> 还是 <strong>set</strong></li><li><strong>关键字是否可以重复</strong>：可以重复的容器名含有 <strong>multi</strong>;</li><li><strong>容器元素是否有序保存</strong>：无序容器名以 <strong>unordered</strong> 开头</li></ul></li><li><strong>map</strong> 和 <strong>multimap</strong> 定义在头文件 <strong>map</strong> 中</li><li><strong>set</strong> 和 <strong>multiset</strong> 定义在头文件 <strong>set</strong> 中</li><li><p><strong>无序容器</strong>定义在头文件 <strong>unordered_map</strong> 和 <strong>unordered_set</strong> 中</p></li><li><p>按<strong>关键字有序</strong>保存元素：</p><p>  | Class | Description |<br>  | —- | —- |<br>  | <strong>map</strong> | 关联数组，保存<strong>关键字-值</strong>对 |<br>  | <strong>set</strong> | 关键字即值，即<strong>只保存关键字</strong>的容器 |<br>  | <strong>multimap</strong> | 关键字可重复出现的 map |<br>  | <strong>multiset</strong> | 关键字可重复出现的 set |</p></li><li><p><strong>关键字无序</strong>集合</p><p>  | Class | Description |<br>  | —- | —- |<br>  | <strong>unordered_map</strong> | 用 hash 函数组织的 map |<br>  | <strong>unordered_set</strong> | 用 hash 函数组织的 set |<br>  | <strong>unordered_multimap</strong> | hash 组织的 map：关键字可重复出现 |<br>  | <strong>unordered_multiset</strong> | hash 组织的 set：关键字可重复出现 |</p></li></ul><h2 id="使用-map"><a href="#使用-map" class="headerlink" title="使用 map"></a>使用 map</h2><ul><li>关联容器是模板，定义 map 必须指明<strong>关键字和值的类型</strong></li><li>map 被称为<strong>关联数组</strong>，使用 map，是<strong>用关键字作为下标</strong>：<code>word_count[word]</code>, word 为关键字；当 word 不在 map 中时，<strong>下标运算符会创建一个新元素</strong>，新元素关键字值是 word</li><li><strong>从 map 中提取</strong>一个元素，会得到一个 <strong>pair 类型对象</strong>。pair 是模板类型，有两个 public 成员： <strong>first 和 second</strong>。map 使用的 pair 用 <strong>first 保存 关键字</strong>，用 <strong>second 保存对应的值</strong></li></ul><h2 id="使用-set"><a href="#使用-set" class="headerlink" title="使用 set"></a>使用 set</h2><ul><li>可以对一个关联容器的元素进行<strong>列表初始化</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 关联容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2 访问控制与封装</title>
      <link href="/2025/04/02/7.%20%E7%B1%BB/7.2%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85/"/>
      <url>/2025/04/02/7.%20%E7%B1%BB/7.2%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>使用 <strong>访问说明符(access specifiers)</strong>加强类的封装：</p><ul><li><strong>public</strong>: public 成员在<strong>整个程序内可访问</strong>，public 成员定义类的接口</li><li><strong>private</strong>: private 成员可以被<strong>类的成员函数访问</strong>，但<strong>不能被使用该类的代码访问</strong>，private 部分封装了类的实现细节</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span> (std::istream &amp;);<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> units_sold ? revenue / units_sold : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>struct</strong> 定义类：在第一个访问说明符之前的成员是 <strong>public</strong></li><li><strong>class</strong> 定义了：在第一个访问说明符之前的成员是 <strong>private</strong></li></ul><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>类允许其他类或函数访问非公有成员的方法是<strong>友元(friend)</strong>, 使用 <strong>friend</strong> 关键字可将函数或类声明为<strong>友元</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 为 Sale_data 的非成员函数做友元声明</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span> (std::istream &amp;);<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">return</span> units_sold ? revenue / units_sold : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br><br><span class="hljs-comment">// Sale_data 的非成员接口函数</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>一般在类定义开始或结束时定义友元</li><li>友元函数的声明<strong>不是</strong>通常意义的<strong>函数声明</strong>，在进行友元声明之后<strong>需对函数进行一次专门的声明</strong></li></ul><h2 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h2><ul><li>确保用户代码不会无意间破坏封装对象的状态</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级代码<ul><li>只要类的接口，用户代码就无需改变</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 封装 </tag>
            
            <tag> 访问控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.4 再探迭代器</title>
      <link href="/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.4%20%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.4%20%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在头文件 iterator 中还定义了额外的迭代器</p><ul><li>插入迭代器(insert iterator)：可用来向容器插入元素</li><li>流迭代器(stream iterator): 可用来遍历所关联的流</li><li>反向迭代器(reverse iterator)</li><li>移动迭代器(move iterator)</li></ul><h2 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h2><ul><li><strong>back_inserter</strong>: 创建一个使用 <strong>push_back</strong> 的迭代器</li><li><strong>front_inserter</strong>: 创建一个使用 <strong>push_front</strong> 的迭代器， <strong>只有在容器支持 push_front 的情况下</strong>才可以使用 front_inserter</li><li><strong>inserter</strong>: 创建一个使用 <strong>insert</strong> 的迭代器。此函数接受第二个参数，<strong>第二个参数必须是指向给定容器的迭代器</strong>。被插元素将<strong>插入到给定迭代器指向的元素之前</strong></li><li>操作：<ul><li><code>it = t</code> 在 it 指定的当前位置插入值 t。</li><li><em>it, ++it, it++ 虽然都存在，但是不会对 it 做任何操作。<em>*每个操作都返回 it</em></em></li></ul></li><li><p>调用 inserter(c, iter), 得到一个迭代器 it, 使用这个新迭代器将新元素插入到 iter 指定的元素之前</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">*it = val;<br></code></pre></td></tr></table></figure><ul><li>等价于：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">it = c.<span class="hljs-built_in">insert</span>(it, val);   <span class="hljs-comment">// it 指向新插入元素</span><br>++it;   <span class="hljs-comment">// 递增 it 使它指向原来的元素</span><br></code></pre></td></tr></table></figure></li><li><p>调用 front_inserter，新元素总是插入到容器的第一个元素之前</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; lst&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>list&lt;<span class="hljs-type">int</span>&gt; lst2, lst3;<br><br><span class="hljs-comment">// 拷贝完成后，lst2 包含元素 4,3,2,1</span><br><span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">begin</span>(), lst.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">front_inserter</span>(lst2));<br><br><span class="hljs-comment">// 拷贝完成后，lst3 包含元素 1,2,3,4</span><br><span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">begin</span>(), lst.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">inserter</span>(lst3, lst<span class="hljs-number">3.</span><span class="hljs-built_in">begin</span>()))<br></code></pre></td></tr></table></figure><h2 id="iostream-迭代器"><a href="#iostream-迭代器" class="headerlink" title="iostream 迭代器"></a>iostream 迭代器</h2><ul><li>istream_iterator: 读取输入流</li><li>ostream_iterator: 向输出流写数据</li></ul><h3 id="istream-iterator-操作"><a href="#istream-iterator-操作" class="headerlink" title="istream_iterator 操作"></a>istream_iterator 操作</h3><ul><li>将 <strong>istream_iterator</strong> <strong>绑定到一个流</strong></li><li>默认初始化 istream_iterator，相当于 <strong>尾后迭代器</strong></li><li><p>istream_iterator 更有用的地方在于：<strong>可以使用迭代器范围，从输入流获取元素构造容器</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">int_it</span><span class="hljs-params">(cin)</span>, eof</span>; <span class="hljs-comment">// 从 cin 读取</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(int_it, eof)</span></span>;      <span class="hljs-comment">// 用迭代器范围构造 vec</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用算法操作流迭代器"><a href="#使用算法操作流迭代器" class="headerlink" title="使用算法操作流迭代器"></a>使用算法操作流迭代器</h4><ul><li>示例</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">istream_itertor&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">int_it</span><span class="hljs-params">(cin)</span>, eof</span>;<br>std::cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(int_it, eof, <span class="hljs-number">0</span>) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h4 id="istream-iterator-允许使用懒惰求值"><a href="#istream-iterator-允许使用懒惰求值" class="headerlink" title="istream_iterator 允许使用懒惰求值"></a>istream_iterator 允许使用懒惰求值</h4><ul><li>当 istream_iterator 绑定到一个流，标准库并<strong>不保证迭代器立即从流读取数据</strong>，使用迭代器时才真正读取</li><li>标准库保证在<strong>第一次使用解引用迭代器之前</strong>，从流中<strong>读取数据的操作已经完成</strong></li></ul><h3 id="ostream-iterator-操作"><a href="#ostream-iterator-操作" class="headerlink" title="ostream_iterator 操作"></a>ostream_iterator 操作</h3><ul><li>在创建 ostream_iterator 时，可以提供（可选的）第二参数，是字符串，在<strong>输出每个元素后都会打印此字符串</strong>。此字符串必须是一个 <strong>C 风格字符串</strong>，</li><li><p><strong>必须将 ostream_iterator 绑定到一个指定的流</strong>，<strong>不允许</strong>一个<strong>空的</strong>或<strong>表示尾后位置</strong>的 ostream_iterator</p><ul><li>ostream_iterator<T> out(cout);</li><li><strong><code>out = val;</code></strong>  // 用 &lt;&lt; 运算符将 val 写入到 out 绑定的 ostream 中, val 类型必须与 out 可写类型兼容</li><li><code>*out, out++, ++out</code> 都存在，但不对 out 做任何操作。每个运算符都返回 out</li><li><p>对于一个输出容器元素的循环，可以写为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out</span><span class="hljs-params">(cout, <span class="hljs-string">&quot; &quot;</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; item: vec)<br>  out = item;<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>可以通过 copy 来打印元素，比循环更简单</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">copy</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), out);<br>cout &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="使用流迭代器处理类类型"><a href="#使用流迭代器处理类类型" class="headerlink" title="使用流迭代器处理类类型"></a>使用流迭代器处理类类型</h3><ul><li>可以为任何定义了 <code>&gt;&gt;</code> 的类型创建 istream_iterator</li><li>为任何定义了 <code>&lt;&lt;</code> 的类型创建 ostream_iterator</li></ul><h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><ul><li><strong>从尾元素向首元素反向移动</strong></li><li><code>++it</code> 操作会<strong>移动到前一个</strong>元素</li><li><code>--it</code> 操作会<strong>移动到后一个</strong>元素</li><li><strong>除 forward_list 之外</strong>，其他容器都支持反向迭代器</li></ul><h3 id="反向迭代器与普通迭代器的关系"><a href="#反向迭代器与普通迭代器的关系" class="headerlink" title="反向迭代器与普通迭代器的关系"></a>反向迭代器与普通迭代器的关系</h3><ul><li>对于一个 string 元素 “WORD””，使用<strong>普通迭代器输出</strong>为：<strong>“WORD”</strong> ；使用<strong>反向迭代器</strong>输出为 <strong>“DROW”</strong></li><li>反向迭代器的<strong>目的是表示元素范围</strong>，这些范围与普通迭代器指向的范围并不对称</li><li>调用 base() 将反向迭代器转换为普通迭代器</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.6 特定容器算法</title>
      <link href="/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.6%20%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.6%20%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>list</strong> 和 <strong>forward_list</strong> 定义了几个成员函数形式的算法</li><li>特别是定义了<strong>独有的 sort, merge, remove, reverse, unique</strong></li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td><strong>lst.merge(lst2)</strong> <br> <strong>lst.merge(lst2, comp)</strong></td><td>将 lst2 中的元素合并入 lst 中。要求两个链表<strong>必须有序</strong> <br> 元素从 lst2 中被删除，合并之后 lst2 变为空 <br> 第一个版本使用 <code>&lt;</code> 运算符，第二个版本使用给定的比较操作 comp</td></tr><tr><td><strong>lst.remove(val) <br> lst.remove_if(pred)</strong></td><td>调用 erase 删除<strong>与给定值 (val) 相等</strong>或<strong>令谓词 (pred) 为真</strong>的每个元素</td></tr><tr><td><strong>lst.reverse()</strong></td><td>翻转 lst 中元素的顺序</td></tr><tr><td><strong>lst.sort() <br> lst.sort(pred)</strong></td><td>使用 <code>&lt;</code> 或给定比较操作排序元素</td></tr><tr><td><strong>lst.unique() <br> lst.unique(pred)</strong></td><td>调用 erase 删除同一个值的拷贝。<br> 第一个版本使用 <strong><code>==</code></strong>, 第二个版本使用给定的<strong>二元谓词</strong></td></tr></tbody></table></div><ul><li>所有操作都返回 void</li></ul><h2 id="splice-成员"><a href="#splice-成员" class="headerlink" title="splice 成员"></a>splice 成员</h2><ul><li>此算法是<strong>链表结构所特有的</strong></li><li>调用形式有： <strong><code>lst.splice(args)</code></strong> 或 <strong><code>flst.splice_after(args)</code></strong></li><li><p>args 的形式：</p><p>  | Arguments | Description |<br>  | —- | —- |<br>  | <strong>(p, lst2)</strong> | p 是指向 lst 中元素的迭代器，或是一个指向 flst 首前位置的迭代器 <br> 函数将 lst2 中的元素 <strong>lst 中 p 之前</strong>的位置或 <strong>flst 中 p 之后</strong>的位置。将元素从 lst2 中删除 <br> lst2 必须与lst 或 flst <strong>类型相同且不能是同一个链表</strong> |<br>  | <strong>(p, lst2, p2)</strong> | p2 是指向 lst2 中位置的有效迭代器 <br> 将 <strong>p2 指向的元素移动到 lst</strong> 中，或是将 <strong>p2 之后的元素移动到 flst 中</strong> <br> <strong>lst2 可以是与 lst 或 flst 相同的链表</strong> |<br>  | <strong>(p, lst2, b, e)</strong> | b, e 必须表示 lst2 的合法范围 <br> 将给定范围的元素从 lst2 移动到 lst 或 flst。<br> <strong>lst2 与 lst(或 flst) 可以是相同的链表</strong>，但 <strong>p 不能指向b, ef范围内的元素</strong> |</p></li></ul><h2 id="链表特有的操作会改变容器"><a href="#链表特有的操作会改变容器" class="headerlink" title="链表特有的操作会改变容器"></a>链表特有的操作会改变容器</h2>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
            <tag> 特定容器算法 </tag>
            
            <tag> list 特定算法 </tag>
            
            <tag> forward_list 特定算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.5 泛型算法结构</title>
      <link href="/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.5%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84/"/>
      <url>/2025/04/02/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.5%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<ul><li>任何算法最基本特性就是它要求其迭代器做哪些操作</li><li>每个算法对它的每个迭代器参数指明需要提供哪类迭代器</li></ul><h2 id="五类迭代器"><a href="#五类迭代器" class="headerlink" title="五类迭代器"></a>五类迭代器</h2><ul><li>算法所要求的迭代器分为五类：<ul><li><strong>输入迭代器</strong>：<strong>只读不写</strong>、单遍扫描、<strong>只能递增</strong></li><li><strong>输出迭代器</strong>：<strong>只写不读</strong>、单遍扫描、<strong>只能递增</strong></li><li><strong>前向迭代器</strong>：<strong>可读写</strong>、多遍扫描、<strong>只能递增</strong></li><li><strong>双向迭代器</strong>：<strong>可读写</strong>、多遍扫描、<strong>可递增可递减</strong></li><li><strong>随机访问迭代器</strong>：<strong>可读写</strong>、多遍扫描、<strong>支持全部迭代器操作</strong></li></ul></li></ul><h3 id="输入迭代器-input-iterator"><a href="#输入迭代器-input-iterator" class="headerlink" title="输入迭代器(input iterator)"></a>输入迭代器(input iterator)</h3><ul><li>可以读取序列中的元素</li><li>支持操作：<ul><li><code>==</code> <code>!=</code> 比较两个迭代器的相等与不相等</li><li><code>++</code> 递增运算</li><li><code>*</code> 解引用运算符：<strong>只会出现在赋值运算符右侧</strong></li><li><code>-&gt;</code> 箭头运算符：等价于 <code>(*it).member</code>，解引用迭代器，并调用对象成员</li></ul></li><li><strong>只用于顺序访问</strong></li><li>单遍扫描</li><li>递增输入迭代器可能导致其他指向流的迭代器失效</li></ul><h3 id="输出迭代器-output-iterator"><a href="#输出迭代器-output-iterator" class="headerlink" title="输出迭代器(output iterator)"></a>输出迭代器(output iterator)</h3><ul><li>只写而不读元素</li><li>支持操作<ul><li><code>++</code></li><li><code>*</code> 解引用运算符，<strong>只出现在赋值运算符的左侧</strong>（向一个解引用的输出迭代器赋值，就是将值写入它所指向的元素）</li></ul></li><li>只能向一个输出迭代器赋值一次；</li><li>单遍扫描</li><li>通常用作目的位置迭代器</li></ul><h3 id="前向迭代器-forward-iterator"><a href="#前向迭代器-forward-iterator" class="headerlink" title="前向迭代器(forward iterator)"></a>前向迭代器(forward iterator)</h3><ul><li>可读写元素</li><li>只能在序列中延一个方向移动</li><li>支持所有输入迭代器和输出迭代器的操作</li><li>可多次读写同一元素</li><li>可以保存迭代器状态，可对序列进行多遍扫描，forward_list 上的迭代器都是前向迭代器</li></ul><h3 id="双向迭代器-bidirectional-iterator"><a href="#双向迭代器-bidirectional-iterator" class="headerlink" title="双向迭代器(bidirectional iterator)"></a>双向迭代器(bidirectional iterator)</h3><ul><li>可以正向/反向读写元素</li><li>支持所有前向迭代器的操作，还支持 <code>--</code> 递减运算符，除 forward_list 之外，其他容器都提供双向迭代器</li></ul><h3 id="随机访问迭代器-random-access-iterator"><a href="#随机访问迭代器-random-access-iterator" class="headerlink" title="随机访问迭代器(random-access iterator)"></a>随机访问迭代器(random-access iterator)</h3><ul><li>在常量时间内访问序列中的任何元素</li><li>支持所有双向迭代器的所有功能，还支持：<ul><li><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></li><li><strong>迭代器和一个数值</strong>的加减操作：<code>+</code> <code>+=</code> <code>-</code> <code>-=</code> : 计算结果是迭代器在序列中前进(或后退)给定整数个元素后的位置</li><li>两个迭代器的减法运算符：<code>-</code>，得到两个迭代器的距离</li><li>下表运算符(<code>iter[n]</code>)，与 <code>*(iter[n])</code> 等价</li></ul></li></ul><h2 id="算法形参形式"><a href="#算法形参形式" class="headerlink" title="算法形参形式"></a>算法形参形式</h2><h3 id="接受单个目标迭代器的算法"><a href="#接受单个目标迭代器的算法" class="headerlink" title="接受单个目标迭代器的算法"></a>接受单个目标迭代器的算法</h3><ul><li>向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据</li></ul><h3 id="接受第二个输入序列的算法"><a href="#接受第二个输入序列的算法" class="headerlink" title="接受第二个输入序列的算法"></a>接受第二个输入序列的算法</h3><ul><li>这类算法通常将两个输入序列中的元素结合进行操作</li></ul><h2 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h2><h3 id="重载形式传递谓词"><a href="#重载形式传递谓词" class="headerlink" title="重载形式传递谓词"></a>重载形式传递谓词</h3><ul><li>函数名称相同，参数数量不同</li></ul><h3 id="if-版本的算法"><a href="#if-版本的算法" class="headerlink" title="_if 版本的算法"></a>_if 版本的算法</h3><ul><li>函数名称不同，参数数量相同</li></ul><h3 id="区分拷贝元素的版本和不拷贝元素的版本"><a href="#区分拷贝元素的版本和不拷贝元素的版本" class="headerlink" title="区分拷贝元素的版本和不拷贝元素的版本"></a>区分拷贝元素的版本和不拷贝元素的版本</h3><ul><li>大多在算法名后加 <strong><code>_copy</code></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 泛型算法结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.1 泛型算法概述</title>
      <link href="/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.1%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
      <url>/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.1%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>大多数算法在 algorithm 头文件中</li><li>numeric 头文件中有一组数值泛型算法</li><li>一般，算法<strong>不直接操作容器</strong>，而是遍历由<strong>两个迭代器指定范围</strong>内的元素来进行操作</li></ul><h2 id="迭代器算法不依赖于容器"><a href="#迭代器算法不依赖于容器" class="headerlink" title="迭代器算法不依赖于容器"></a>迭代器算法不依赖于容器</h2><ul><li>使用<strong>迭代器解引用运算符</strong>实现元素访问</li><li><strong>返回</strong>指向匹配元素的<strong>迭代器</strong></li></ul><h2 id="算法依赖于元素类型的操作"><a href="#算法依赖于元素类型的操作" class="headerlink" title="算法依赖于元素类型的操作"></a>算法依赖于元素类型的操作</h2><ul><li>大多数算法都使用一个或多个元素类型上的操作</li></ul><h2 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h2><ul><li>算法永远不会改变底层容器的大小</li><li>算法可能改变容器内元素的值，但永远不会直接添加或删除元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.2 认识泛型算法</title>
      <link href="/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.2%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
      <url>/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.2%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>重点了解算法是否<strong>读取元素、改变元素、重排元素</strong></li></ul><hr><h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><h3 id="算法和元素类型"><a href="#算法和元素类型" class="headerlink" title="算法和元素类型"></a>算法和元素类型</h3><ul><li>只读取输入范围内元素，而不改变元素</li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>find(b, e, val)</strong></td><td>在容器中搜索给定值 <br> b,e 是表示范围的迭代器，val 是给定的一个值 <br> <strong>返回</strong>指向第一个等于给定值的元素的<strong>迭代器</strong></td></tr><tr><td><strong>accumulate(b, e, val)</strong></td><td><strong>第三个参数</strong> val <strong>决定</strong>了函数中使用哪个<strong>加法运算符</strong>以及<strong>函数返回值类型</strong></td></tr></tbody></table></div><ul><li><p>accumulate 示例</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对 vector 中元素求和，和的初值是 0</span><br><span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">cbegin</span>(), vec.<span class="hljs-built_in">cend</span>(), <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将 vector 中 string 元素拼接起来, sum 初值为空串</span><br>string sum = <span class="hljs-built_in">accumulate</span>(vec.<span class="hljs-built_in">cbegin</span>(), vec.<span class="hljs-built_in">cend</span>(), <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure><ul><li>accumulate 第三个参数若是空字符串，<strong>不能是 <code>&quot;&quot;</code>(字符串字面值)</strong>。第三个参数类型决定使用哪个+运算，但字符串字面值类型是 <strong>const char*, 这个类型并没有 + 运算</strong></li></ul></li></ul><h3 id="操作两个序列的算法"><a href="#操作两个序列的算法" class="headerlink" title="操作两个序列的算法"></a>操作两个序列的算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>equal(b1, e1, b2)</strong></td><td>b1,e1 表示第一个序列中的元素范围 <br> b2 指向第二个序列的首元素</td></tr></tbody></table></div><ul><li><strong>equal</strong>：用于确定两个序列是否保存相同的值</li><li>由于 equal 是利用迭代器完成操作，因此可以通过 <strong>equal 比较两个不同类型容器中的元素</strong>，而且元<strong>素类型也可以不一样</strong>，只要这两个元素类型可以使用 <code>==</code> 来比较既可</li><li>equal <strong>假定第二个序列至少与第一个序列一样长</strong></li><li>只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长</li></ul><hr><h2 id="写容器元素算法"><a href="#写容器元素算法" class="headerlink" title="写容器元素算法"></a>写容器元素算法</h2><ul><li>使用这类算法必须注意：<strong>确保序列原大小至少不小于</strong>要求算法写入的元素数目</li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>fill(b, e, val)</strong></td><td>将 val 的值赋予输入序列的每一个元素</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 将每个元素重置为 0</span><br><span class="hljs-built_in">fill</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>); <br><span class="hljs-comment">// 将容器的一个子序列设置为 10</span><br><span class="hljs-built_in">fill</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">begin</span>() + vec.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h3 id="算法不检查写操作"><a href="#算法不检查写操作" class="headerlink" title="算法不检查写操作"></a>算法不检查写操作</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>fill_n(b, n, val)</strong></td><td>将 val 赋予 迭代器 b 指向位置开始的 n 个元素</td></tr></tbody></table></div><ul><li><p>向<strong>空容器</strong>写入值要注意：</p><ul><li><p>合法操作：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空容器</span><br><span class="hljs-built_in">fill_n</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>非法操作</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空容器</span><br><span class="hljs-built_in">fill_n</span>(vec.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>向容器<strong>写入指定数量</strong>的值时要注意，<strong>容器是否有足够的空间</strong>来容纳这些数量的值</p></li></ul><h3 id="back-inserter"><a href="#back-inserter" class="headerlink" title="back_inserter"></a>back_inserter</h3><ul><li><strong>插入迭代器(insert iterator)</strong>: 向容器中添加元素的迭代器。保证算法有足够的空间来容纳输出数据</li><li>back_inserter <strong>接受一个指向容器的引用</strong>，<strong>返回</strong>一个与该容器绑定的<strong>插入迭代器</strong></li><li><p>常使用 back_inserter 创建一个迭代器，作为算法的目的位置</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec;   <span class="hljs-comment">// 空容器</span><br><span class="hljs-built_in">fill_n</span>(<span class="hljs-built_in">back_inserter</span>(vec), <span class="hljs-number">10</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 向空容器 vec 添加 10 个 值为 0 的元素</span><br></code></pre></td></tr></table></figure><ul><li>由于传入的是 back_inserter 返回的迭代器，所以每次赋值都会在 vector 上调用 push_back</li></ul></li></ul><h3 id="拷贝算法"><a href="#拷贝算法" class="headerlink" title="拷贝算法"></a>拷贝算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>copy(b1, e1, b2)</strong></td><td>b1, e1 表示输入范围 <br> b2 表示目的序列的起始位置 <br> 此算法将输入范围的元素拷贝到目的序列中<br> 返回目的位置迭代器（递增后）的值</td></tr></tbody></table></div><ul><li><p>传递给 copy 的<strong>目的序列至少要包含与输入范围同样多的元素</strong></p><ul><li><p>用 copy 实现内置数组的拷贝</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a1[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> a2[<span class="hljs-built_in">sizeof</span>(a1) / <span class="hljs-built_in">sizeof</span>(*a1)];       <span class="hljs-comment">// 保证 a2 与 a1 大小一样</span><br><span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>(a1), <span class="hljs-built_in">end</span>(a1), a2);<br></code></pre></td></tr></table></figure></li><li><p>ret 指向 a2 尾元素之后的位置</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>replace(b, e, oldVal, newVal)</strong></td><td>b,e 迭代器表示输入范围 <br> oldVal 是要搜索的值，newVal 是新值 <br> 算法将输入序列中所有等于 oldVal 的元素替换为 newVal</td></tr></tbody></table></div><ul><li>如果希望保持原序列不变，可以调用 <strong>replace_copy</strong>, 此算法接受第三个迭代器参数，指向调整后序列的保存位置</li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>replace_copy(b, e, b2, oldVal, newVal)</strong></td><td>其他参数含义不变 <br> b2 表示调整后序列的保存位置</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">replace</span>(ilst.<span class="hljs-built_in">begin</span>(), ilst.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);   <span class="hljs-comment">// 将 ilst 中值为 0 的元素值替换为42</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ilst 不变</span><br><span class="hljs-comment">// vec 包含 ilst 的一份拷贝，但是其中 值为 0 的元素已经替换为 42</span><br><span class="hljs-built_in">replace_copy</span>(ilst.<span class="hljs-built_in">begin</span>(), ilst.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(vec), <span class="hljs-number">0</span>, <span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><hr><h2 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h2><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>sort(b, e)</strong></td><td>b, e 表示要排序的元素的范围</td></tr><tr><td><strong>unique(b, e)</strong></td><td>b, e 表示要排序的元素的范围 <br> <strong>返回指向不重复区域之后一个位置的迭代器</strong></td></tr></tbody></table></div><ul><li><strong>unique 并不真正删除元素，只覆盖相邻的重复元素</strong>，使得不重复元素出现在序列开始的部分</li></ul><h3 id="使用容器操作删除元素"><a href="#使用容器操作删除元素" class="headerlink" title="使用容器操作删除元素"></a>使用容器操作删除元素</h3><ul><li><strong>标准库算法</strong>对迭代器而不是对容器操作，因此<strong>不能（直接）添加或删除元素</strong></li><li>要真正删除无用元素，必须使用容器操作</li></ul><h2 id="算法不改变容器大小的原因"><a href="#算法不改变容器大小的原因" class="headerlink" title="算法不改变容器大小的原因"></a>算法不改变容器大小的原因</h2><ul><li>将算法和容器成员函数区分开</li><li>算法接受的参数是迭代器，不是容器本身</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.3 标准库算法的定制操作</title>
      <link href="/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.3%20%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/30/10.%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/10.3%20%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>许多算法使用元素类型的 <code>&lt;</code>, <code>==</code>完成比较</li><li>标准库还定义了额外版本，允许提供自定义的操作代替默认运算符</li></ul><h2 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h2><h3 id="谓词-predicate"><a href="#谓词-predicate" class="headerlink" title="谓词(predicate)"></a>谓词(predicate)</h3><ul><li>谓词是<strong>可调用的表达式</strong></li><li>标准库算法使用的谓词分为两类：<ul><li><strong>一元谓词</strong>(unary predicate)：只<strong>接受单一参数</strong></li><li><strong>二元谓词</strong>(binary predicate)：有<strong>两个参数</strong></li></ul></li><li>输入序列中的<strong>元素类型必须能转换为谓词的参数类型</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 比较函数，用来按长度排序单词</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isShorter</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s1, <span class="hljs-type">const</span> string &amp;s2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-comment">// 按长度由短到长排序 words</span><br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), isShorter);<br></code></pre></td></tr></table></figure><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>stable_sort(b, e, compare)</strong></td><td><strong>排序之后仍保持元素的相对顺序</strong> <br> b, e 是要排序的范围 <br> <strong>compare 是可选的比较函数对象</strong> <br> 返回 void</td></tr></tbody></table></div><hr><h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h2><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>find_if(b, e, lambda)</strong></td><td>功能与 find 相似，查找第一个具有特定大小的元素<br> b, e 是表示输入序列的迭代器，<strong>第三个参数是谓词</strong> <br> 返回指向第一个<strong>使谓词返回值非 0</strong> 的元素的迭代器，如果<strong>不存在</strong>，<strong>返回尾迭代器</strong></td></tr></tbody></table></div><h3 id="了解-lambda-表达式"><a href="#了解-lambda-表达式" class="headerlink" title="了解 lambda 表达式"></a>了解 lambda 表达式</h3><ul><li>可以向算法传递任何类别的<strong>可调用对象(callable object)</strong></li><li>可调用对象有：<ul><li>函数</li><li>函数指针</li><li>lambda 表达式</li><li>重载了函数调用运算符的类</li></ul></li><li><p>lambda 具有返回类型、参数列表、函数体，一个 lambda 表达式具有如下形式：</p><ul><li><strong><code>[capture list] (parameter list) -&gt; return type &#123; function body &#125;</code></strong></li><li><strong>capture list</strong>: <strong>捕获列表，lambda</strong> <strong>所在函数中定义的局部变量的列表</strong>（通常为空）</li><li>parameter list， return type, function body 与普通函数含义一样</li><li>与普通函数不同的是，<strong>lambda 必须使用尾置返回，来指定返回类型</strong></li><li>可以忽略参数列表和返回类型，但<strong>必须永远包含捕获列表和函数体</strong></li><li><p>lambda 调用方式与普通函数调用方式相同，都使用调用运算符</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义一个可调用对象 f, 不接受参数，返回 42</span><br><span class="hljs-keyword">auto</span> f = [] &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-comment">// 调用 f 打印 42</span><br>cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>lambda 中忽略括号和参数列表，<strong>等价于指定一个空参数列表</strong></p></li><li>忽略返回类型，lambda <strong>根据函数体中代码推断返回类型</strong><ul><li>如果<strong>函数体</strong>只是<strong>一条 return 语句</strong>，则<strong>返回类型从返回的表达式推断</strong></li><li>如果 lambda 函数体包含任何单一 <strong>return 语句之外的内容</strong>，且<strong>未指定返回类型</strong>，则<strong>返回 void</strong></li></ul></li></ul></li></ul><h3 id="向-lambda-传递参数"><a href="#向-lambda-传递参数" class="headerlink" title="向 lambda 传递参数"></a>向 lambda 传递参数</h3><ul><li><strong>lambda 形参不能有默认值</strong>，因此 lambda 调用的实参数目永远与形参数目相等</li><li><p>与 isShorter 函数功能相同的 lambda 表达式</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">[] (<span class="hljs-type">const</span> string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)<br>    &#123; <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); &#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 lambda 表达式</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stable_sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(),<br>            [] (<span class="hljs-type">const</span> string &amp; s1, <span class="hljs-type">const</span> string &amp; s2)<br>            &#123; <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>(); &#125;)<br></code></pre></td></tr></table></figure></li></ul><h3 id="使用捕获列表"><a href="#使用捕获列表" class="headerlink" title="使用捕获列表"></a>使用捕获列表</h3><ul><li>lambda 只能使用所在函数中明确指定的</li><li><strong>捕获列表</strong>中是逗号隔开的名字列表，这些名字是所在函数中的<strong>局部变量</strong></li><li>一个 lambda <strong>只有在其捕获列表中捕获一个它所在函数中的局部变量</strong>，<strong>才能在函数体中使用该变量</strong></li></ul><h3 id="find-if-算法"><a href="#find-if-算法" class="headerlink" title="find_if 算法"></a>find_if 算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td>find_if(b, e, lambda)</td><td>b, e 表示输入范围 <br> lambda 是一元谓词 <br> <strong>返回指向第一个使一元谓词为 true 到迭代器</strong>，若未找到，返回迭代器 e</td></tr></tbody></table></div><h3 id="for-each-算法"><a href="#for-each-算法" class="headerlink" title="for_each 算法"></a>for_each 算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td>for_each(b, e, lambda)</td><td>b, e 表示要遍历的范围 <br> lambda 是一个<strong>一元谓词，接受范围内元素的引用作为参数</strong> <br> 返回值：返回传入的可调用对象的副本</td></tr></tbody></table></div><ul><li><strong>捕获列表只用于局部非 static 变量</strong>，lambda 函数体<strong>内可以直接使用局部 static 变量</strong>和<strong>它所在函数之外声明的名字</strong></li></ul><h3 id="biggies-练习"><a href="#biggies-练习" class="headerlink" title="biggies 练习"></a>biggies 练习</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">elimDups</span><span class="hljs-params">(std::vector&lt;std::string&gt; &amp; words)</span> </span>&#123;<br>    std::<span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">auto</span> iter = std::<span class="hljs-built_in">unique</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>());<br>    words.<span class="hljs-built_in">erase</span>(iter, words.<span class="hljs-built_in">end</span>());<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">make_plural</span><span class="hljs-params">(<span class="hljs-type">size_t</span> count, <span class="hljs-type">const</span> std::string &amp; str, <span class="hljs-type">const</span> std::string &amp; ending)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> count &gt; <span class="hljs-number">1</span> ? str + ending : str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">biggies</span><span class="hljs-params">(std::vector&lt;std::string&gt; &amp; words, std::vector&lt;std::string&gt;::size_type sz)</span> </span>&#123;<br>    <span class="hljs-comment">// 将 words 按字典序排序，删除重复元素</span><br>    <span class="hljs-built_in">elimDups</span>(words);<br>    <span class="hljs-comment">// 按长度排序，长度相同的维持字典序</span><br>    std::<span class="hljs-built_in">stable_sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                     [] (<span class="hljs-type">const</span> std::string &amp; s1, <span class="hljs-type">const</span> std::string &amp; s2)<br>                     &#123; <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() &lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();&#125;);<br>    <span class="hljs-comment">// 获取一个迭代器，指向第一个满足 size() &gt;= sz 的元素</span><br>    <span class="hljs-keyword">auto</span> wc = std::<span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                           [sz] (<span class="hljs-type">const</span> std::string &amp; s)<br>                           &#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &gt;= sz;&#125;);<br>    <span class="hljs-comment">// 计算满足 size() &gt;= sz 的元素数量</span><br>    <span class="hljs-keyword">auto</span> count = words.<span class="hljs-built_in">end</span>() - wc;<br>    std::cout &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-built_in">make_plural</span>(count, <span class="hljs-string">&quot;word&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>) &lt;&lt; <span class="hljs-string">&quot; of length &quot;</span> &lt;&lt; sz<br>                &lt;&lt; <span class="hljs-string">&quot; or longer.&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 打印长度大于等于给定值的单词，每个单词后接一个空格</span><br>    std::for_each(wc, words.<span class="hljs-built_in">end</span>(),<br>                  [sz] (<span class="hljs-type">const</span> std::string &amp; s)<br>                  &#123;std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;);<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testBiggies</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::string&gt; words&#123;<span class="hljs-string">&quot;fd&quot;</span>, <span class="hljs-string">&quot;fds&quot;</span>, <span class="hljs-string">&quot;qw&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;fdasf&quot;</span>, <span class="hljs-string">&quot;dfsdafd&quot;</span>, <span class="hljs-string">&quot;afd&quot;</span>, <span class="hljs-string">&quot;fadsf&quot;</span>, <span class="hljs-string">&quot;dfasdsaf&quot;</span>, <span class="hljs-string">&quot;fdakhuiohiohu&quot;</span>&#125;;<br>    <span class="hljs-built_in">biggies</span>(words, <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="partition-算法"><a href="#partition-算法" class="headerlink" title="partition 算法"></a>partition 算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>partition(b, e, UnaryPredicate)</strong></td><td>根据一元谓词函数重排指定范围元素，使<strong>谓词函数为 true</strong> 的元素放于<strong>前半部分</strong>，为 <strong>false</strong> 的元素放在<strong>后半部分</strong> <br> UnaryPredicate 是<strong>一元谓词</strong> <br> <strong>返回一个迭代器</strong>，指向<strong>第一个使谓词为 false</strong> 的元素</td></tr></tbody></table></div><h2 id="lambda-捕获和返回"><a href="#lambda-捕获和返回" class="headerlink" title="lambda 捕获和返回"></a>lambda 捕获和返回</h2><ul><li>当定义一个 lambda 时，编译器生成了一个与 lambda 对应的新的（未命名）类类型</li><li>可以这样理解，当向一个函数传递 lambda 时，同时定义了一个新类型和该类型的对象：传递的参数就是编译器生成的类类型的未命名对象</li><li>默认情况下，<strong>从 lambda 生成的类</strong>都<strong>包含</strong>对应于<strong>该 lambda 所捕获变量的数据成员</strong>。lambda 的数据成员也在 lambda 对象创建时初始化</li></ul><h3 id="值捕获"><a href="#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><ul><li>变量的捕获方式可以是<strong>值</strong>或<strong>引用</strong></li><li><p>采用<strong>值捕获的前提是变量可以拷贝</strong>，被捕获变量的值是在 lambda 创建时拷贝，而不是在调用时拷贝</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>; <span class="hljs-comment">// 局部变量</span><br>  <span class="hljs-keyword">auto</span> f = [v1] &#123; <span class="hljs-keyword">return</span> v1; &#125;;<br>  v1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// j 为 42，f 保存了创建它时对 v1 的拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="引用捕获"><a href="#引用捕获" class="headerlink" title="引用捕获"></a>引用捕获</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">size_t</span> v1 = <span class="hljs-number">42</span>;<br>  <span class="hljs-keyword">auto</span> f = [&amp;v1] &#123; <span class="hljs-keyword">return</span> v1; &#125;;<br>  v1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">f</span>();   <span class="hljs-comment">// j 为 0，f 保存 v1 的引用，而不是拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>捕获引用</strong>，在 lambda 函数体内使用此变量时，<strong>实际使用的是引用绑定的对象</strong></li><li><strong>必须确保被引用对象在 lambda 执行的时候是存在的</strong></li><li><strong>可以从一个函数返回 lambda</strong>。如果函数返回一个 lambda，则与函数不能返回局部变量的引用类似，<strong>此 lambda 不能包含引用捕获</strong></li></ul><h3 id="隐式捕获"><a href="#隐式捕获" class="headerlink" title="隐式捕获"></a>隐式捕获</h3><ul><li>可以让编译器根据 lambda 体中的代码来判断要使用哪些变量</li><li>在捕获列表中写入 <strong>&amp;</strong> 或 <strong>=</strong><ul><li><strong>&amp;</strong> 告诉编译器采用<strong>捕获引用</strong>方式</li><li><strong>=</strong> 表示采用<strong>值捕获</strong>方式</li></ul></li><li>显示捕获可以与隐式捕获同时使用<ul><li>当<strong>混合使用</strong>时，<strong>捕获列表中第一个元素必须是一个 &amp; 或 =</strong></li><li><strong>显示捕获</strong>的变量<strong>必须使用与隐式捕获不同的方式</strong><ul><li>隐式捕获是引用方式，显示捕获就必须是值捕获方式</li><li>隐式捕获是值捕获方式，显示捕获就必须是引用捕获方式</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">biggies</span><span class="hljs-params">(vector&lt;string&gt; &amp;words, vector&lt;string&gt;::size_type sz,</span></span><br><span class="hljs-params"><span class="hljs-function">              ostream &amp; os = cout, <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27; &#x27;</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// os 隐式捕获，引用捕获方式，c 显示捕获，值捕获方式</span><br>  for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>          [&amp;, c](<span class="hljs-type">const</span> string &amp;s) <br>          &#123; os &lt;&lt; s &lt;&lt; c; &#125;);<br><br>  <span class="hljs-comment">// os 显示捕获，引用捕获方式，c 隐式捕获，值捕获方式</span><br>  for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>          [=, os] (<span class="hljs-type">const</span> string &amp;s)<br>          &#123; os &lt;&lt; s &lt;&lt; c; &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可变-lambda"><a href="#可变-lambda" class="headerlink" title="可变 lambda"></a>可变 lambda</h3><ul><li>默认情况下，一个值被拷贝的变量，lambda 不会改变其值</li><li>如果希望能改变一个被捕获变量的值，就必须<strong>在参数列表首加上 mutable</strong></li><li>可变 lambda 能省略参数列表</li></ul><h3 id="指定-lambda-返回类型"><a href="#指定-lambda-返回类型" class="headerlink" title="指定 lambda 返回类型"></a>指定 lambda 返回类型</h3><ul><li>如果一个 lambda 体包含处 return 之外的任何语句，则编译器假定此 lambda 返回 void</li></ul><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>transform(b1, e1, b2, UnaryPredicate)</strong></td><td>对于给定范围内的元素应用给定的操作，并将结果存储到目的范围内。<br> b, e 是输入范围起始与结束迭代器。b2 是输出范围起始迭代器 <br> UnaryPredicate 可调用对象可以是一元谓词，也可以是二元谓词 <br> <strong>返回一个迭代器，指向输出范围最后一个转换结果之后的位置</strong></td></tr></tbody></table></div><ul><li>transform 中<strong>目的位置迭代器</strong> b2 <strong>可以</strong>与<strong>输入范围的开始位置迭代器</strong> b1 <strong>相同</strong></li><li>当需要为 lambda 定义返回类型时，必须使用尾置返回类型</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">transform</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), vec.<span class="hljs-built_in">begin</span>(),<br>          [] (<span class="hljs-type">const</span> <span class="hljs-type">int</span> i) -&gt; <span class="hljs-type">int</span><br>          &#123; <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -i; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i;&#125;)<br></code></pre></td></tr></table></figure><h3 id="count-if-算法"><a href="#count-if-算法" class="headerlink" title="count_if 算法"></a>count_if 算法</h3><div class="table-container"><table><thead><tr><th>Algorithm</th><th>Description</th></tr></thead><tbody><tr><td><strong>count_if(b, e, UnaryPredicate)</strong></td><td>b, e 表示输入范围 <br> 谓词 UnaryPredicate 会对输入范围的每个元素执行 <br> <strong>返回一个计数值，表示谓词有多少次为真</strong></td></tr></tbody></table></div><hr><h2 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h2><ul><li>如果 lambda 的捕获列表为空，通常可以使用函数来代替</li><li>但是对于捕获局部变量的 lambda，就要确认算法接受一元谓词还是二元谓词<ul><li>如果只接受一元谓词，但是我们传入的参数除了输入范围元素，还有局部变量，就不行</li></ul></li></ul><h3 id="标准库-bind-函数"><a href="#标准库-bind-函数" class="headerlink" title="标准库 bind 函数"></a>标准库 bind 函数</h3><ul><li><strong>bind</strong> 函数，定义在头文件 <strong>functional</strong> 中</li><li>可以将 bind 看做通用函数适配器：<strong>接受一个可调用对象</strong>，<strong>生成一个新的可调用对象来适应原对象的参数列表</strong></li><li>一般形式<ul><li><code>auto newCallable = bind(callable, args_list);</code></li><li><strong>newCallable 本身是一个可调用对象</strong></li><li><strong>args_list</strong> 是一个逗号分隔的参数列表，<strong>对应给定 callable 的参数</strong></li><li>当调用 newCallable 时， <strong>newCallable 会调用 callable</strong>，<strong>并传递给它 args_list 中的参数</strong></li></ul></li><li>args_list 中参数形式：<ul><li>形如 <strong><code>_n</code></strong>,n 是整数</li><li>这些参数是<strong>占位符</strong>，表示 <strong>newCallable</strong> 的参数，占据了传递给 newCallable 的参数的位置</li><li><strong>n 表示生成的可调用对象中参数的位置</strong>：<code>_1</code> 为 newCallable 的第一个参数，<code>_2</code> 为 newCallable 的第二个参数</li></ul></li><li><p>利用 bind 可以将基于 lambda 的 find_if 调用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                  [sz] (<span class="hljs-type">const</span> string &amp; s)<br>                  &#123; <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &gt;= sz;&#125;);<br></code></pre></td></tr></table></figure></li><li><p>替换为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> wc = <span class="hljs-built_in">find_if</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(),<br>                  <span class="hljs-built_in">bind</span>(check_size, _1, sz));<br></code></pre></td></tr></table></figure><ul><li>bind 生成一个可调用对象，将 check_size 的第二个参数绑定到 sz 的值</li></ul></li></ul><h3 id="使用-placeholders-名字"><a href="#使用-placeholders-名字" class="headerlink" title="使用 placeholders 名字"></a>使用 placeholders 名字</h3><ul><li><p><strong>名字 <code>_n</code></strong> 都定义在 <strong>placeholders</strong> 命名空间中，而 placeholders 本身定义在 <strong>std</strong> 命名空间中，<strong>使用这些名字时，两个命名空间都要写上</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> std::placeholders::_1;<br></code></pre></td></tr></table></figure></li></ul><h3 id="bind-的参数"><a href="#bind-的参数" class="headerlink" title="bind 的参数"></a>bind 的参数</h3><ul><li>可以用 bind 绑定给定可调用对象中的参数或重新安排其顺序</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// g 是一个有两个参数的可调用对象</span><br><span class="hljs-keyword">auto</span> g = <span class="hljs-built_in">bind</span>(f, a, b, _2, c, _1);<br></code></pre></td></tr></table></figure><ul><li>传递给 g 的<strong>参数按位置绑定到占位符</strong>。<ul><li><strong>第一个参数绑定到 <code>_1</code></strong>, <strong>第二个参数绑定到 <code>_2</code></strong>。</li><li>当调用 g 时，<strong>第一个参数</strong>被传递到 f <strong>作为 f 的最后一个参数</strong>；<strong>第二个参数</strong>被传递给 f <strong>作为 f 的第三个参数</strong></li></ul></li></ul><h3 id="用-bind-重排参数顺序"><a href="#用-bind-重排参数顺序" class="headerlink" title="用 bind 重排参数顺序"></a>用 bind 重排参数顺序</h3><h3 id="绑定引用参数"><a href="#绑定引用参数" class="headerlink" title="绑定引用参数"></a>绑定引用参数</h3>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 泛型算法 </tag>
            
            <tag> generic algorithm </tag>
            
            <tag> 谓词 </tag>
            
            <tag> lambda </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.6 容器适配器</title>
      <link href="/2025/03/30/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.6%20%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>/2025/03/30/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.6%20%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器操作和类型"><a href="#适配器操作和类型" class="headerlink" title="适配器操作和类型"></a>适配器操作和类型</h2><ul><li>适配器是标准库的一个通用概念，容器、迭代器、函数都有适配器。</li><li><strong>适配器</strong>是一种<strong>机制</strong>，使某种事物行为看起来像另外一种事物</li><li>比如 <strong>stack 适配器接受</strong>一个<strong>顺序容器(除 array 和 forward_list 之外)</strong>, 并<strong>使其操作看起来像 stack</strong></li></ul><div class="table-container"><table><thead><tr><th>Adaptor Operation And Type</th><th>Description</th></tr></thead><tbody><tr><td>size_type</td><td>一种类型，足以保存当前类型的最大对象的大小</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>container_type</td><td>实现适配器的底层容器类型</td></tr><tr><td>A a;</td><td>创建一个名为 a 的空适配器</td></tr><tr><td><strong>A a(c)</strong>;</td><td><strong>创建一个名为 a 的适配器，带有容器 c 的一个拷贝</strong></td></tr><tr><td>关系运算符</td><td>适配器都支持 ==, !=, &lt;, &lt;=, &gt;, &gt;= <br> 这些运算符返回底层容器的比较结果</td></tr><tr><td>a.empty()</td><td>若 a 至少包含一个元素，返回false；否则返回 true</td></tr><tr><td>a.size()</td><td>返回 a 中的元素数目</td></tr><tr><td>swap(a, b) <br> a.swap(b)</td><td>交换 a, b 的内容 <br> a 和 b 必须具有相同的类型，包括底层容器类型也必须相同</td></tr></tbody></table></div><h2 id="定义适配器"><a href="#定义适配器" class="headerlink" title="定义适配器"></a>定义适配器</h2><ul><li><p>每个适配器都有两个构造函数：</p><ul><li>默认构造函数创建一个空对象，</li><li>接受容器的构造函数拷贝该容器来初始化适配器</li></ul></li><li><p>默认情况下，<strong>stack 和 queue 基于 deque 实现</strong>；<strong>priority queue 基于 vector  实现</strong></p></li><li><p>在创建适配器时，将一个命名的<strong>顺序容器作为第二个类型参数</strong>，来重载默认容器类型</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在 vector 上实现的空栈</span><br>stack&lt;string, vector&lt;string&gt;&gt; str_stk;<br><span class="hljs-comment">// str_stk2 在 vector 上实现，初始化时保存 svec 的拷贝</span><br>stack&lt;string, vector&lt;string&gt;&gt; <span class="hljs-built_in">str_stk2</span>(svce);<br></code></pre></td></tr></table></figure></li><li><p><strong>不能用 array</strong> 来构造适配器：所有适配器<strong>都要求能添加和删除元素</strong></p></li><li><strong>不能用 forward_list</strong> 构造适配器：所有适配器<strong>都要求能添加、删除、访问尾元素</strong></li><li><strong>stack</strong> 要求 push_back，pop_back，back<ul><li>可以使用<strong>除 array，forward_list 之外的任何容器类型</strong>来构造</li></ul></li><li><strong>queue</strong> 要求 back，push_back，front，push_front<ul><li>可以使用 <strong>list，deque 构造</strong></li><li>但<strong>不能基于 vector</strong> 构造</li></ul></li><li><strong>priority</strong> 要求 front, push_back，push_front，还要求<strong>随机访问</strong><ul><li>可以<strong>基于 vector，deque 构造</strong>，但<strong>不能用 list</strong></li></ul></li></ul><h2 id="栈适配器"><a href="#栈适配器" class="headerlink" title="栈适配器"></a>栈适配器</h2><ul><li>默认基于 deque 实现，也可以使用 list 或 vector 实现</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>s.pop()</td><td>删除栈顶元素，但不返回该元素值</td></tr><tr><td>s.push(item) <br> s.emplace(args)</td><td>创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来，或者由 args 构造</td></tr><tr><td>s.top()</td><td>返回栈顶元素，但不讲元素弹出栈</td></tr></tbody></table></div><ul><li>只能使用适配器的操作，<strong>不能使用底层容器操作</strong></li></ul><h2 id="队列适配器"><a href="#队列适配器" class="headerlink" title="队列适配器"></a>队列适配器</h2><ul><li>queue 和 priority_queue 定义在 queue 头文件中</li><li>queue 默认基于 deque 实现，priority_queue 默认基于 vector 实现</li><li>queue 也可以使用 list 或 vector 实现；priority_queue 也可以使用 deque 实现</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>q.pop()</td><td>返回 queue 的首元素或者 priority_queue 的最高优先级元素，但不删除元素</td></tr><tr><td><strong>q.front()</strong> <br> <strong>q.back()</strong></td><td>返回首元素或尾元素，但不删除元素。<strong>只适用于 queue</strong></td></tr><tr><td><strong>q.top()</strong></td><td>返回最高优先级元素，但不删除元素。<strong>只适用于 priority_queue</strong></td></tr><tr><td>q.push(item) <br> q.emplace(args)</td><td>在 queue 的末尾或者 priority_queue 的恰当位置创建一个元素，其值为 item，或由 args 构造</td></tr></tbody></table></div><ul><li>queue 使用先进先出(<strong>first in, first out FIFO</strong>)的存储和访问策略：<ul><li><strong>进入</strong>队列的对象放<strong>在队尾</strong>，<strong>离开</strong>队列的对象<strong>从队首删除</strong></li></ul></li><li>priority_queue 允许为队列元素创建优先级<ul><li>新元素会排在优先级比它低的已有元素之前</li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>题目：使用stack处理括号化的表达式。当你看到一个左括号，将其记录下来。 当你在一个左括号之后看到一个右括号，从s七ack中pop对象，直至遇到左括号，将左括号也一起弹出栈。然后将一个值（括号内的运算结果）push到栈中，表示一个括号化的（子）表达式已经处理完毕，被其运算结果所替代。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 判断字符是否为操作符</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span> || c == <span class="hljs-string">&#x27;/&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 返回操作符优先级</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getPrecedence</span><span class="hljs-params">(<span class="hljs-type">char</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span> || op == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;*&#x27;</span> || op == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 接受两个整数和一个操作符，返回计算结果</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculator</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">char</span> op)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (op) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> a + b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> a - b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> a * b;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>            <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Division by zero&quot;</span>);<br>            <span class="hljs-keyword">return</span> a / b;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Invalid operator&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">handleExpression</span><span class="hljs-params">(std::string &amp; expr)</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">char</span>&gt; ops_stk;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; v_stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; expr.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-type">char</span> c = expr[i];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isspace</span>(c))<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">// 如果是数字，解析完整字符并压入栈</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>            <span class="hljs-type">int</span> value = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (i &lt; expr.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(expr[i])) &#123;<br>                value = value * <span class="hljs-number">10</span> + (expr[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                ++i;<br>            &#125;<br>            v_stk.<span class="hljs-built_in">push</span>(value);<br>            --i;      <span class="hljs-comment">// 回退 1 位, 在 for 循环中 i 还要 ++</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果遇到 ’(&#x27; ,直接压入操作符栈</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>)<br>            ops_stk.<span class="hljs-built_in">push</span>(c);<br><br>        <span class="hljs-comment">// 如果遇到 ‘)&#x27; 则弹出操作符直到遇到左括号</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            <span class="hljs-keyword">while</span> (!ops_stk.<span class="hljs-built_in">empty</span>() &amp;&amp; ops_stk.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-type">int</span> a = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> b = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">char</span> op = ops_stk.<span class="hljs-built_in">top</span>(); ops_stk.<span class="hljs-built_in">pop</span>();<br>                v_stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calculator</span>(a, b, op));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!ops_stk.<span class="hljs-built_in">empty</span>() &amp;&amp; ops_stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>)<br>                ops_stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Mismatched Parenthesis&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果遇到操作符</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isOperator</span>(c)) &#123;<br>            <span class="hljs-keyword">while</span> (!ops_stk.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">getPrecedence</span>(ops_stk.<span class="hljs-built_in">top</span>()) &gt;= <span class="hljs-built_in">getPrecedence</span>(c)) &#123;<br>                <span class="hljs-type">int</span> a = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> b = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">char</span> op = ops_stk.<span class="hljs-built_in">top</span>(); ops_stk.<span class="hljs-built_in">pop</span>();<br>                v_stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calculator</span>(a, b, op));<br>            &#125;<br>            ops_stk.<span class="hljs-built_in">push</span>(c);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余操作符</span><br>    <span class="hljs-keyword">while</span> (!ops_stk.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> a = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> b = v_stk.<span class="hljs-built_in">top</span>(); v_stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">char</span> op = ops_stk.<span class="hljs-built_in">top</span>(); ops_stk.<span class="hljs-built_in">pop</span>();<br>        v_stk.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">calculator</span>(a, b, op));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (v_stk.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) &#123;<br>        std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Error in expression evaluation&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> v_stk.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;请输入一个数学表达式：&quot;</span>;<br>    std::<span class="hljs-built_in">getline</span>(std::cin, str);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">handleExpression</span>(str);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;计算结果是：&quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;错误：&quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 容器适配器 </tag>
            
            <tag> stack </tag>
            
            <tag> queue </tag>
            
            <tag> priority queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.5 额外的 string 操作</title>
      <link href="/2025/03/29/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.5%20%E9%A2%9D%E5%A4%96%E7%9A%84%20string%20%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/29/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.5%20%E9%A2%9D%E5%A4%96%E7%9A%84%20string%20%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="构造-string-的其他方法"><a href="#构造-string-的其他方法" class="headerlink" title="构造 string 的其他方法"></a>构造 string 的其他方法</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>string s(cp, n)</td><td>s 是 <strong>cp 指向的数组</strong>中前 n 个字符的拷贝。<br> 此<strong>数组至少包含 n 个字符</strong></td></tr><tr><td>string s(s2, pos2)</td><td>s 是 s2 从下标 pos2 开始的字符的拷贝。<br> 如果 pos2 &gt; s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2, pos2, len2)</td><td>s 是 s2 从下标 pos2 开始的 len2 个元素的拷贝。<br> 若 pos2 &gt; s2.size()，构造函数行为未定义 <br> 不管 len2 的值是多少，构造函数<strong>至多拷贝 s2.size() - pos2 个元素</strong></td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testStringConstructor</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * cp = <span class="hljs-string">&quot;Hello World!!&quot;</span>;      <span class="hljs-comment">// 以空字符结束的数组</span><br>    <span class="hljs-type">char</span> noNull[] = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>&#125;;     <span class="hljs-comment">// 不是以空字符结束</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s1</span><span class="hljs-params">(cp)</span></span>;                 <span class="hljs-comment">// 拷贝 cp 中的字符直到遇到空字符；s1 == &quot;Hello World!!&quot;</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s2</span><span class="hljs-params">(noNull, <span class="hljs-number">2</span>)</span></span>;        <span class="hljs-comment">// 从 noNull 拷贝两个字符;s2 == &quot;Hi&quot;</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s3</span><span class="hljs-params">(noNull)</span></span>;             <span class="hljs-comment">// 未定义行为。noNull 不是以空字符结尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s4</span><span class="hljs-params">(cp + <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span></span>;        <span class="hljs-comment">// 从 cp[6] 开始拷贝 5 个字符。</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s5</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)</span></span>;  <span class="hljs-comment">// 在 s1[6] 开始拷贝 5 个字符</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s6</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>)</span></span>;          <span class="hljs-comment">// 从 s1[6] 开始拷贝，直到 s1 末尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s7</span><span class="hljs-params">(s1, <span class="hljs-number">6</span>, <span class="hljs-number">20</span>)</span></span>;  <span class="hljs-comment">// 从 s1[6] 开始拷贝，直到 s1 末尾</span><br>    <span class="hljs-function">std::string <span class="hljs-title">s8</span><span class="hljs-params">(s1, <span class="hljs-number">18</span>)</span></span>;         <span class="hljs-comment">// 抛出 out_of_range 异常</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当从一个 <code>const char *</code> <strong>创建 string</strong> 时，指针指向的<strong>数组必须以空字符结尾</strong>，<strong>拷贝操作遇到空字符停止</strong></li><li>但如果还<strong>传递给构造函数一个计数值</strong>，则数组不必以空字符结尾。</li><li>若未传递计数值也未以空字符结尾，或传递的计数值大于数组大小，构造函数行为未定义</li></ul><h3 id="substr-操作"><a href="#substr-操作" class="headerlink" title="substr 操作"></a>substr 操作</h3><ul><li>substr 返回一个 string</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>s.substr(pos, n)</td><td>返回 string，包含 s 中<strong>从 pos 开始的 n 个字符的拷贝</strong>。<br> pos 默认值是 0，n 的默认值是 s.size() - pos, 即拷贝从 pos 开始的所有字符</td></tr></tbody></table></div><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testSubstr</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello world&quot;</span>)</span></span>;<br>    std::string s1 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);        <span class="hljs-comment">// s1 = Hello</span><br>    std::string s2 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>);              <span class="hljs-comment">// s2 = world</span><br>    std::string s3 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">6</span>, <span class="hljs-number">11</span>);       <span class="hljs-comment">// s3 = world</span><br>    std::string s4 = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">12</span>);             <span class="hljs-comment">// 抛出 out_of_range 异常</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="改变-string-的其他方法"><a href="#改变-string-的其他方法" class="headerlink" title="改变 string 的其他方法"></a>改变 string 的其他方法</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>args 形式</th><th>Description</th></tr></thead><tbody><tr><td>s.insert(pos, args)</td><td>str <br> str, pos2, len <br> cp, len <br> n, c</td><td>在 <strong>下标 pos 前插入</strong> args 指定的字符。<br> <strong>返回指向 s 的引用</strong></td></tr><tr><td>s.insert(iter, args)</td><td>n, c <br> b2, e2 <br> 初始化列表</td><td>在<strong>迭代器 iter 前</strong>插入 args 指定字符。 <br> <strong>返回指向第一个插入字符的迭代器</strong></td></tr><tr><td>s.erase(pos, len)</td><td></td><td><strong>删除从位置 pos 开始的 len 个字符</strong>。<br> 如果 len 被省略，则删除从 pos 开始直到 s 末尾的所有字符。<br> <strong>返回指向 s 的引用</strong></td></tr><tr><td>s.assign(args)</td><td>str <br> str, pos, len <br> cp, len <br> cp <br> n,c <br> b,e <br> 初始化列表</td><td>将 <strong>s 中的字符替换为 args 指定的字符</strong>。<br> 返回一个指向 s 的引用</td></tr><tr><td>s.append(args)</td><td>str <br> str,pos,len <br> cp,len <br> cp <br> n,c <br> b, e <br> 初始化列表</td><td>将 <strong>args 追加到 s</strong>。返回指向 s 的引用</td></tr><tr><td>s.replace(pos, len, args)</td><td>str <br> str, pos2, len2 <br> cp, len <br> cp <br> n, c</td><td>删除 s 中<strong>从下标 pos 开始的 len 个字符</strong>，替换为 args 指定的字符。<br> <strong>返回指向 s 的引用</strong>。</td></tr><tr><td>s.replace(b, e, args)</td><td>str <br> cp, len <br> cp <br> n, c <br> b2, e2 <br> 初始化列表</td><td>删除 s 中<strong>迭代器 b, e 指定范围的字符</strong>，替换为 args 指定的字符。<br> <strong>返回指向 s 的引用</strong></td></tr></tbody></table></div><ul><li>上表中的 args 可以是下列形式之一；</li><li>append 和 assign 可以使用所有形式</li></ul><div class="table-container"><table><thead><tr><th>Form</th><th>Description</th></tr></thead><tbody><tr><td>str</td><td>字符串 str</td></tr><tr><td>str, pos, len</td><td>str 中从 pos 开始最多 len 个字符</td></tr><tr><td>cp, len</td><td>cp 指向的字符数组的前(最多) len 个字符</td></tr><tr><td>cp</td><td>cp 指向的以空字符结尾的字符数组</td></tr><tr><td>n, c</td><td>n 个 字符 c</td></tr><tr><td>b, e</td><td>迭代器 b, e 指定范围内的字符</td></tr><tr><td>初始化列表</td><td>{} 包围的，以 “,” 分隔的字符列表</td></tr></tbody></table></div><ul><li>str 不能和 s 相同</li><li>迭代器 b,e 不能指向 s</li><li><strong>replace</strong> 和 <strong>insert</strong> 所允许的 args 形式<strong>依赖于 range 和 pos 如何指定</strong></li></ul><div class="table-container"><table><thead><tr><th>replace</th><th>replace</th><th>insert</th><th>insert</th><th>args 可以是</th></tr></thead><tbody><tr><td>(pos, len, args)</td><td>(b, e, args)</td><td>(pos, args)</td><td>(iter, args)</td><td></td></tr><tr><td>是</td><td>是</td><td>是</td><td>否</td><td>str</td></tr><tr><td>是</td><td>否</td><td>是</td><td>否</td><td>str, pos, len</td></tr><tr><td>是</td><td>是</td><td>是</td><td>否</td><td>cp, len</td></tr><tr><td>是</td><td>是</td><td>否</td><td>否</td><td>cp</td></tr><tr><td>是</td><td>是</td><td>是</td><td>是</td><td>n, c</td></tr><tr><td>否</td><td>是</td><td>否</td><td>是</td><td>b2, e2</td></tr><tr><td>否</td><td>是</td><td>否</td><td>是</td><td>初始化列表</td></tr></tbody></table></div><h3 id="接受下标版本的-insert-和-erase"><a href="#接受下标版本的-insert-和-erase" class="headerlink" title="接受下标版本的 insert 和 erase"></a>接受下标版本的 insert 和 erase</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">size</span>(), <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;!&#x27;</span>);     <span class="hljs-comment">// 在 s 的末尾添加 5 个 ！</span><br>s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);       <span class="hljs-comment">// 从 s 中删除最后五个字符</span><br></code></pre></td></tr></table></figure><h3 id="接受-c-风格字符数组的-insert-和-assign"><a href="#接受-c-风格字符数组的-insert-和-assign" class="headerlink" title="接受 c 风格字符数组的 insert 和 assign"></a>接受 c 风格字符数组的 insert 和 assign</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * cp = <span class="hljs-string">&quot;Stately, plump Buck&quot;</span>;<br>s.<span class="hljs-built_in">assign</span>(cp, <span class="hljs-number">7</span>);        <span class="hljs-comment">// s == &quot;Stately&quot;</span><br>s.<span class="hljs-built_in">insert</span>(s.<span class="hljs-built_in">size</span>(), cp<span class="hljs-number">+7</span>);   <span class="hljs-comment">// s == &quot;Stately, plump Buck&quot;</span><br></code></pre></td></tr></table></figure><ul><li>调用 assign，用 cp 指向的地址开始的 7 个字符替换 s 中的内容</li><li>调用 insert，在 s 的结尾(<em>s[size()] 这个不存在的位置</em>) 插入 cp 指向的数组下从 7 开始直到结尾空字符之前字符的拷贝</li></ul><h3 id="指定其他-string-或子字符串的字符插入当前-string-或赋予当前-string"><a href="#指定其他-string-或子字符串的字符插入当前-string-或赋予当前-string" class="headerlink" title="指定其他 string 或子字符串的字符插入当前 string 或赋予当前 string"></a>指定其他 string 或子字符串的字符插入当前 string 或赋予当前 string</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">string s = <span class="hljs-string">&quot;some string&quot;</span>, s2 = <span class="hljs-string">&quot;some other string&quot;</span>;<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, s2);        <span class="hljs-comment">// 在 s 的 下标 0 之前插入 s2 的拷贝</span><br><span class="hljs-comment">// 在 s[0] 之前插入 s2 中从下标 0 开始的 s2.size() 个字符</span><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, s2, <span class="hljs-number">0</span>, s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>());<br></code></pre></td></tr></table></figure><h3 id="append-和-replace-函数"><a href="#append-和-replace-函数" class="headerlink" title="append 和 replace 函数"></a>append 和 replace 函数</h3><ul><li>append 是在 string 末尾进行插入操作</li><li>replace 是 调用 erase 和 insert 的一种简写</li><li>调用 <strong>replace</strong> 时，<strong>插入文本可以与删除文本长度不同</strong></li></ul><h3 id="改变-string-的多种重载函数"><a href="#改变-string-的多种重载函数" class="headerlink" title="改变 string 的多种重载函数"></a>改变 string 的多种重载函数</h3><ul><li><p><strong>assign 和 append 函数 无需指定要替换 string 中哪个部分</strong>：</p><ul><li>assign 总是替换 string 中的所有内容</li><li>append 总是将新字符添加到 string 末尾</li></ul></li><li><p><strong>replace</strong> 提供<strong>两种指定删除元素范围的方式</strong>：</p><ul><li>通过一个位置和一个长度指定范围</li><li>通过一个迭代器范围来指定</li></ul></li><li><p><strong>insert</strong> 提供<strong>两种方式指定插入点</strong>：</p><ul><li>一个下标</li><li>一个迭代器</li><li><strong>新元素都会插入到给定下标或迭代器之前的位置</strong></li></ul></li><li><p>多种方式指定要添加到 string 中的字符：</p><ul><li>新字符可以来自另一个 string</li><li>可以来自字符指针（指向的字符数组）</li><li>可以来自花括号包围的字符列表</li><li>或是一个字符和一个计数值</li><li>当新字符<strong>来自另一个 string 或 字符数组</strong>时，可以<strong>传递一个额外参数来控制是拷贝部分还是全部</strong></li></ul></li></ul><h2 id="string-的搜索操作"><a href="#string-的搜索操作" class="headerlink" title="string 的搜索操作"></a>string 的搜索操作</h2><ul><li>string 提供 6 个不同的搜索函数，每个搜索函数有 4 个重载版本</li><li>每个搜索操作都返回一个 string::size_type 值，表示匹配发生位置下标</li><li>搜索失败，返回一个 string::npos 的 static 成员。npos 是 const string::size_type 类型，初始化值为 -1。</li></ul><div class="table-container"><table><thead><tr><th>Search Operation</th><th>Description</th></tr></thead><tbody><tr><td>s.find(args)</td><td>查找 s 中 <strong>args 第一次出现</strong>的位置</td></tr><tr><td>s.rfind(args)</td><td>查找 s 中 <strong>args 最后一次出现</strong>的位置</td></tr><tr><td>s.find_first_of(args)</td><td>在 s 中查找 <strong>args 中任何一个字符第一次出现</strong>的位置</td></tr><tr><td>s.find_last_of(arsg)</td><td>在 s 中查找 <strong>args 中任何一个字符最后一次出现</strong>的位置</td></tr><tr><td>s.find_first_not_of(args)</td><td>在 s 中查找<strong>第一个不在 args 中</strong>的字符</td></tr><tr><td>s.find_last_not_of(args)</td><td>在 s 中查找<strong>最后一个不在 args 中</strong>的字符</td></tr></tbody></table></div><ul><li>args 必须是以下形式</li></ul><div class="table-container"><table><thead><tr><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>c, pos</td><td>从 s 中位置 pos 开始查找字符 c 。<br> pos 默认为 0</td></tr><tr><td>s2, pos</td><td>从 s 中位置 pos 开始查找字符串 s2 。<br> pos 默认为 0</td></tr><tr><td>cp, pos</td><td>从 s 中位置 pos  开始查找 cp 指向的以空字符结尾的 C 风格字符串。<br> pos 默认为 0</td></tr><tr><td>cp, pos, n</td><td>从 s 中位置 pos 开始查找 cp 指向的数组的前 n 个字符。<br> pos 和 n 无默认值</td></tr></tbody></table></div><h3 id="指定在哪里搜索"><a href="#指定在哪里搜索" class="headerlink" title="指定在哪里搜索"></a>指定在哪里搜索</h3><ul><li><p>循环搜索子字符串出现的所有位置</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_substring_pos</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-string">&quot;dfadafdasfd343245232t434543254545435132343476y 55243eq6tr6&quot;</span>)</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">number</span><span class="hljs-params">(<span class="hljs-string">&quot;34&quot;</span>)</span></span>;<br>    std::string::size_type pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((pos = name.<span class="hljs-built_in">find_first_of</span>(number, pos)) != std::string::npos) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;find number at index: &quot;</span> &lt;&lt; pos <br>                      &lt;&lt; <span class="hljs-string">&quot;, element is &quot;</span> &lt;&lt; name[pos] &lt;&lt; std::endl;<br>            ++pos;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ul><li>如果一个字母延伸到中线之上，如d或f，则称其有上出头部分（ascender）。如果一个字母延伸到中线之下，如p或g，则称其有下出头部分（descender）。编写程序，读入一个单词文件，输出最长的既不包含上出头部分，也不包含下出头部分的单词。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">checkMax</span><span class="hljs-params">(std::string &amp; currWord, std::string &amp; maxWord)</span></span>&#123;<br>    maxWord = currWord.<span class="hljs-built_in">size</span>() &gt; maxWord.<span class="hljs-built_in">size</span>() ? currWord : maxWord;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkWord</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; word)</span> </span>&#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">target</span><span class="hljs-params">(<span class="hljs-string">&quot;acemnorsuvwxz&quot;</span>)</span></span>;<br>    std::string::size_type pos = word.<span class="hljs-built_in">find_first_not_of</span>(target);<br>    <span class="hljs-keyword">return</span> pos == std::string::npos;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_longest_noAscender_noDescender</span><span class="hljs-params">(std::ifstream &amp; ifs)</span> </span>&#123;<br>    std::string maxWord, currWord;<br>    <span class="hljs-keyword">while</span> (ifs &gt;&gt; currWord) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">checkWord</span>(currWord))<br>            <span class="hljs-built_in">checkMax</span>(currWord, maxWord);<br>    &#125;<br>    std::cout &lt;&lt; maxWord &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-type">void</span> _9_49() &#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;../Resource/letter.txt&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">if</span>(!ifs) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">find_longest_noAscender_noDescender</span>(ifs);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="compare-函数"><a href="#compare-函数" class="headerlink" title="compare 函数"></a>compare 函数</h2><ul><li>除关系运算符外，标准库 string 提供 compare 函数</li><li>s.compare 根据 s 是大于、小于、等于参数给定的字符串，返回 正数、负数、零</li><li>compare 有 6 个版本</li></ul><div class="table-container"><table><thead><tr><th>Compare Arguments</th><th>Description</th></tr></thead><tbody><tr><td>s2</td><td>比较 s 和 s2</td></tr><tr><td>pos1, n1, s2</td><td>将 s 中从 pos1 开始的 n1 个字符与 s2 比较</td></tr><tr><td>pos1, n1, s2, pos2, n2</td><td>将 <strong>s 中从 pos1 开始的 n1 个字符</strong>，与 <strong>s2 中 pos2 开始的 n2个字符</strong>进行比较</td></tr><tr><td>cp</td><td>比较 s 与 cp 指向的以空字符结尾的字符数组</td></tr><tr><td>pos1, n1, cp</td><td>将 s 中从 pos1 开始的 n1 个字符，与 cp 指向的以空字符结尾的字符数组进行比较</td></tr><tr><td>pos1, n1, cp, n2</td><td>将 s 中从 pos1 开始的 n1 个字符，与 cp 指向的字符数组中前 n2 个字符进行比较</td></tr></tbody></table></div><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><div class="table-container"><table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td>to_string(val)</td><td>一组重载函数，返回 val 的 string 表示。<br> val 可以是任何算数类型。<br> 对每个浮点类型和 int 或更大的整型，都有相应版本的 to_string()</td></tr><tr><td>stoi(s, p, b) <br> stol(s, p, b) <br> stoul(s, p, b) <br> stoll(s, p, b) <br> stoull(s, p, b)</td><td><strong>返回</strong> s 的起始字符串（表示<strong>整数</strong>内容）的<strong>数值</strong>，返回类型分别是 int, long, unsigned long, long long, unsigned long long。<br> <strong>b 表示转换所用基数</strong>，<strong>默认值为 10</strong> <br> <strong>p 是 size_t 指针</strong>，用来<strong>保存 s 中第一个非数值字符的下标</strong>，p 默认是 0，即函数不保存下标</td></tr><tr><td>stof(s, p) <br> stod(s, p) <br> stold(s, p)</td><td><strong>返回</strong> s 的起始字符串（表示<strong>浮点数</strong>内容）的<strong>数值</strong>，返回类型分别是 float, double, long double。<br> <strong>p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标</strong>，默认 是 0，即函数不保存下标</td></tr></tbody></table></div><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testChangeNumber</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br>    std::string s = std::<span class="hljs-built_in">to_string</span>(i);<br>    <span class="hljs-type">double</span> d = std::<span class="hljs-built_in">stod</span>(s);<br><br>    std::string s2 = <span class="hljs-string">&quot;pi = 3.14&quot;</span>;<br>    <span class="hljs-comment">// 转换 s2 中以数字开始的第一个子串</span><br>    d = std::<span class="hljs-built_in">stod</span>(s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;+-.0123456789&quot;</span>)));     <span class="hljs-comment">// d = 3.14</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>string 中<strong>第一个非空白符</strong>必须是<strong>符号(+ 或 -)</strong> 或 <strong>数字</strong></li><li>string 可以以 <strong>0x</strong> 或 <strong>0X</strong> 开头来<strong>表示十六进制数</strong></li><li>字符串<strong>转为浮点数</strong>的函数，string 参数也<strong>可以以 (</strong>.<strong>) 开头</strong>, 并<strong>可以包含 e 或 E 来表示指数部分</strong></li><li>字符串转为<strong>整型值</strong>的函数，根据<strong>基数不同</strong>，<strong>string 参数可以包含字母字符</strong></li><li>若 string 不能转为一个数值，函数抛出 invalid_argument 异常。</li><li>如果转换后的数值无法用任何类型来表示，则抛出 out_of_range 异常</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>题目： 设计一个类，它有三个unsigned成员，分别表示年、月和日。为其编写构造函数，接受一个表示日期的string参数。你的构造函数应该能处理不同的数据格式，如January 1,1900、1/1/1990、Jan 1 1900 等。</p><ul><li><p>Date 类实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数接受表示日期的 string 参数</span><br>    <span class="hljs-comment">// 可以处理如 January 1, 1990、1/1/1990、Jan 1 1990 等不同数据格式</span><br>    <span class="hljs-built_in">Date</span>(std::string &amp; date);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">monthCovert</span><span class="hljs-params">(std::string &amp; s)</span></span>;<br>    <span class="hljs-type">unsigned</span> _year;<br>    <span class="hljs-type">unsigned</span> _month;<br>    <span class="hljs-type">unsigned</span> _day;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>构造函数实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">Date::<span class="hljs-built_in">Date</span>(std::string &amp;date) &#123;<br>    <span class="hljs-type">unsigned</span> format = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) != std::string::npos)<br>        format = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) != std::string::npos)&#123;<br>        format = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) == std::string::npos &amp;&amp; date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) == std::string::npos) &#123;<br>        format = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (format) &#123;<br>        <span class="hljs-comment">// 1/1/1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        &#123;<br>            _month = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>)));<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27;/&#x27;</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// January 1, 1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        &#123;<br>            <span class="hljs-keyword">auto</span> month = date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>            _month = <span class="hljs-built_in">monthCovert</span>(month);<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>( date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;123456789&quot;</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;,&#x27;</span>)), <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// Jan 1 1990</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        &#123;<br>            <span class="hljs-keyword">auto</span> month = date.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>));<br>            _month = <span class="hljs-built_in">monthCovert</span>(month);<br>            _day = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>,<br>                                        date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) - date.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27; &#x27;</span>)));<br>            _year = std::<span class="hljs-built_in">stoi</span>(date.<span class="hljs-built_in">substr</span>(date.<span class="hljs-built_in">find_last_of</span>(<span class="hljs-string">&#x27; &#x27;</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>));<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>monthCovert 私有成员实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">Date::monthCovert</span><span class="hljs-params">(std::string &amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jan&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Feb&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Mar&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Apr&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;May&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jun&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Jul&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Aug&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Sep&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Oct&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Nov&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;<br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Dec&quot;</span>) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>print 成员实现</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Date::print</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;year: &quot;</span> &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>            &lt;&lt; <span class="hljs-string">&quot;month: &quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>            &lt;&lt; <span class="hljs-string">&quot;day: &quot;</span> &lt;&lt; _day &lt;&lt; std::endl;<br>    std::cout &lt;&lt; _year &lt;&lt; <span class="hljs-string">&quot; 年 &quot;</span> &lt;&lt; _month &lt;&lt; <span class="hljs-string">&quot; 月 &quot;</span> &lt;&lt; _day &lt;&lt; <span class="hljs-string">&quot; 日&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试函数</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str;<br>    std::<span class="hljs-built_in">getline</span>(std::cin, str);<br>    <span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(str)</span></span>;<br>    date.<span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> string 操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.4 vector 对象如何增长</title>
      <link href="/2025/03/29/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.4%20vector%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E9%95%BF/"/>
      <url>/2025/03/29/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.4%20vector%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A2%9E%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="减少容器空间重新分配的策略"><a href="#减少容器空间重新分配的策略" class="headerlink" title="减少容器空间重新分配的策略"></a>减少容器空间重新分配的策略</h2><ul><li><strong>vector 和 string</strong> 在内存中是<strong>连续保存</strong>的，如果原先分配的内存已经用完，则会重新分配内存空间，将已有元素从旧空间移动到新空间，然后添加新元素</li><li>当不得不获取新的内存空间时，<strong>vector</strong> 和 <strong>string</strong> 通常<strong>分配比新的空间需求更大的内存空间</strong>，作为备用</li></ul><h2 id="管理容量的成员函数"><a href="#管理容量的成员函数" class="headerlink" title="管理容量的成员函数"></a>管理容量的成员函数</h2><div class="table-container"><table><thead><tr><th>Operating</th><th>Description</th></tr></thead><tbody><tr><td>c.shrink_to_fit()</td><td>将 capacity() 减少为与 size() 相同大小</td></tr><tr><td>c.capacity()</td><td>不重新分配内存空间，c 可以保存多少元素</td></tr><tr><td>c.reserve(n)</td><td>分配至少能容纳 n 个元素的内存空间</td></tr></tbody></table></div><ul><li><strong>shrink_to_fit()</strong> 只适用于 <strong>vector, string，deque</strong></li><li><strong>capacity</strong>：容器在<strong>不扩张内存空间</strong>的情况下<strong>可以容纳的元素数</strong></li><li><strong>reserve</strong>：告诉容器<strong>分配至少保存</strong>多少元素的<strong>内存空间</strong></li><li><strong>capacity</strong>，<strong>reserve</strong> 都只适用于 <strong>vector</strong>， <strong>string</strong></li></ul><h2 id="reserve、-resize-辨析"><a href="#reserve、-resize-辨析" class="headerlink" title="reserve、 resize 辨析"></a>reserve、 resize 辨析</h2><ul><li>reserve 不改变容器中元素的数量，仅影响 vector 预先分配多大的内存空间</li><li>只有当<strong>需要的内存空间超过当前容量</strong>时，调用 <strong>reserve</strong> 才会<strong>改变 vector 的容量</strong>；若<strong>不超过</strong>， reserve 什么也不做。</li><li><strong>resize</strong> <strong>只改变</strong>容器中<strong>元素数量</strong>，<strong>不改变容量大小</strong></li></ul><h2 id="capacity、size-辨析"><a href="#capacity、size-辨析" class="headerlink" title="capacity、size 辨析"></a>capacity、size 辨析</h2><ul><li>capacity 是容器在不重新分配内存的情况下最多能保存元素的数量</li><li>size 是指容器已经保存的元素数量</li><li>size 永远不可能大于 capacity</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> vector 增长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.1 IO 类</title>
      <link href="/2025/03/28/8.%20IO%E5%BA%93/8.1%20IO%20class/"/>
      <url>/2025/03/28/8.%20IO%E5%BA%93/8.1%20IO%20class/</url>
      
        <content type="html"><![CDATA[<h2 id="IO-库类型和头文件"><a href="#IO-库类型和头文件" class="headerlink" title="IO 库类型和头文件"></a>IO 库类型和头文件</h2><div class="table-container"><table><thead><tr><th style="text-align:center">头文件</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:center">iostream</td><td style="text-align:left">istream, wistream: 从流读出数据 <br> ostream, wostream: 向流写入数据 <br> iostream, wiostream: 读写流</td></tr><tr><td style="text-align:center">fstream</td><td style="text-align:left">ifstream, wifstream: 从文件读取数据 <br> ofstream, wofstream: 向文件写入数据 <br> iofstream, wiostream: 读写文件</td></tr><tr><td style="text-align:center">sstream</td><td style="text-align:left">istringstream, wistringstream: 从 string 读取数据 <br> ostringstream, wostringstream: 向 string 写入数据 <br> stringstream, wstringstream: 读写 string</td></tr></tbody></table></div><h3 id="IO-对象无拷贝或赋值"><a href="#IO-对象无拷贝或赋值" class="headerlink" title="IO 对象无拷贝或赋值"></a>IO 对象无拷贝或赋值</h3><ul><li>通常以<strong>引用</strong>的形式传递和返回流</li></ul><h3 id="条件状态-condition-state"><a href="#条件状态-condition-state" class="headerlink" title="条件状态(condition state)"></a>条件状态(condition state)</h3><div class="table-container"><table><thead><tr><th style="text-align:left">类型与函数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">strm::iostate</td><td style="text-align:left">strm 是一种 IO 类型，iostate 提供了表达condition state的完整功能</td></tr><tr><td style="text-align:left">strm::badbit</td><td style="text-align:left">用来指出流已崩溃</td></tr><tr><td style="text-align:left">strm::failbit</td><td style="text-align:left">用来指出一个 IO 操作失败了</td></tr><tr><td style="text-align:left">strm::eofbit</td><td style="text-align:left">用来指出流到达了文件结束</td></tr><tr><td style="text-align:left">strm::goodbit</td><td style="text-align:left">用来指出流未处于错误状态，此值保证为零</td></tr><tr><td style="text-align:left">s.eof()</td><td style="text-align:left">若流 s 的 eofbit 置位，返回 true</td></tr><tr><td style="text-align:left">s.fail()</td><td style="text-align:left">若 s 的 failbit / badbit 置位，则返回 true</td></tr><tr><td style="text-align:left">s.bad()</td><td style="text-align:left">若 s 的badbit 置位，则返回 true</td></tr><tr><td style="text-align:left">s.good()</td><td style="text-align:left">若 s 处于有效状态，则返回 true</td></tr><tr><td style="text-align:left">s.clear()</td><td style="text-align:left">将流 s 的所有条件状态位置位，将流的状态设置为有效，返回 void</td></tr><tr><td style="text-align:left">s.clear(flags)</td><td style="text-align:left">根据给定的 flag 标志位，将流中对应的条件状态位<strong>复位</strong>。flags 类型为 strm::iostate。返回 void</td></tr><tr><td style="text-align:left">s.setstate(flags)</td><td style="text-align:left">根据给定的 flag 标志位，将流中对应的条件状态位<strong>置位</strong>，flags 类型为 strm::iostate。返回 void</td></tr><tr><td style="text-align:left">s.rdstate()</td><td style="text-align:left">返回流 s 的当前条件状态，返回值类型为 strm::iostate</td></tr></tbody></table></div><h3 id="确定一个流状态的最简单方法"><a href="#确定一个流状态的最简单方法" class="headerlink" title="确定一个流状态的最简单方法"></a>确定一个流状态的最简单方法</h3><ul><li><p>将它作为<strong>条件</strong>来使用</p><p>  while 循环检查 &gt;&gt; 表达式返回的流状态。如果输入操作成功，则保持流状态，条件为真。</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cin &gt;&gt; word) &#123;<br>    <span class="hljs-comment">// ok: 读操作成功</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><ul><li>endl: 输出缓冲区内容和一个换行，然后刷新缓冲区</li><li>flush：输出缓冲区内容，刷新缓冲区，不附加任何字符</li><li>ends：输出缓冲区内容和一个空字符，然后刷新缓冲区</li></ul><h3 id="unitbuf-操纵符"><a href="#unitbuf-操纵符" class="headerlink" title="unitbuf 操纵符"></a>unitbuf 操纵符</h3><p>若想在<strong>每次输出操作后都刷新缓冲区</strong>，可以使用 <strong>unitbuf 操纵符</strong>。它使得流在接下来的每次写操作之后都进行一次 flush 操作。而 <strong>nounitbuf 操纵符</strong>则重置流，<strong>使流恢复正常</strong>的系统管理缓冲区刷新机制。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">cout &lt;&lt; unitbuf;    <span class="hljs-comment">// 之后所有输出操作后都会刷新缓冲区</span><br>                    <span class="hljs-comment">// 任何输出都立即刷新，无缓冲</span><br>cout &lt;&lt; nounitbuf;  <span class="hljs-comment">// 回到正常缓冲方式</span><br></code></pre></td></tr></table></figure><h3 id="关联输入流与输出流"><a href="#关联输入流与输出流" class="headerlink" title="关联输入流与输出流"></a>关联输入流与输出流</h3><ul><li>当一个输入流关联到输出流，任何从输入流读取数据的操作都会刷新关联的输出流</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> IO 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.2 文件输入输出流</title>
      <link href="/2025/03/28/8.%20IO%E5%BA%93/8.2%20%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
      <url>/2025/03/28/8.%20IO%E5%BA%93/8.2%20%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h2><ul><li><p>头文件：fstream.h</p></li><li><p>类型：</p><ul><li>ifstream</li><li>ofstream</li><li>fstream</li></ul></li></ul><hr><h2 id="fstream-特有操作"><a href="#fstream-特有操作" class="headerlink" title="fstream 特有操作"></a>fstream 特有操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left"><strong>fstream</strong> fstrm</td><td style="text-align:left">创建一个未绑定的文件流，fstream 是头文件 fstream 中定义的类型</td></tr><tr><td style="text-align:left"><strong>fstream</strong> fstrm(s)</td><td style="text-align:left">创建一个fstream object, 并打开名为 s 的文件。s 可以是 <strong>string</strong>，也可以是 <strong>C 风格字符串的指针</strong>，这些构造函数都是 explicit 的。<strong>默认文件 mode 依赖于 fstream 的类型</strong>。</td></tr><tr><td style="text-align:left"><strong>fstream</strong> fstrm(s, mode)</td><td style="text-align:left">按指定 mode 打开文件</td></tr><tr><td style="text-align:left">fstrm.open(s)</td><td style="text-align:left">打开一个名为 s 的文件，并将 s 与 fstrm 绑定。默认文件 mode 依赖于 fstream 的类型。返回 void</td></tr><tr><td style="text-align:left">fstrm.close()</td><td style="text-align:left">关闭与 fstrm 绑定的文件。返回 void</td></tr><tr><td style="text-align:left">fstrm.is_open()</td><td style="text-align:left">返回一个 bool 值，指出与 fstrm 绑定的文件是否成功打开且尚未关闭</td></tr></tbody></table></div><p><strong>NOTE:</strong> 当一个 fstream 对象被销毁时，close() 会自动被调用。</p><hr><h2 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Mode</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left">in</td><td style="text-align:left">以读的方式打开</td></tr><tr><td style="text-align:left">out</td><td style="text-align:left">以写的方式打开</td></tr><tr><td style="text-align:left">app</td><td style="text-align:left">每次写操作之前均定位到文件末尾</td></tr><tr><td style="text-align:left">ate</td><td style="text-align:left">打开文件后立即定位到文件末尾</td></tr><tr><td style="text-align:left">trunc</td><td style="text-align:left">截断文件</td></tr><tr><td style="text-align:left">binary</td><td style="text-align:left">以二进制方式进行 IO</td></tr></tbody></table></div><p><strong>NOTE:</strong> 指定文件模式有以下限制</p><ul><li>只可以对 <strong>ofstream 或 fstream 对象</strong>设定 <strong>out mode</strong></li><li>只可以对 <strong>ifstream 或 fstream 对象</strong>设定 <strong>in mode</strong></li><li>只有当 out 也被设定时，才可以设定 trunc</li><li>只要 trunc 没被设定，就可以设定 app 模式。<strong>app mode 下，默认指定 out mode</strong></li><li><strong>默认情况下</strong>，即使没有指定 trunc mode, 以 out mode 打开的文件也总会被截断。<strong>为了保留 out mode 下文件的内容，必须同时指定 app mode</strong>.</li><li><strong>ate mode 和 binary mode</strong> 可<strong>用于任何类型的文件流对象</strong>，且可以与其他任何文件 mode 组合使用</li><li>与 <strong>ifstream</strong> 关联的文件默认以 <strong>in mode</strong> 打开；与 <strong>ofstream</strong> 关联的文件默认以 <strong>out mode</strong> 打开；与 <strong>fstream</strong> 关联的文件默认以 <strong>in, out mode</strong>打开</li></ul><h3 id="out-mode-打开文件会丢弃已有数据"><a href="#out-mode-打开文件会丢弃已有数据" class="headerlink" title="out mode 打开文件会丢弃已有数据"></a>out mode 打开文件会丢弃已有数据</h3><ul><li>阻止一个 ofstream 清空数据的方法是<strong>显式指定 app mode 或 in mode</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 这几条语句中，file1 都被截断</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>)</span></span>;    <span class="hljs-comment">// 隐含以 out mode 打开文件并截断文件</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::out)</span></span>; <span class="hljs-comment">// 隐含的截断文件</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;<br><br><span class="hljs-comment">// 为保留文件内容，显式指定 app mode</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::app)</span></span>; <span class="hljs-comment">// 隐含为 out mode</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::app | ofstream::out)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="每次调用-open-确定文件模式"><a href="#每次调用-open-确定文件模式" class="headerlink" title="每次调用 open 确定文件模式"></a>每次调用 open 确定文件模式</h3><ul><li>调用 open 打开文件的<strong>默认文件模式</strong>是 <strong>out mode</strong>，而一般 out mode 意味着同时使用 trunc mode.</li><li>调用 open 打开文件，可以显式地指定文件模式</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> file stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.3 string 流</title>
      <link href="/2025/03/28/8.%20IO%E5%BA%93/8.3%20string%20stream/"/>
      <url>/2025/03/28/8.%20IO%E5%BA%93/8.3%20string%20stream/</url>
      
        <content type="html"><![CDATA[<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><pre><code>#include &lt;sstream&gt;</code></pre><p>头文件中定义了三个类类型来支持 IO：</p><ul><li><code>istringstream</code>: 从 string 读数据</li><li><code>ostringstream</code>: 从 string 写数据</li><li><code>stringstream</code>: 既可读，也可写</li></ul><h2 id="stringstream-特有的操作"><a href="#stringstream-特有的操作" class="headerlink" title="stringstream 特有的操作"></a>stringstream 特有的操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Implication</th></tr></thead><tbody><tr><td style="text-align:left">sstream strm</td><td style="text-align:left">strm 是一个未绑定的 stringstream 对象，sstream 是头文件中定义的一个类型</td></tr><tr><td style="text-align:left">sstream strm(s)</td><td style="text-align:left">strm 是个 stringstream 对象，保存 string s 的一个拷贝。<br> 此构造函数是 explicite 的</td></tr><tr><td style="text-align:left"><strong>strm.str()</strong></td><td style="text-align:left"><strong>返回所保存的 string 的拷贝</strong></td></tr><tr><td style="text-align:left"><strong>strm.str(s)</strong></td><td style="text-align:left"><strong>将 string s 拷贝到 strm 中，返回 void</strong></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> string stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Some Question about file stream in cpp</title>
      <link href="/2025/03/28/8.%20IO%E5%BA%93/IO%20file%20stream%20Question/"/>
      <url>/2025/03/28/8.%20IO%E5%BA%93/IO%20file%20stream%20Question/</url>
      
        <content type="html"><![CDATA[<h2 id="current-work-directory"><a href="#current-work-directory" class="headerlink" title="current work directory"></a>current work directory</h2><p>windows 获取当前工作目录：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;direct.h&gt;</span> <span class="hljs-comment">// windows</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> cwd[<span class="hljs-number">1024</span>];<br>    <span class="hljs-keyword">if</span> (_getcwd(cwd, <span class="hljs-built_in">sizeof</span>(cwd)) != <span class="hljs-literal">NULL</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;当前工作目录: &quot;</span> &lt;&lt; cwd &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;获取工作目录失败&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="file-path"><a href="#file-path" class="headerlink" title="file path"></a>file path</h2><p>例如打开一个文件：</p><ul><li><p>使用相对路径：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;../data/example.txt&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure><p> <strong>NOTE:</strong> <code>../</code> <strong>表示 current work directory 的父目录</strong></p></li><li><p>使用绝对路径：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">fstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;E:/WorkSpace/Employment/KnowledgeTest/data/example.txt&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="如何在文件处理中进行异常处理"><a href="#如何在文件处理中进行异常处理" class="headerlink" title="如何在文件处理中进行异常处理"></a>如何在文件处理中进行异常处理</h2><p>contents</p><h3 id="使用try-catch-机制捕获并处理异常"><a href="#使用try-catch-机制捕获并处理异常" class="headerlink" title="使用try-catch 机制捕获并处理异常"></a>使用try-catch 机制捕获并处理异常</h3><p>contents</p><h2 id="cpp-对字符串的处理"><a href="#cpp-对字符串的处理" class="headerlink" title="cpp 对字符串的处理"></a>cpp 对字符串的处理</h2><h3 id="find-funciton"><a href="#find-funciton" class="headerlink" title="find() funciton"></a>find() funciton</h3><ul><li>作用: 用于<strong>查找某个子字符串(或字符)首次出现的位置</strong>。</li><li>返回值：查找<strong>成功返回</strong>该子字符串的<strong>起始索引</strong>，查找<strong>失败返回 std::string::npos</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp; str, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li>str 是要查找的子字符串</li><li>ch 是要查找的字符</li><li>pos 是查找起始位置，默认从 0 开始。</li></ul><h4 id="KMP-算法原理"><a href="#KMP-算法原理" class="headerlink" title="KMP 算法原理"></a>KMP 算法原理</h4><p>contents</p><h3 id="replace-function"><a href="#replace-function" class="headerlink" title="replace() function"></a>replace() function</h3><ul><li>作用: 用于替换字符串中的一部分内容。可以替换<strong>字符、字符串、用迭代器指定的字符范围</strong>。</li><li><p><strong>语法:</strong></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string &amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> std::string &amp; str)</span></span>;<br><span class="hljs-function">std::string &amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> std::string &amp; str, <span class="hljs-type">size_t</span> subpos, <span class="hljs-type">size_t</span> sublen)</span></span>;<br><span class="hljs-function">std::string &amp; <span class="hljs-title">replace</span><span class="hljs-params">(const_iterator first, const_iterator last, <span class="hljs-type">const</span> std::string &amp; str)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>pos: 要替换的起始位置</p></li><li>len: 要替换的字符或子字符串的长度</li><li>str: 用于替换的字符串</li><li>subpos, sublen: 如果用于替换的字符串是另一个字符串的一部分，可以指定字符串的起始位置和长度</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> file stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1 顺序容器概述</title>
      <link href="/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.1%20Sequentail%20Containers/"/>
      <url>/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.1%20Sequentail%20Containers/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序容器类型"><a href="#顺序容器类型" class="headerlink" title="顺序容器类型"></a>顺序容器类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Type</th><th style="text-align:left">Description</th><th style="text-align:left">Application</th><th style="text-align:left">Time Complexity (insert/delete/visit)</th></tr></thead><tbody><tr><td style="text-align:left">vector</td><td style="text-align:left"><strong>动态数组</strong>, 支持<strong>随机访问</strong>，<strong>尾部之外</strong>的位置插入删除会很慢</td><td style="text-align:left">大部分场景首选</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr><tr><td style="text-align:left">list</td><td style="text-align:left"><strong>双向链表</strong>，支持<strong>双向顺序访问</strong>，在任何位置<strong>插入删除都很快</strong></td><td style="text-align:left">频繁的插入删除操作</td><td style="text-align:left">insert/delete O(1), visit O(n)</td></tr><tr><td style="text-align:left">deque</td><td style="text-align:left"><strong>双端队列</strong>，支持<strong>快速随机访问</strong>，<strong>头尾位置插入、删除速度很快</strong></td><td style="text-align:left">双端插入、删除操作</td><td style="text-align:left">insert/delete O(1), visit O(1)</td></tr><tr><td style="text-align:left">array</td><td style="text-align:left"><strong>定长数组</strong>，支持快速<strong>随机访问</strong>元素，<strong>不能添加或删除</strong>元素</td><td style="text-align:left">大小固定的数组</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr><tr><td style="text-align:left">forward_list</td><td style="text-align:left">单向链表，只支持<strong>单向顺序访问</strong>，在任何位置的插入删除都很快</td><td style="text-align:left">更节省内存的链表</td><td style="text-align:left">insert/delete O(1), visit O(n)</td></tr><tr><td style="text-align:left">string</td><td style="text-align:left">字符序列，与 vector 相似，<strong>专门用于保存字符</strong>。支持<strong>随机访问</strong>，<strong>尾部的插入删除速度快</strong></td><td style="text-align:left">存储和操作文本数据</td><td style="text-align:left">insert/delete O(n), visit O(1)</td></tr></tbody></table></div><p>NOTE: forward_list 中没有 size 操作。</p><h3 id="选择容器的基本原则"><a href="#选择容器的基本原则" class="headerlink" title="选择容器的基本原则"></a>选择容器的基本原则</h3><ul><li><strong>首选 vector</strong></li><li>程序有<strong>很多小的元素</strong>，且<strong>空间的额外开销</strong>很重要，则<strong>不要使用 list</strong> 或 <strong>forward_list</strong></li><li>要求<strong>随机访问元素</strong>，使用 <strong>vector</strong> 或 <strong>deque</strong></li><li>要求在容器<strong>中间插入或删除元素</strong>，使用 <strong>list</strong> 或 <strong>forward_list</strong></li><li>需要在容器<strong>头尾插入或删除元素</strong>，但<strong>不会在中间位置进行插入删除操作</strong>，使用 <strong>deque</strong></li><li><p>如果程序只有在<strong>读取输入时</strong>才需要在容器<strong>中间位置插入</strong>元素，随后需要<strong>随机访问元素</strong></p><ul><li>首先确定是否真的需要在容器中间位置添加元素。处理输入数据时，通常向 <strong>vector</strong> 追加元素，再使用<strong>标准库 sort 函数重排</strong>元素，避免在容器中间位置添加元素</li><li>如果必须在中间位置插入元素，考虑在<strong>输入阶段使用 list</strong>，一旦输入完成，将 <strong>list 内容拷贝到 vector</strong> 中</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 顺序容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2 容器库概览</title>
      <link href="/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.2%20%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88/"/>
      <url>/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.2%20%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h2 id="容器的通用操作"><a href="#容器的通用操作" class="headerlink" title="容器的通用操作"></a>容器的通用操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">类型别名</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">iterator</td><td style="text-align:left">此容器类型的迭代器类型</td></tr><tr><td style="text-align:left">const_iterator</td><td style="text-align:left">可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td style="text-align:left">size_type</td><td style="text-align:left">无符号整数类型，足够保存此种容器类型最大可能容器大小</td></tr><tr><td style="text-align:left">difference_type</td><td style="text-align:left">带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td style="text-align:left">value_type</td><td style="text-align:left">元素类型</td></tr><tr><td style="text-align:left">reference</td><td style="text-align:left">元素的左值类型，与 <code>value_type &amp;</code> 含义相同</td></tr><tr><td style="text-align:left">const_reference</td><td style="text-align:left">元素的 const 左值类型 (即 <code>const value_type &amp;</code> )</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">构造函数</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">C c</td><td style="text-align:left">默认构造函数</td></tr><tr><td style="text-align:left">C c1(c2)</td><td style="text-align:left">构造 c2 的拷贝 c1</td></tr><tr><td style="text-align:left">C c(b, e)</td><td style="text-align:left">构造 c, 将迭代器 b 和 e 指定范围内的元素拷贝到 c (<strong>array 不支持</strong>)</td></tr><tr><td style="text-align:left">C c{a, b, c, …} <br> C c = {a, b, c, …}</td><td style="text-align:left">列表初始化, c 初始化为列表中元素的拷贝，列表元素类型必须与 C 中元素类型相容；对于 array，列表中<strong>元素数量必须小于等于 array 大小</strong></td></tr><tr><td style="text-align:left">C seq(n)</td><td style="text-align:left">seq 包含 n 个元素，元素进行了值初始化；此构造函数是 explicit。<strong>string 不适用</strong></td></tr><tr><td style="text-align:left">C seq(n, t)</td><td style="text-align:left">seq 包含 n 个 值初始化为 t 的元素</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">赋值与 swap</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1 = c2</td><td style="text-align:left">将 c1 中的元素替换为 c2 中的元素</td></tr><tr><td style="text-align:left">c1 = {a, b, c, …}</td><td style="text-align:left">将 c1 中的元素替换为列表中的元素(不支持 array)</td></tr><tr><td style="text-align:left">a.swap(b)</td><td style="text-align:left">交换 a 和 b 的元素</td></tr><tr><td style="text-align:left">swap(a, b)</td><td style="text-align:left">与 a.swap(b) 等价</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">大小</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.size()</td><td style="text-align:left">c 中元素的数目(不支持 forward_list)</td></tr><tr><td style="text-align:left">c.max_size()</td><td style="text-align:left">c 中可保存的最大元素数目</td></tr><tr><td style="text-align:left">c.empty()</td><td style="text-align:left">若 c 中存储了元素，返回 false，否则返回 true</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">添加/刪除元素(不适用于 array)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.insert(args)</td><td style="text-align:left">将 args 中的元素拷贝到 c 中</td></tr><tr><td style="text-align:left">c.emplace(inits)</td><td style="text-align:left">使用 inits 构造 c 中的一个元素</td></tr><tr><td style="text-align:left">c.eraser(args)</td><td style="text-align:left">删除 args 指定的的元素</td></tr><tr><td style="text-align:left">c.clear()</td><td style="text-align:left">删除 c 中的所有元素，返回 void</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">关系运算符</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">==, !=</td><td style="text-align:left">所有容器都支持</td></tr><tr><td style="text-align:left">&lt;, &lt;=, &gt;, &gt;=</td><td style="text-align:left">无需关联容器不支持</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">获取迭代器</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c.begin(), c.end()</td><td style="text-align:left">返回指向 c 的首元素和尾元素之后位置的迭代器</td></tr><tr><td style="text-align:left">c.cbegin(), c.cend()</td><td style="text-align:left">返回 const_iterator</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">反向容器的额外成员(不支持 forward_list)</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">reverse_iterator</td><td style="text-align:left">按逆序寻址元素的迭代器</td></tr><tr><td style="text-align:left">const_reverse_itrator</td><td style="text-align:left">不能修改元素的逆序迭代器</td></tr><tr><td style="text-align:left">c.rbegin(), c.rend()</td><td style="text-align:left">返回指向尾元素和首元素之前位置的迭代器</td></tr><tr><td style="text-align:left">c.crbegin(), c.crend()</td><td style="text-align:left">返回 const_reverse_itrator</td></tr></tbody></table></div><hr><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="若-begin-end-构成合法的迭代器范围"><a href="#若-begin-end-构成合法的迭代器范围" class="headerlink" title="若 begin, end 构成合法的迭代器范围"></a>若 begin, end 构成合法的迭代器范围</h3><ul><li>begin==end, 容器为空</li><li>begin!=end, 容器至少含有一个元素</li><li>可以通过对 begin 的若干次递增，使得 begin==end</li></ul><h3 id="begin-end-有多个版本"><a href="#begin-end-有多个版本" class="headerlink" title="begin, end 有多个版本"></a>begin, end 有多个版本</h3><ul><li>begin, end：正常版本，支持对容器读写操作</li><li>cbegin, cend：const 版本，只支持对容器读操作</li><li>rbegin, rend：返回反向迭代器，支持读写操作</li><li>crbegin, crend：const 版本反向迭代器，只支持读操作</li></ul><p><strong>NOTE：</strong></p><ul><li>forward_list 不支持递减运算符 “—“；</li></ul><hr><h2 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h2><ul><li>迭代器类型</li><li>反向迭代器类型</li><li>通过<strong>类型别名</strong>，可以在不知道元素类型的情况下使用它<ul><li>需要<strong>元素类型</strong>，使用容器的 <strong>value_type</strong></li><li>需要<strong>元素类型的引用</strong>，使用容器的 <strong>reference</strong> 或 <strong>const_reference</strong></li></ul></li></ul><hr><h2 id="容器定义与初始化"><a href="#容器定义与初始化" class="headerlink" title="容器定义与初始化"></a>容器定义与初始化</h2><h3 id="将一个容器初始化为另一个容器的拷贝"><a href="#将一个容器初始化为另一个容器的拷贝" class="headerlink" title="将一个容器初始化为另一个容器的拷贝"></a>将一个容器初始化为另一个容器的拷贝</h3><ul><li>直接拷贝整个容器</li><li>拷贝由一个迭代器对指定的范围( array 除外)</li><li>当将一个容器初始化为另一个容器的拷贝时，<strong>容器类型</strong>和<strong>元素类型必须相同</strong></li><li><p>使用迭代器范围的构造函数：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 拷贝元素，直到（但不包括）it 指向的元素</span><br><span class="hljs-function">deque&lt;string&gt; <span class="hljs-title">authList</span><span class="hljs-params">(author.begin(), it)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="与顺序容器大小有关的构造函数"><a href="#与顺序容器大小有关的构造函数" class="headerlink" title="与顺序容器大小有关的构造函数"></a>与顺序容器大小有关的构造函数</h3><ul><li><p><strong>只有顺序容器</strong>(不包含 array)才能<strong>接受大小参数</strong>, 关联容器不支持</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">C <span class="hljs-title">seq</span><span class="hljs-params">(n)</span></span>;       <span class="hljs-comment">// seq 包含了 n 个元素，这些元素进行了值初始化，</span><br>                <span class="hljs-comment">// 此构造函数是 explicit 的，string 不适用</span><br><span class="hljs-function">C <span class="hljs-title">seq</span><span class="hljs-params">(n, v)</span></span>;    <span class="hljs-comment">// seq 包含 n 个值为 v 的元素</span><br></code></pre></td></tr></table></figure></li><li><p>array 具有固定大小，使用 <strong>array 时必须指定元素类型与大小</strong></p></li><li><p>array 不支持普通的容器构造函数，一个默认构造的 array 是非空的，元素都进行默认初始化</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>, 10&gt; ia1;        <span class="hljs-comment">// 数组类型包括元素类型与大小</span><br>array&lt;<span class="hljs-type">int</span>, 10&gt; ia2 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; ia3 = &#123;<span class="hljs-number">42</span>&#125;; <span class="hljs-comment">// ia3[0] 的元素为42，其余元素为 0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>内置数组类型不能进行拷贝或对象赋值操作</strong>，但 array 可以</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> digs[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-type">int</span> cop[<span class="hljs-number">10</span>] = digs;     <span class="hljs-comment">// 错误！内置数组类型不支持拷贝或赋值</span><br>array&lt;<span class="hljs-type">int</span>, 10&gt; digits = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; copys = digits;      <span class="hljs-comment">// 正确：只要数组类型匹配即合法</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="赋值与-swap"><a href="#赋值与-swap" class="headerlink" title="赋值与 swap"></a>赋值与 swap</h2><ul><li>赋值运算符将其左边容器中的全部元素替换为右边容器中的拷贝，大小也变得与右边容器相等</li><li><p>array 类型允许赋值，“=” 左右容器类型与元素类型必须相同（包括 <strong>array 的大小</strong>）</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">array&lt;<span class="hljs-type">int</span>, 10&gt; a1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;<br>array&lt;<span class="hljs-type">int</span>, 10&gt; a2 = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-comment">// 10 个元素全部初始化为 0</span><br>a1 = a2;    <span class="hljs-comment">// 替换 a1 中的元素</span><br></code></pre></td></tr></table></figure></li><li><p>由于 “=” 左右容器大小可能不容，array 不支持 assign，也不允许 {} 包围的值列表进行赋值（<strong>注意区分赋值与初始化</strong>）</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">a2 = &#123;<span class="hljs-number">0</span>&#125;;   <span class="hljs-comment">// 错误！不允许值列表进行赋值</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="容器赋值运算"><a href="#容器赋值运算" class="headerlink" title="容器赋值运算"></a>容器赋值运算</h3><div class="table-container"><table><thead><tr><th style="text-align:left">Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1 = c2</td><td style="text-align:left">将 c1 中的元素替换为 c2 中元素的拷贝。c1, c2 必须具有相同类型</td></tr><tr><td style="text-align:left">c = {a, b, c, …}</td><td style="text-align:left">将 c 中的元素替换为列表中元素的拷贝。<strong>array 不支持</strong></td></tr></tbody></table></div><h3 id="使用-assign-成员"><a href="#使用-assign-成员" class="headerlink" title="使用 assign 成员"></a>使用 assign 成员</h3><ul><li>顺序容器(array 除外)定义了 assign 成员，assign 操作用参数指定的元素的拷贝替换左边容器中的所有元素</li><li><strong>assign</strong> 允许从一个<strong>不同但相容的类型赋值</strong></li><li><strong>assign</strong> 允许从<strong>容器的一个子序列赋值</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">assign Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">seq.assign(b, e)</td><td style="text-align:left">将 seq 中的元素替换为迭代器 b, e所指向范围内的元素(<strong>迭代器b,e不能指向 seq</strong>)</td></tr><tr><td style="text-align:left">seq.assign(il)</td><td style="text-align:left">将 seq 中的元素替换为初始化列表 il 中的元素</td></tr><tr><td style="text-align:left">seq.assign(n, v)</td><td style="text-align:left">将 seq 中的元素替换为 n 个值为 v 的元素</td></tr></tbody></table></div><p><strong>NOTE:</strong></p><ul><li><strong>assign 操作不能用于关联容器和 array</strong></li></ul><h3 id="使用-swap"><a href="#使用-swap" class="headerlink" title="使用 swap"></a>使用 swap</h3><div class="table-container"><table><thead><tr><th style="text-align:left">Swap Operation</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left">c1. swap(c2) <br> swap(c1, c2)</td><td style="text-align:left">交换 c1, c2中的元素(c1 和 c2 必须具有相同的类型)。<strong>swap 通常比从 c2 向 c1 拷贝元素快</strong></td></tr></tbody></table></div><ul><li>除 array 外，交换两个容器内容的操作很快——<strong>容器本身并未交换，只是交换了两个容器的内部数据结构</strong></li><li>除 array 外，<strong>swap 不对任何元素进行拷贝、删除或插入操作</strong>，因此可以保证在常数时间内完成。</li><li>swap 两个 <strong>array</strong> 会真正交换它们的元素</li><li>标准库中既提供成员函数版本的 swap, 也提供非成员函数版本的 swap</li></ul><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li><strong>赋值相关运算</strong>会<strong>导致</strong>指向<strong>左边容器内部</strong>的<strong>迭代器、引用和指针失效</strong>，而<strong>除 string 外</strong>，<strong>swap</strong> 操作将容器内容交换<strong>不会导致</strong>指向容器的迭代器、引用、指针失效</li></ul><hr><h2 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h2><ul><li>成员函数 size, 返回容器中元素的数目</li><li>empty：当 size 为 0 时返回 true, 否则返回 false</li><li>max_size: 返回一个大于或等于该容器所能容纳的最大元素数量的值</li><li>forward_list 支持 max_size 和 empty, 不支持 size</li></ul><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><ul><li><strong>每个容器</strong>都支持相等运算符 <strong>“==”</strong> 和 <strong>“!=”</strong></li><li><strong>除无序容器外</strong>的所有容器<strong>都支持</strong>关系运算符：<strong>“&gt;, &gt;=, &lt;, &lt;=”</strong></li><li>关系运算符左右两边的<strong>容器必须是相同类型</strong>，且<strong>保存相同类型元素</strong></li></ul><h3 id="运算符工作方式与-string-相似"><a href="#运算符工作方式与-string-相似" class="headerlink" title="运算符工作方式与 string 相似"></a>运算符工作方式与 string 相似</h3><ul><li>两容器大小相等，所有元素两两对应相等，则两容器相等</li><li>两容器大小不等，小容器中元素都等于大容器中对应位置元素，则小容器小于大容器</li><li>两容器都不是另一个容器的前缀子序列，它们的比较结果取决于第一个不相等的元素</li></ul><h3 id="容器的关系运算符使用元素的关系运算符完成比较"><a href="#容器的关系运算符使用元素的关系运算符完成比较" class="headerlink" title="容器的关系运算符使用元素的关系运算符完成比较"></a>容器的关系运算符使用元素的关系运算符完成比较</h3><ul><li>只有元素类型也定义了相应的比较运算符时，容器才可以使用关系运算符比较</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 容器库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3 顺序容器操作</title>
      <link href="/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.3%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2025/03/28/9.%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/9.3%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h2><ul><li>除 array 外，所有容器都可以动态添加或删除元素</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.push_back(t) <br> c.emplace_back(args)</td><td>在 c 的尾部创建一个值为 t 或由 args 创建的元素。返回 void</td></tr><tr><td>c.push_front(t) <br> c.emplace_front(args)</td><td>在 c 的头部创建一个值为 t 或由 args 创建的元素。返回void</td></tr><tr><td>c.insert(p, t) <br> c.emplace(p, args)</td><td>在迭代器 <strong>p 指向的元素之前</strong>创建一个值为 t 或由 args 创建的元素。<strong>返回指向新添加元素的迭代器</strong></td></tr><tr><td>c.insert(p, n, t)</td><td>在迭代器 <strong>p 指向的元素之前</strong>插入 n 个值为 t 的元素。<strong>返回指向新添加的第一个元素的迭代器</strong>；若 <strong>n 为 0</strong>，则<strong>返回 p</strong>。</td></tr><tr><td>c.insert(p, begin, end)</td><td>将迭代器 begin 和 end 指向范围内的元素插入到迭代器 p 指向的元素之前。<strong>begin 和 end 不能指向 c 中的元素</strong>。<strong>返回指向新添加第一个元素的迭代器</strong>；若<strong>范围为空</strong>，则<strong>返回 p</strong></td></tr><tr><td>c.insert(p, il)</td><td>il 是 {} 包围的元素值列表。将这些给定值插入到迭代器 p 指向的元素之前。<strong>返回指向新添加第一个元素的迭代器</strong>；若列表为空，则返回 p</td></tr></tbody></table></div><ul><li>forward_list 有自己专有版本的 insert 和 emplace</li><li><strong>forward_list</strong> <strong>不支持</strong> push_back 和 emplace_back</li><li><strong>vector 和 string 不支持</strong> push_front 和 emplace_front</li><li>向 <strong>vector、string、deque 插入元素</strong>会使指向容器的<strong>所有迭代器、引用、指针失效</strong></li><li>不同容器使用不同的内存分配策略</li><li>在 <strong>vector 或 string 尾部之外</strong>，或 <strong>deque 的首尾之外</strong>的任何位置<strong>添加元素</strong>，都<strong>需要移动元素</strong></li><li>向 vector 或 string 添加元素，可能引起整个对象存储空间的重新分配。重新分配对象存储空间需要重新分配内存，并将元素从旧的内存空间移动到新的内存空间</li></ul><h3 id="元素容器是拷贝"><a href="#元素容器是拷贝" class="headerlink" title="元素容器是拷贝"></a>元素容器是拷贝</h3><ul><li>使用对象来初始化容器，或将一个对象插入到容器中时，实际放入容器的是对象的拷贝</li></ul><h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><ul><li>vector, string, list, deque 都支持 push_back</li></ul><h3 id="push-front"><a href="#push-front" class="headerlink" title="push_front"></a>push_front</h3><ul><li>list, forward_list, deque 支持 push_front</li><li>vector 不支持 push_front</li></ul><h3 id="在容器特定位置添加元素"><a href="#在容器特定位置添加元素" class="headerlink" title="在容器特定位置添加元素"></a>在容器特定位置添加元素</h3><ul><li>vector, deque, list, string 都支持 insert</li><li>forward_list 有自己版本的 insert</li><li><p>有些容器不支持 push_front，但支持 insert，可以用 insert 在容器开始位置添加元素</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; vec;<br>vec.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">begin</span>(), <span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="emplace-操作"><a href="#emplace-操作" class="headerlink" title="emplace 操作"></a>emplace 操作</h4><ul><li>emplace, emplace_front, emplace_back 是<strong>构造元素</strong>，而不是拷贝元素</li><li>调用 push 或 insert 成员，是将元素类型的对象传递给它们，这些<strong>对象被拷贝到容器中</strong></li><li>调用 emplace 成员，是将参数传递给元素类型的构造函数。emplace 成员使用参数在容器管理的内存空间直接构造元素</li><li>传递给 emplace 函数的参数必须与元素类型的构造函数相匹配</li></ul><hr><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><ul><li>所有顺序容器都有 front 成员函数，返回首元素引用</li><li><strong>除 forward_list 之外</strong>，所有顺序容器都有 back 成员函数，返回尾元素引用</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.back()</td><td>返回 c 中尾元素的引用。若 c 为空，则函数行为未定义</td></tr><tr><td>c.front()</td><td>返回 c 中首元素的引用。若 c 为空，则函数行为未定义</td></tr><tr><td>c[n]</td><td>返回 c 中下标为 n 的元素的引用。n 是无符号整数，若 n &gt; c.size(), 则函数行为未定义</td></tr><tr><td>c.at(n)</td><td>返回 c 中下标为 n 的元素的引用。如果下标越界，抛出 out_of_range 异常</td></tr></tbody></table></div><ul><li>at 只适用于 string，vector，deque，array</li><li>back 不适用于 forward_list</li></ul><hr><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.pop_back()</td><td>删除 c 中尾元素。若 c 为空，函数行为未定义。返回 void</td></tr><tr><td>c.pop_front()</td><td>删除 c 中首元素。若 c 为空，函数行为未定义。返回 void</td></tr><tr><td>c.erase(p)</td><td>删除迭代器 p 指向的元素，<strong>返回一个指向被删元素之后元素的迭代器</strong>。若 p 指向尾元素，则返回尾后(off-the-end)顶点。若 p 是尾后迭代器，函数行为未定义</td></tr><tr><td>c.erase(b, e)</td><td>删除迭代器 b, e 指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器。若 e 本身是尾后迭代器，则返回的也是尾后迭代器</td></tr><tr><td>c.clear()</td><td>删除 c 中所有元素，返回 void</td></tr></tbody></table></div><ul><li>这些删除操作会改变容器大小，因此不适用于 array</li><li>forward_list 有自己版本的 erase</li><li>f<strong>orward_list 不支持 pop_back</strong></li><li><strong>vector、string 不支持 pop_fron</strong>t</li><li>删除 <strong>deque 除首尾之外</strong>的元素，会使所有迭代器、引用、指针失效</li><li>指向 <strong>vector 或 string 删除点之后位置</strong>的迭代器、引用、指针失效</li><li>删除元素的成员函数不检查参数，因此必须确保被删除元素存在</li></ul><hr><h2 id="forward-list-特殊操作"><a href="#forward-list-特殊操作" class="headerlink" title="forward_list 特殊操作"></a>forward_list 特殊操作</h2><ul><li>在单向链表中，没有简单的方法来获取一个元素的前驱。</li><li>在 forward_list 中添加删除操作都是通过<strong>改变给定元素之后的元素</strong>来完成</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>lst.before_begin() <br> lst.cbefore_begin()</td><td><strong>返回指向链表首元素之前不存在元素的迭代器</strong>。此迭代器<strong>不能解引用</strong>。cbefore_begin 返回 const_iterator</td></tr><tr><td>lst.insert_after(p, t) <br> lst.insert_after(p, n, t) <br> lst.insert_after(p, b, e) <br> lst.insert(p, il)</td><td>在迭代器 <strong>p 之后的位置插入元素</strong>。<br> t 是一个对象，n 是数量，b 和 e 是一对表示范围的迭代器（<strong>b，e 不能指向 lst 内</strong>），il 是一个花括号列表。<br> <strong>返回指向最后一个插入元素的迭代器</strong>。如果<strong>范围为空，则返回 p</strong>。如果 p 是尾后迭代器，则函数行为未定义</td></tr><tr><td>emplace_after(p, args)</td><td>使用 args 在 <strong>p 指定位置之后创建</strong>一个元素。<br> <strong>返回一个指向新元素的迭代器</strong>。若 p 为尾后迭代器，函数行为未定义</td></tr><tr><td>lst.erase_after(p) <br> lst.erase_after(b, e)</td><td>删除迭代器 <strong>p 指定位置之后</strong>的元素。或删除 <strong>从 b 之后直到（但不包括） e</strong> 之间的元素。<br> <strong>返回一个指向被删元素之后元素的迭代器</strong>。若<strong>不存在</strong>这样的元素，<strong>返回尾后迭代器</strong>；如果 <strong>p 指向 lst 的尾元素</strong>或者是<strong>尾后迭代器</strong>，函数行为未定义</td></tr></tbody></table></div><ul><li><p>在 forward_list 中添加或删除元素时，必须关注两个迭代器：一<strong>个指向要处理的元素</strong>，另<strong>一个指向其前驱</strong></p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">forward_list&lt;<span class="hljs-type">int</span>&gt; flst&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">auto</span> prev = flst.<span class="hljs-built_in">before_begin</span>();        <span class="hljs-comment">// 指向 flst 的首前元素</span><br><span class="hljs-keyword">auto</span> curr = flst.<span class="hljs-built_in">begin</span>();               <span class="hljs-comment">// 指向 flst 的首元素</span><br><span class="hljs-keyword">while</span> (curr != flst.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (*curr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        curr = flst.<span class="hljs-built_in">erase_after</span>(prev);  <span class="hljs-comment">// 删除元素并移动 curr</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev = curr;                    <br>        ++curr;                         <span class="hljs-comment">// 移动 curr，指向下一个元素，prev 指向 curr 前驱</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h2><ul><li>使用 <strong>resize</strong> 增大或缩小容器大小</li><li>当前大小 &lt; 要求大小，容器后面元素会被删除</li><li>当前大小 &gt; 要求大小，会将新元素添加到容器后面</li></ul><div class="table-container"><table><thead><tr><th>Operation</th><th>Description</th></tr></thead><tbody><tr><td>c.resize(n)</td><td>调整 c 的大小为 n 个元素。<br> 若 n &lt; c.size(), 则多出的元素会被删除 <br> 若必须添加新元素，则对新元素进行值初始化</td></tr><tr><td>c.resize(n, t)</td><td>调整 c 的大小为 n 个元素。<br> 任何新添加的元素都初始化为 t</td></tr></tbody></table></div><ul><li>resize 不适用于 array</li><li>如果 resize 缩小容器大小，则指向被删除元素的迭代器、指针、引用都失效</li><li>对 vector、string、deque 使用 resize 可能导致迭代器、引用、指针失效</li></ul><hr><h2 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h2><h3 id="向容器添加元素后"><a href="#向容器添加元素后" class="headerlink" title="向容器添加元素后"></a>向容器添加元素后</h3><ul><li><strong>vector</strong> 、<strong>string</strong>：<strong>存储空间被重新分配</strong>，则指向容器的<strong>迭代器、引用、指针失效</strong>；<strong>存储空间未重新分配</strong>，则指向<strong>插入元素之前</strong>的<strong>迭代器、引用、指针有效</strong>，指向<strong>插入元素之后</strong>的<strong>迭代器、引用、指针都失效</strong></li><li><strong>deque</strong>：插入到<strong>首尾位置之外</strong>的任何位置<strong>都会使迭代器、引用、指针失效</strong>。<strong>首尾位置添加元素</strong>，<strong>迭代器会失效</strong>，<strong>但</strong>指向容器内元素的<strong>引用、指针不会失效</strong></li><li><strong>list</strong>、<strong>forward_list</strong>：<strong>迭代器、指针、引用仍有效</strong></li></ul><h3 id="从容器删除元素后"><a href="#从容器删除元素后" class="headerlink" title="从容器删除元素后"></a>从容器删除元素后</h3><ul><li><strong>vector、string</strong>：指向<strong>被删元素之前</strong>的迭代器、引用、指针仍有效</li><li><strong>deque</strong>：<strong>首尾之外</strong>删除元素，指向被删元素之外的<strong>其他迭代器、引用、指针都失效</strong>。<strong>删除尾元素</strong>，<strong>尾后迭代器失效</strong>，其他迭代器、引用、指针仍有效。<strong>删除首元素</strong>，不会受影响</li><li><strong>list、forward_list</strong>：指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用、指针<strong>仍有效</strong></li></ul><h3 id="不要保存-end-返回的迭代器"><a href="#不要保存-end-返回的迭代器" class="headerlink" title="不要保存 end 返回的迭代器"></a>不要保存 end 返回的迭代器</h3><ul><li>vector、string 添加删除元素，或 deque 除首位置之外添加删除元素，都<strong>会导致尾后迭代器失效</strong>，因此添加删除元素的循环过程必须反复调用 end()，不能在循环前保存 end</li></ul><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ul><li><strong>复合赋值语句</strong>（+=）只适用于 vector、string、deque、array，<strong>不适用于 list，forward_list</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 顺序容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 类的其他特性</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.3%20%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.3%20%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="定义类型成员"><a href="#定义类型成员" class="headerlink" title="定义类型成员"></a>定义类型成员</h2><p>自定义某种类型在类中的别名：</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>typedef std::string::size_type pos;</code> 等价于 <code>using pos = std::string::size_type;</code></p><h2 id="令成员作为内联函数"><a href="#令成员作为内联函数" class="headerlink" title="令成员作为内联函数"></a>令成员作为内联函数</h2><ul><li>在类内部使用 <code>inline</code>作为函数声明的一部分，将函数显示的声明为内联函数</li><li><p>也可以在类外部用 <code>inline</code> 关键字修饰函数的定义</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];        <span class="hljs-comment">// 隐式内联</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">// 显示内联</span><br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br>&#125;;<br></code></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">inline</span>                          <span class="hljs-comment">// 在函数定义处指定 inline</span><br><span class="hljs-function">Screen&amp; <span class="hljs-title">Screen::move</span><span class="hljs-params">(Screen::pos r, Screen::pos c)</span> </span>&#123;<br>    pos row = r * width;        <span class="hljs-comment">// 计算行的位置</span><br>    cursor = row + c;           <span class="hljs-comment">// 将光标移动到指定的列</span><br>    <span class="hljs-keyword">return</span>  *<span class="hljs-keyword">this</span>;              <span class="hljs-comment">// 以左值的形式返回对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(Screen::pos r, Screen::pos c)</span> <span class="hljs-type">const</span> </span>&#123;      <span class="hljs-comment">// 在类的内部声明为内联函数</span><br>    pos row = r * width;        <span class="hljs-comment">// 计算行的位置</span><br>    <span class="hljs-keyword">return</span> contents[row + c];   <span class="hljs-comment">// 返回给定列的字符</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h2><ul><li><p>可变数据成员(mutable data member)永远不会是 cosnt, 即使它是const 对象的成员。因此一个 const 成员函数可以改变一个可变成员的值</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>通过 access_ctr 可变成员，追踪成员函数被调用次数</p></li><li>some_member() 是一个 const 成员函数，但依旧可以改变 access_ctr 可变成员的值</li></ul><h2 id="类数据成员的初始值"><a href="#类数据成员的初始值" class="headerlink" title="类数据成员的初始值"></a>类数据成员的初始值</h2><p>定义一个窗口管理类并用它表示显示器上的一组 Screen。这个类包含一个 Screen 类型的 vector，每个元素表示一个特定的 Screen，默认情况下，Window_mgr 类有一个默认初始化的 Screen</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br>    std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&#x27; &#x27;</span>)&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>类内初始值必须使用 <strong>=的初始化形式</strong>或者 <strong>{}的直接初始化形式</strong></li></ul><h2 id="返回-this-的成员函数"><a href="#返回-this-的成员函数" class="headerlink" title="返回 *this 的成员函数"></a>返回 *this 的成员函数</h2><ul><li><p>添加函数，负责设置光标所在位置字符或其他任一给定位置字符</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd) &#123; contents = ht * wd, <span class="hljs-string">&#x27; &#x27;</span>; &#125;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(pos, pos, <span class="hljs-type">char</span>)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br>&#125;;<br></code></pre></td></tr></table></figure>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> </span>&#123;<br>    contents[cursor] = c;       <span class="hljs-comment">// 设置当前光标所在位置新值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;               <span class="hljs-comment">// 将 this 对象作为左值返回</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span></span><br><span class="hljs-function">Screen &amp; <span class="hljs-title">Screen::set</span><span class="hljs-params">(pos r, pos col, <span class="hljs-type">char</span> c)</span> </span>&#123;<br>    contents[r*width + col] = c;        <span class="hljs-comment">// 设置指定位置的值</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                       <span class="hljs-comment">// 将 this 对象作为左值返回</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>返回引用的函数是左值的，这些函数返回对象本身而不是对象的副本。此时可进行如下操作：</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 把光标移动到指定位置，然后设置该位置的值</span><br>myscreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>).<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="从-const-成员函数返回-this"><a href="#从-const-成员函数返回-this" class="headerlink" title="从 const 成员函数返回 *this"></a>从 const 成员函数返回 *this</h3><p>添加 display() 操作，负责打印 Screen 的内容。</p><ul><li>若将 display() 设置为 const, 则 this 是指向 const 的指针，而 *this 是 const 对象</li><li>一个 <strong>const 成员函数</strong>如果以<strong>引用</strong>形式返回 *this，那么它的<strong>返回类型是常量引用</strong></li></ul><h3 id="基于-const-的重载"><a href="#基于-const-的重载" class="headerlink" title="基于 const 的重载"></a>基于 const 的重载</h3><p>由于非常量版本函数对于常量对象不可用，所以重载一个 const 版本的成员函数很有必要</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> std::string::size_type pos;<br>    <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd) &#123; contents = ht * wd, <span class="hljs-string">&#x27; &#x27;</span>; &#125;<br>    <span class="hljs-built_in">Screen</span>(pos ht, pos wd, <span class="hljs-type">char</span> c) : <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd), <span class="hljs-built_in">contents</span>(ht * wd, c) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 读取光标处的字符</span><br>        <span class="hljs-keyword">return</span> contents[cursor];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht, pos wd)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>;<br><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">set</span><span class="hljs-params">(pos, pos, <span class="hljs-type">char</span>)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// 根据对象是否是 const 重载了 display 函数</span><br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp; os)</span> </span>&#123;<br>        <span class="hljs-built_in">do_display</span>(os); <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> Screen &amp; <span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">do_display</span>(os);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    pos cursor = <span class="hljs-number">0</span>;<br>    pos height = <span class="hljs-number">0</span>, width = <span class="hljs-number">0</span>;<br>    std::string contents;<br><br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr;      <span class="hljs-comment">// 即使在一个 const 对象内也能被修改</span><br><br>    <span class="hljs-comment">// 该函数负责显示 Screen 的内容</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp; os)</span> <span class="hljs-type">const</span> </span>&#123; os &lt;&lt; contents; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 do_display 完成后，display 返回解引用 this 所得的对象</p><ul><li>非常量版本中，<strong>this 指向一个非常量对象</strong>，因此 display 返回一个 非常量引用</li><li>const 成员中，<strong>this 指向一个常量对象</strong>，display返回一个常量引用</li></ul><h2 id="类之间的友元关系"><a href="#类之间的友元关系" class="headerlink" title="类之间的友元关系"></a>类之间的友元关系</h2><p>A 类若想访问 B 类的私有成员，需要被 B 类声明为友元。</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-comment">// window_mgr 成员可以访问 Screen 的私有成员</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span>;<br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br>    std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>, <span class="hljs-number">80</span>, <span class="hljs-string">&#x27; &#x27;</span>)&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(window_mgr::ScreenIndex i)</span> </span>&#123;<br>    <span class="hljs-comment">// s 是 Screen 的引用，指向想清空的那个 Screen</span><br>    Screen &amp;s = screens[i];<br>    <span class="hljs-comment">// 将选定 Screen 重置为空白</span><br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将 window_mgr 声明为 Screen 的友元，则 window_mgr 的成员可以访问 Screen 的私有成员</li><li><strong>友元关系不存在传递性</strong>，每个类负责控制自己的友元类或友元函数</li></ul><h2 id="成员函数作为友元"><a href="#成员函数作为友元" class="headerlink" title="成员函数作为友元"></a>成员函数作为友元</h2><h3 id="程序设计步骤"><a href="#程序设计步骤" class="headerlink" title="程序设计步骤"></a>程序设计步骤</h3><ul><li><strong>首先，定义 window_mgr 类</strong>，在其中声明 clear 成员，但不定义它。<strong>在 clear 函数使用 Screen 的成员之前必须声明 Screen 类</strong></li><li><strong>接下来定义 Screen,</strong> 包括对于 clear 的友元声明</li><li><strong>最后定义 clear</strong>, 此时它才可以使用 Screen 的成员</li></ul><p>Screen 只为 window_mgr 的成员 clear 提供访问权限</p><h3 id="详细代码示例"><a href="#详细代码示例" class="headerlink" title="详细代码示例"></a>详细代码示例</h3><ol><li><p>首先<strong>定义 window_mgr 类</strong></p><ul><li>在 window_mgr.h 中使用 Screen 类的<strong>前置声明</strong>，防止循环依赖</li><li><p>在 window_mgr 类中<strong>声明 clear 成员</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 默认情况下，一个 window_mgr 包含一个标准尺寸的空白 Screen</span><br><span class="hljs-comment">//    std::vector&lt;Screen&gt; screens&#123;Screen(24, 80, &#x27; &#x27;)&#125;;</span><br>    std::vector&lt;Screen&gt; screens;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>其次<strong>定义 Screen 类</strong></p><ul><li>在 <strong>Screen.h</strong> 文件中使用 <code>#include &quot;window_mgr.h&quot;</code>，使得 <strong>clear 声明在 Screen 类之前</strong></li><li><p>在 Screen 类中声明 clear 为友元函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;window_mgr.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span> &#123;<br>    <span class="hljs-comment">// window_mgr 成员可以访问 Screen 的私有成员</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(ScreenIndex)</span></span>;  <span class="hljs-comment">// 声明window_mgr的clear为友元函数</span><br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>最后<strong>定义 clear 成员</strong></p><ul><li>在 window_mgr.cpp 中 包含 Screen.h, 使得 <strong>Screen 类的声明在 clear 定义之前</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;window_mgr.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Screen.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(window_mgr::ScreenIndex i)</span> </span>&#123;<br>    <span class="hljs-comment">// s 是 Screen 的引用，指向想清空的那个 Screen</span><br>    Screen &amp;s = screens[i];<br>    <span class="hljs-comment">// 将选定 Screen 重置为空白</span><br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="编译器对-Screen-h-Screen-cpp-window-mgr-h-window-mgr-cpp-的处理过程"><a href="#编译器对-Screen-h-Screen-cpp-window-mgr-h-window-mgr-cpp-的处理过程" class="headerlink" title="编译器对 Screen.h, Screen.cpp, window_mgr.h, window_mgr.cpp 的处理过程"></a>编译器对 Screen.h, Screen.cpp, window_mgr.h, window_mgr.cpp 的处理过程</h3><pre class="mermaid">flowchart TD    A["Screen.cpp"]    A --> B["#include "Screen.h""]    B --> C["#include "window_mgr.h""]    C --> D["窗口管理器(window_mgr)的完整声明（含 friend 声明）"]    B --> E["Screen 类定义（友元声明：friend void window_mgr::clear(ScreenIndex);)"]    subgraph TU1["Screen.cpp的翻译单元"]        D        E    end</pre><ul><li>Screen.cpp 中包含 <strong>Screen.h</strong> ,Screen.h 中包含 <strong>window_mgr.h</strong></li><li>此时 window_mgr 已经完整，能正确处理友元声明</li><li>这个翻译单元中包含了 Screen.cpp 的代码，Screen.h 中 Screen 类的定义及友元声明，window_mgr.h 中 window_mgr 的声明（此时 <strong>window_mgr 内部对 Screen 的引用只需前向声明即可</strong>）</li></ul><pre class="mermaid">flowchart TD    A["window_mgr.CPP"]    A --> B["#include "window_mgr.h""]    B --> C["window_mgr 类定义（包含对 Screen 的前向声明）"]    A --> D["#include "Screen.h""]    D --> E[Screen 类的完整定义（含友元声明）]    subgraph "TU2: Window_mgr.cpp 翻译单元"        C        E    end</pre><ul><li><strong>window_mgr.cpp</strong> 首先包含 <strong>window_mgr.h</strong>，这时 window_mgr 中对 Screen 的引用仅为前向声明</li><li>随后在 <strong>window_mgr.cpp</strong> 中包含 <strong>Screen.h</strong>(通过包含获得 Screen.h 的完整定义)，从而可以在 <strong>window_mgr.cpp</strong> 中使用 Screen 类的 <strong>public 成员</strong></li><li>也可以让 clear() 使用 Screen 类的私有成员(clear 已被声明为友元)</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 类的特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 类的作用域</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.4%20%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.4%20%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="作用域和定义在类外部的成员"><a href="#作用域和定义在类外部的成员" class="headerlink" title="作用域和定义在类外部的成员"></a>作用域和定义在类外部的成员</h2><ol><li><p>为什么类外部定义成员函数必须提供类名和函数名</p><ul><li>一个类就是一个作用域</li><li><p>一旦遇到类名，定义的剩余部分就在类的作用域之内，包括参数列表和函数体</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">window_mgr::clear</span><span class="hljs-params">(ScreenIndex i)</span> </span>&#123;<br>    Screen &amp;s = screens[i];<br>    s.contents = std::<span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译器在处理参数列表之前已经明确了当前正处于 window_mgr 类作用域中，所以不必专门说明 ScreenIndex 是 window_mgr 类定义的。</li><li>screens 也是同理</li></ul></li></ul></li><li><p>函数的返回类型必须指明它是哪个类的成员</p><ul><li><p>函数返回类型在函数名之前，当成员函数定义在类外部时，返回类型中使用的名字在类作用域外部，因此<strong>必须指明返回类型是哪个类的成员</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">window_mgr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;<br>    ......<br><br>    <span class="hljs-comment">// 向窗口添加一个 Screen, 返回它的编号</span><br>    <span class="hljs-function">ScreenIndex  <span class="hljs-title">addScreen</span><span class="hljs-params">(<span class="hljs-type">const</span> Screen &amp;)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">window_mgr::ScreenIndex             <span class="hljs-comment">// 首先处理返回类型</span><br>        window_mgr::<span class="hljs-built_in">addScreen</span>(<span class="hljs-type">const</span> Screen &amp; s) &#123;<br>    screens.<span class="hljs-built_in">push_back</span>(s);<br>    <span class="hljs-keyword">return</span> screens.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要想使用 ScreenIndex 作为返回类型，<strong>必须明确指明哪个类定义了它</strong></li></ul></li></ul></li></ol><h2 id="名字查找-name-lookup"><a href="#名字查找-name-lookup" class="headerlink" title="名字查找(name lookup)"></a>名字查找(name lookup)</h2><ol><li><p><strong>一般查找过程</strong></p><ul><li>首先在名字所在块儿中寻找声明语句，只考虑在名字使用前出现的声明</li><li>如果没找到，继续查找外层作用域</li><li>如果最终没有找到匹配声明，程序报错</li></ul></li><li><p>对于<strong>定义在类内部的成员函数</strong></p><ul><li><strong>首先，编译成员的声明</strong></li><li>直到<strong>类全部可见后才编译函数体</strong></li></ul></li><li><p><strong>类型名</strong>要特殊处理</p><ul><li><strong>一般的</strong>，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过</li><li><strong>特殊</strong>：在类中，如果成员使用了外层作用域的某个名字，改名字代表类型，则<strong>类不能在之后重新定义该名字</strong></li></ul></li><li><p><strong>成员定义中的普通块作用域的名字查找</strong></p><ul><li>在成员函数内查找该名字声明，同样只考虑函数使用之前出现的名字</li><li>成员函数内没找到，则在类内查找，类的所有成员都可以被考虑</li><li>类内没找到，在成员函数定义之前的作用域内查找</li></ul></li><li><p>类的作用域之后，<strong>在外围作用域查找</strong></p><ul><li>在函数和类中没有找到声明，则在类的外部作用域查找</li><li>若需要使用外层作用域中的同名的名字，可以使用<code>::</code>作用域运算符来进行请求</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 类的作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 再探构造函数</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.5%20%E5%86%8D%E6%8E%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.5%20%E5%86%8D%E6%8E%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h2><h3 id="构造函数的初始值有时必不可少"><a href="#构造函数的初始值有时必不可少" class="headerlink" title="构造函数的初始值有时必不可少"></a>构造函数的初始值有时必不可少</h3><ul><li>如果<strong>成员是 const 或者 引用</strong>，则<strong>必须将其初始化</strong></li><li>必须<strong>通过构造函数初始值列表</strong>为成员提供初值，而<strong>不是通过赋值</strong></li></ul><h3 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h3><ul><li>构造函数初始化列表<strong>只说明用于初始化成员的值</strong>，而<strong>不限定初始化顺序</strong></li><li>成员<strong>初始化顺序与类定义中出现顺序一致</strong></li><li>当一个成员是用另一个成员初始化时，<strong>必须保持类中定义顺序与初始化列表顺序的一致</strong></li></ul><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><ul><li>如果一个构造函数为所有参数提供了默认实参，它实际上也定义了默认构造函数</li></ul><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><ul><li>delegating constructor: 一个委托构造函数使用它所属类的其他构造函数执行自己的初始化过程</li><li>委托构造函数也有成员初始值列表和函数体</li></ul><p>使用委托构造函数重写 Sale_data 类</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br><br>    ......<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 非委托构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>(std::string s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>            <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br><br>    <span class="hljs-comment">// 委托构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() : <span class="hljs-built_in">Sale_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s) : <span class="hljs-built_in">Sale_data</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::istream &amp;is) : <span class="hljs-built_in">Sale_data</span>() &#123; <span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>); &#125;<br><br>   ......<br><br><span class="hljs-keyword">private</span>:<br>    ......<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h2><p>默认初始化在下面情况发生：</p><ul><li>当在块作用域内不使用任何初始值定义一个非静态变量或数组时</li><li>当一个类本身含有类类型的成员且使用合成的默认构造函数时</li><li>当类类型的成员没有在构造函数初始值列表中显式地初始化时</li></ul><p>值初始化在以下情况发生：</p><ul><li>数组初始化过程中提供的初始值数量少于数组大小时</li><li>当不使用一个初始值定义局部静态变量时</li><li>当通过书写形如 T() 的表达式显式的请求初始化时(其中 T 是类型名)</li></ul><h2 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h2><ul><li>能通过一个实参调用的构造函数定义了一条<strong>从构造函数的参数类型</strong>向<strong>类类型</strong>隐式转换的规则</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::string null_book = <span class="hljs-string">&quot;9-9999-9999&quot;</span>;<br><span class="hljs-comment">// 构造一个临时的 Sale_data 对象</span><br><span class="hljs-comment">// 该对象成员 bookNo = null_book, units_sold 和 revenue 都等于 0</span><br>item.<span class="hljs-built_in">combine</span>(null_book);<br></code></pre></td></tr></table></figure><ul><li>这里使用 string 实参调用 Sale_data 的 combine 成员，编译器用给定的 string 自动创建了一个 Sale_data 对象，这个临时对象被传递给 combine</li><li>combine 的参数是 常量引用，所以可以给该参数传递一个临时量</li></ul><h3 id="只允许一步类型转换"><a href="#只允许一步类型转换" class="headerlink" title="只允许一步类型转换"></a>只允许一步类型转换</h3><ul><li>编译器只会自动地执行<strong>一步类型转换</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>);    <span class="hljs-comment">// 错误，编译器不会将&quot;9-9999-9999&quot;转换为 Sale_data对象</span><br></code></pre></td></tr></table></figure><ul><li>可以显式的将字符串转换成 string 或者 Sale_data 对象：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">item.<span class="hljs-built_in">combine</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>));<br><br>item.<span class="hljs-built_in">combine</span>(<span class="hljs-built_in">Sale_data</span>(<span class="hljs-string">&quot;9-9999-9999&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="通过-explicit-阻止隐式的类类型转换"><a href="#通过-explicit-阻止隐式的类类型转换" class="headerlink" title="通过 explicit 阻止隐式的类类型转换"></a>通过 explicit 阻止隐式的类类型转换</h3><ul><li>在构造函数声明时，可加入 <strong>explicit 关键字</strong>阻止隐式类类型转换</li><li>explicit 只对一个实参的构造函数有效</li><li>只能在<strong>类内声明构造函数</strong>时使用 <strong>explicit</strong></li><li>explicit 构造函数<strong>只能用于直接初始化</strong>，不能用于拷贝初始化(=)等</li></ul><h2 id="聚合类-aggregate-class"><a href="#聚合类-aggregate-class" class="headerlink" title="聚合类(aggregate class)"></a>聚合类(aggregate class)</h2><ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类，没有 virtual 函数</li></ul><h2 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h2><ul><li>数据成员是字面值常量的聚合类是字面值常量类</li><li><p>如果不是聚合类，但符合以下要求，也是字面值常量类：</p><ul><li>数据成员必须是字面值类型</li><li>类必须至少含有机一个 constexpr 构造函数</li><li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式；或者如果成员属于某种类型，则初始值必须使用成员自己的 constexpr 构造函数</li><li>类必须使用析构函数的默认定义，该成员负责销毁类的对象</li></ul></li></ul><h3 id="constexpr-构造函数"><a href="#constexpr-构造函数" class="headerlink" title="constexpr 构造函数"></a>constexpr 构造函数</h3><ul><li>构造函数不能是 const 的，但字面值常量类的构造函数可以是 constexpr 函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6 类的静态成员</title>
      <link href="/2025/03/24/7.%20%E7%B1%BB/7.6%20%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
      <url>/2025/03/24/7.%20%E7%B1%BB/7.6%20%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>使用 <strong>static 关键字</strong>声明静态成员，可以是 public 的，也可以是 private 的。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>&#123; amount += amount * interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">rate</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> interestRate; &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">rate</span><span class="hljs-params">( <span class="hljs-type">double</span> )</span></span>;<br><span class="hljs-keyword">private</span>:<br>    std::string owner;<br>    <span class="hljs-type">double</span> amount;<br>    <span class="hljs-type">static</span> <span class="hljs-type">double</span> interestRate;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">initRate</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>static 成员存在于任何对象之外，对象中不包含与静态成员有关的任何数据</li><li>静态成员函数不和任何对象绑定在一起，不包含 this 指针</li><li><strong>静态成员不能被声明为 const</strong>， 在 <strong>static 函数体内不能使用 this 指针</strong></li></ul><h2 id="使用静态成员"><a href="#使用静态成员" class="headerlink" title="使用静态成员"></a>使用静态成员</h2><ul><li>使用<strong>作用域运算符</strong>直接访问静态成员</li><li>使用类的对象、引用或指针访问静态成员</li><li>成员函数不用通过作用域运算符就可直接使用静态成员</li></ul><h2 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h2><ul><li>既可以在类内部定义，也可以在类外部定义</li><li>在外部定义时，<strong>不能重复使用</strong> static 关键字；和其他成员一样，必须<strong>指明成员所属类名</strong></li><li><strong>不能在类内部初始化静态成员</strong>，一般必须在类外部定义和初始化静态成员</li><li>类似全局变量，静态成员一旦被定义，就一致<strong>存在于程序的整个生命周期</strong></li><li><p>定义静态成员需要指定对象的类型名，然后是类名、作用域运算符、成员自己的名字</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义并初始化一个静态成员</span><br><span class="hljs-type">double</span> Account::interestRate = <span class="hljs-built_in">initRate</span>();<br></code></pre></td></tr></table></figure></li></ul><h2 id="静态成员类内初始化"><a href="#静态成员类内初始化" class="headerlink" title="静态成员类内初始化"></a>静态成员类内初始化</h2><ul><li>一般静态成员不在类内初始化，但是可以为静态成员提供 <strong>const 整数类型</strong>的类内初始值，要求静态成员必须是字面值常量类型的 constexpr。初始值必须是常量表达式。</li></ul><h2 id="静态成员可用于特殊场景"><a href="#静态成员可用于特殊场景" class="headerlink" title="静态成员可用于特殊场景"></a>静态成员可用于特殊场景</h2><ul><li>静态成员可以是<strong>不完全类型</strong></li><li><p>静态成员的类型可以就是它所属的类类型</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ......<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Bar mem1; <br>    Bar *mem2;<br>    Bar mem3;       <span class="hljs-comment">// 错误：数据成员必须是完全类型</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>可以使用<strong>静态成员作为默认实参</strong>，而非静态成员不行</p></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Screen &amp; <span class="hljs-title">clear</span><span class="hljs-params">( <span class="hljs-type">char</span> = bkground)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> bkground;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 静态成员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My first blog</title>
      <link href="/2025/03/20/My-first-blog/"/>
      <url>/2025/03/20/My-first-blog/</url>
      
        <content type="html"><![CDATA[<h2 id="This-is-my-first-blog"><a href="#This-is-my-first-blog" class="headerlink" title="This is my first blog"></a>This is my first blog</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1 定义抽象数据类型</title>
      <link href="/2025/03/20/7.%20%E7%B1%BB/7.1%20%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/03/20/7.%20%E7%B1%BB/7.1%20%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Sale-item-class"><a href="#Sale-item-class" class="headerlink" title="Sale_item class"></a>Sale_item class</h2><p>Sale_item class 的作用是表示一本书的总销售额、售出册数、平均售价</p><h2 id="设计-Sale-data-class"><a href="#设计-Sale-data-class" class="headerlink" title="设计 Sale_data class"></a>设计 Sale_data class</h2><ol><li><p>Sale_data 的接口应该包含以下操作：</p><ul><li><strong>isbn 成员函数</strong>，返回对象的 ISBN 编号</li><li><strong>combine 成员函数</strong>，将一个 Sale_data 对象加到另一个对象上</li><li><strong>add 函数</strong>，执行两个 Sale_data 对象的加法</li><li><strong>read 函数</strong>，将数据从 istream 读入到 Sale_data 对象中</li><li><strong>print 函数</strong>，将 Sale_data 对象的值输出到 ostream</li></ul></li><li><p>Sale_data class 数据成员</p><ul><li><strong>bookNo</strong>———string 类型：表示 ISBN 编号</li><li><strong>units_sold</strong>——-unsigned 类型：表示某本书的销量</li><li><strong>revenue</strong>———double 类型：表示这本书的总销售收入</li><li><strong>avg_price 成员函数</strong>，返回售出书籍的平均价格</li></ul></li></ol><ul><li>成员函数声明必须在 class 内部，定义可以在外部，也可以在内部</li><li>非成员函数声明与定义都在 class 外部</li><li>定义在 class 内部的函数是隐式 inline 函数</li></ul><h2 id="Sale-data-class-声明与定义"><a href="#Sale-data-class-声明与定义" class="headerlink" title="Sale_data class 声明与定义"></a>Sale_data class 声明与定义</h2><h3 id="Sale-data-h"><a href="#Sale-data-h" class="headerlink" title="Sale_data.h"></a>Sale_data.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br><br><span class="hljs-comment">// Sale_data 的非成员接口函数</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;, <span class="hljs-type">const</span> Sale_data &amp;)</span></span>;<br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp;, Sale_data &amp;)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="解读std-string-isbn-const-return-bookNo"><a href="#解读std-string-isbn-const-return-bookNo" class="headerlink" title="解读std::string isbn() const { return bookNo; }"></a>解读<code>std::string isbn() const &#123; return bookNo; &#125;</code></h3><ul><li><p><strong>this 隐式形参</strong>：</p><ul><li><code>std::string isbn() const &#123; return bookNo; &#125;</code> 等价于 <code>std::string isbn() const &#123; return this.bookNo; &#125;</code>，当一个 Sale_data 对象调用 isbn() 时，编译器将<strong>这个对象的地址</strong>传递给 isbn() 的<strong>隐式形参 this</strong>，相当于 <code>this-&gt;bookNo</code>，所以这条语句中可以直接使用 <code>return bookNo</code></li><li>this 是一个<strong>常量指针</strong>，不允许改变 this 中保存的地址</li></ul></li><li><p><strong>const 成员函数</strong></p><ul><li>在这里使用 const 成员函数的考虑是：无论 <strong>Sale_data 是常量对象</strong>还是<strong>非常量对象</strong>，<strong>都可以调用</strong> isbn()，提高 isbn() 成员函数的灵活性</li><li>一般情况，this 是一个指向<strong>类类型非常量版本</strong>的<strong>常量</strong>指针，为了使 isbn() 只能读取调用它的对象的 data member, 而不能写入新值，就需要改变 this 这个隐式形参类型，使其成为<strong>指向常量对象</strong>的<strong>常量指针</strong>。这种<strong>指向常量对象的常量指针</strong>，也<strong>允许</strong>它指向<strong>非常量对象</strong></li><li>紧随参数列表之后的 const 表示 this 是一个指向常量对象的常量指针。像这种使用 const 的成员函数称为<strong>常量成员函数(const member function)</strong></li><li><strong>NOTE:</strong> 常量对象，常量对象的引用或指针，都只能调用常量成员函数</li></ul></li></ul><h3 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h3><ul><li>在 class 外部定义成员函数，<strong>必须与 class 内部的声明保持一致</strong></li><li><p>class 外部定义的成员的名字<strong>必须包含它所属的类名</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sale_data::avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">if</span> (units_sold)<br>    <span class="hljs-keyword">return</span> revenue / units_sold;<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="定义返回-this-对象的函数"><a href="#定义返回-this-对象的函数" class="headerlink" title="定义返回 this 对象的函数"></a>定义返回 this 对象的函数</h3><ul><li><p>函数 combine 的设计类似复合赋值运算符 <strong>+=</strong>, 内置赋值运算符把它<strong>左侧运算对象当成左值返回</strong>，combine 函数也应模仿此操作，返回调用 combine() 的 Sale_data 对象的引用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Sale_data &amp; <span class="hljs-title">Sale_data::combine</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp; rhs)</span> </span>&#123;<br>    units_sold += rhs.units_sold;<br>    revenue += rhs.revenue;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;       <span class="hljs-comment">// 返回调用该函数的对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="定义类相关的非成员函数"><a href="#定义类相关的非成员函数" class="headerlink" title="定义类相关的非成员函数"></a>定义类相关的非成员函数</h3><ul><li>一般的，如果非成员函数是类接口的组成部分，则这些函数的<strong>声明应与类在同一个头文件中</strong></li><li><p>IO 类是<strong>不能被拷贝</strong>的类型，只能通过<strong>引用传递</strong>；读取和写入会<strong>改变 IO 流的内容</strong>，因此函数接受 IO 的<strong>普通引用</strong>，而不是对常量的引用</p>  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输入交易信息包括 ISBN, 售出总数，售出价格</span><br><span class="hljs-function">std::istream &amp; <span class="hljs-title">read</span><span class="hljs-params">(std::istream &amp; is, Sale_data &amp; item)</span> </span>&#123;<br>    <span class="hljs-type">double</span> price = <span class="hljs-number">0</span>;<br>    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;<br>    item.revenue = price * item.units_sold;<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-function">std::ostream &amp; <span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp; os, <span class="hljs-type">const</span> Sale_data &amp; item)</span> </span>&#123;<br>    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>        &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-built_in">avg_price</span>();<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">// 接受两个 Sale_data 对象，返回一个新的 Sale_data 对象，用于表示两个对象的和</span><br><span class="hljs-function">Sale_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sale_data &amp;lhs, <span class="hljs-type">const</span> Sale_data &amp;rhs)</span> </span>&#123;<br>    Sale_data sum = lhs;<br>    sum.<span class="hljs-built_in">combine</span>(rhs);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul><li>构造函数名字<strong>与类名相同</strong></li><li>构造函数<strong>没有返回类型</strong></li><li>构造函数有参数列表（可能为空）和函数体（可能为空）</li><li>构造函数<strong>不能被声明为 const</strong></li><li>若没有显示的定义构造函数，编译器会隐式的定义一个<strong>默认构造函数(default constructor)</strong></li><li>合成的 default constructor 只适用于非常简单的类<ul><li>只有当类<strong>没有声明任何构造函数</strong>时，编译器才会自动生成 default constructor</li><li>如果类内包含内置类型或复合类型（数组、指针等），只有当这些成员全部被赋予类内初始值时，这个类才适用于合成的默认构造函数</li><li>如果类内包含其他类类型成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员</li></ul></li></ul><h3 id="定义-Sale-data-的构造函数"><a href="#定义-Sale-data-的构造函数" class="headerlink" title="定义 Sale_data 的构造函数"></a>定义 Sale_data 的构造函数</h3><ul><li>constructor1: istream &amp;, 从中读取一条交易信息</li><li>constructor2: const string &amp;, 表示 ISBN 编号；unsigned， 表示售出图书数量；double, 表示图书的售出价格</li><li>constructor3: const string &amp;, 表示 ISBN 编号；其他成员由编译器赋予默认值</li><li>constructor4: 空参数列表（default constructor）</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sale_data</span>&#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Sale_data</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">const</span> std::string &amp;s) : <span class="hljs-built_in">bookNo</span>(s) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::string &amp;s, <span class="hljs-type">unsigned</span> n, <span class="hljs-type">double</span> p) :<br>        <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(n), <span class="hljs-built_in">revenue</span>(p) &#123; &#125;<br>    <span class="hljs-built_in">Sale_data</span>(std::istream &amp; );<br><br>    <span class="hljs-comment">// 成员函数：关于 Sale_data 对象的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;<br>    <span class="hljs-function">Sale_data &amp; <span class="hljs-title">combine</span><span class="hljs-params">( <span class="hljs-type">const</span> Sale_data&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// data member</span><br>    std::string bookNo; <span class="hljs-comment">// ISBN 编号</span><br>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 某本书的销量</span><br>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;   <span class="hljs-comment">// 这本书的总销售收入</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>= default</strong>: 让编译器自动生成构造函数</li><li><strong>构造函数初始值列表(constructor initialize list)</strong>： “:”之后 “{}” 之前的部分。作用是接受参数列表的内容，赋值给相应成员，未被赋值的成员由编译器赋默认值</li></ul><h3 id="类外部定义构造函数"><a href="#类外部定义构造函数" class="headerlink" title="类外部定义构造函数"></a>类外部定义构造函数</h3><ul><li><p>与其他函数一样，必须指明这个构造函数是哪个类的成员</p><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 接受 istream &amp; 的构造函数</span><br>Sale_data::<span class="hljs-built_in">Sale_data</span>(std::istream &amp; is) &#123;<br>    <span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这个函数没有 constructor initialize list，所以在调用它时，类内成员将通过类内值初始化或执行默认初始化</p></li><li>read() 的第二个参数是 Sale_data 对象的引用，使用 *this 将 “this”对象作为实参传递给 read 函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer </tag>
            
            <tag> 定义抽象数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/20/hello-world/"/>
      <url>/2025/03/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
